<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>硬件组2023-2024-2 最终考核</title>
      <link href="/2024/06/23/dian-zi-dian-li/ying-jian-zu-kao-he/ying-jian-zu-2023-2024-2-zui-zhong-kao-he/"/>
      <url>/2024/06/23/dian-zi-dian-li/ying-jian-zu-kao-he/ying-jian-zu-2023-2024-2-zui-zhong-kao-he/</url>
      
        <content type="html"><![CDATA[<h2 id="考核须知"><a href="#考核须知" class="headerlink" title="考核须知"></a>考核须知</h2><ol><li>不要直接把喂给<strong>Chatgpt</strong>或者CSDN的答案直接<strong><em>复制粘贴</em></strong>，请让人至少看上去你消化过Chatgpt的答案，用自己的话或者理解去叙述会加分。</li><li>答案配图是个好习惯，交md/pdf会更好。</li><li>开卷就是让大家去网上寻找解决问题的方法，即使最终你没有解决出来这个问题，请体现出来你为了解决这个问题做出了什么程度的努力？（看过并总结<del>（吐槽）</del>文章，不限方法）</li><li>祝大家答题<del>（期末）</del>愉快<del>（喜</del>  </li></ol><h1 id="考核内容"><a href="#考核内容" class="headerlink" title="考核内容"></a>考核内容</h1><p>现给出一个48V-&gt;24V 10A 的需求，使用MP9929搭建Buck电路<br>自行阅读MP9929 DataSheet， 回答下列问题：</p><ol><li>开关频率靠什么调节？当开关频率是1Khz时应该如何修改电路？开关频率的高低对电路元件有什么要求或影响？</li><li>栅极驱动电源来自MP9929本身吗？如果不来自于本身，如何利用分立元件搭出符合要求的外部电路？</li><li>电流限制有几个挡位？</li><li>如何调节输出电压？应该如何搭配电阻使得MP9929能够输出24V或19V？（必须使用立创商城有货的电阻）</li><li>Typical Application Ciruits中，$C5$的作用是什么？</li><li>MP9929能够控制的最大输出电压是多少？</li><li>假设目前的开关频率是1KHz，计算电感的感值并挑选合适的电感。（给出公式来源，有推导过程加分）</li><li>如果实际的感值比计算值偏大或偏小，会对电路造成什么影响？</li><li>为什么航模电池上电会打火？如何避免打火？有几种方法？</li><li>假设输出电容的容值组成为：100nF+10uF * 3+470uF ，按照上面计算的感值，计算输出纹波。</li><li>MLCC的实际容值会受到哪些因素的影响？</li><li>如何计算$R_{SENSE}$的大小？为什么用到这个电阻？如何选型？需要注意什么？</li><li>如何挑选一个合适的MOS？MOS的什么参数会影响本身的开关速度？</li><li>在BST上串接电阻的意义是什么？除去串接电阻外有没有其他方式能够达到和串接电阻一样的效果？</li><li>为什么在$Figure 9$的电路中，$R_{SENSE}$被放在了低侧（靠近GND）而非像12V输出时，放在电感和输出电容之间？</li><li>写出Layout 要求，并尝试绘制原理图和PCB。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件组 </tag>
            
            <tag> 原神 </tag>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程学导论</title>
      <link href="/2024/06/11/gong-cheng-xue-dao-lun/gong-cheng-xue-dao-lun/"/>
      <url>/2024/06/11/gong-cheng-xue-dao-lun/gong-cheng-xue-dao-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="铁路信号系统"><a href="#铁路信号系统" class="headerlink" title="铁路信号系统"></a>铁路信号系统</h1><ol><li>铁路信号的基本颜色有红、绿、黄，辅助颜色有蓝和月白</li><li>电动转辙机每转换一次，锁闭齿轮和锁闭齿条快完成了解锁，转换和锁闭三个过程</li><li>道岔按锁闭方式有内锁闭和外锁闭，ZD6使用间接锁闭方式，S700K使用直接锁闭方式。</li><li>继电器接点的接触方式有点接触，线接触和面接触三种</li><li>根据能源供应和信息提供方式，应答器可分为由有源应答器和无源应答器 ![[Pasted image 20240611185420.png]]<h1 id="什么是科学及科学思维"><a href="#什么是科学及科学思维" class="headerlink" title="什么是科学及科学思维"></a>什么是科学及科学思维</h1>用科学方法研究自然就是在进行科学思维<br>科学是研究自然的方法，发现有关自然的可靠知识，让我们了解世界的真理。<h1 id="什么是工程及工程思维"><a href="#什么是工程及工程思维" class="headerlink" title="什么是工程及工程思维"></a>什么是工程及工程思维</h1>涉及以下内容</li><li>科学思维和辩证思维</li><li>横向思维</li><li>设计思维</li><li>有组织的创造性思维<br>应用科学原理和优化方法将自然资源转化为造福人类的结构、机器、产品、系统及工艺。<h1 id="科学与工程的关系"><a href="#科学与工程的关系" class="headerlink" title="科学与工程的关系"></a>科学与工程的关系</h1>类似分析与综合的关系，工程呈现的是产品，技术是工程的手段，工程与技术关系密切<h1 id="举例说明科学如何为工程服务"><a href="#举例说明科学如何为工程服务" class="headerlink" title="举例说明科学如何为工程服务"></a>举例说明科学如何为工程服务</h1><h1 id="举例说明工程如何辅助科学探索"><a href="#举例说明工程如何辅助科学探索" class="headerlink" title="举例说明工程如何辅助科学探索"></a>举例说明工程如何辅助科学探索</h1><h1 id="什么是简单问题-如何求解"><a href="#什么是简单问题-如何求解" class="headerlink" title="什么是简单问题 如何求解"></a>什么是简单问题 如何求解</h1></li><li>简单问题评价标准类似，可以一并优化。</li><li>可以通过数学分析的方法或者逻辑推理的方法进行求解。<h1 id="什么是复杂问题-如何求解"><a href="#什么是复杂问题-如何求解" class="headerlink" title="什么是复杂问题 如何求解"></a>什么是复杂问题 如何求解</h1>不能按照简单问题求解方法进行求解的工程问题是复合问题<h2 id="求解策略"><a href="#求解策略" class="headerlink" title="求解策略"></a>求解策略</h2></li><li>暂时忽略不可测量指标。</li><li>基于事实或证据，表述指标的相对值，尝试将复合问题转化为简单问题。</li><li>将问题分解为可以独立求解的若干简单问题。<h1 id="什么叫优化？简述其在工程解决方案中的应用。"><a href="#什么叫优化？简述其在工程解决方案中的应用。" class="headerlink" title="什么叫优化？简述其在工程解决方案中的应用。"></a>什么叫优化？简述其在工程解决方案中的应用。</h1>优化是指通过系统化的分析和改进过程，使某一系统、方案或过程达到最佳状态。优化的目标通常是最大化或最小化某一性能指标，如成本、时间、资源使用效率或生产率等。优化可以应用于各种领域，包括工程、经济、管理、计算机科学等。<br>在工程解决方案中的应用，优化主要表现为以下几个方面：</li><li><strong>设计优化</strong>：工程设计阶段，通过优化算法来确定设计参数，以达到最优的设计效果。例如，优化建筑结构的材料分配，以达到最小的重量和最大强度。</li><li><strong>资源优化</strong>：在项目实施过程中，通过合理调配资源，减少浪费，提高资源利用率。例如，优化施工队伍的调度和施工顺序，以缩短工期和降低成本。</li><li><strong>过程优化</strong>：对生产过程进行优化，提高生产效率和产品质量。例如，优化制造流程中的每一个步骤，减少生产时间和不良品率。</li><li><strong>系统优化</strong>：在复杂系统中，通过优化算法来改进系统的整体性能。例如，优化供电网络中的电力调度，减少输电损耗，提高供电可靠性。</li><li><strong>参数优化</strong>：在工程模拟和分析过程中，通过调整模型参数，使模拟结果与实际情况更为接近，从而提高模型的准确性和预测能力。例如，优化流体动力学模型中的参数，以更准确地预测流体流动行为。<br>优化在工程解决方案中的应用可以显著提高效率、降低成本、提高质量和可靠性，是工程实践中不可或缺的重要方法。<h1 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>物物相连的一种网络，把物品通过RFID和条码等 信息传感设备与互联网连接起来，实现智能化识别和管理，其实质就是将RFID与 互联网相结合加以应用。<br>RFID 无源有缘半无源</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工程学导论 自动化 o.O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>芯原杯IDE替换测试</title>
      <link href="/2024/06/08/xin-yuan-bei/xin-yuan-bei-ide-ti-huan-ce-shi/"/>
      <url>/2024/06/08/xin-yuan-bei/xin-yuan-bei-ide-ti-huan-ce-shi/</url>
      
        <content type="html"><![CDATA[<p>省流：能代码补全，编译结果有问题，CLion的远程调试能接上qemu，但是程序都似了有没有什么用，建议ntr开发，Clion写代码Esclipse编译Debug。</p><h1 id="为什么要做IDE替换"><a href="#为什么要做IDE替换" class="headerlink" title="为什么要做IDE替换"></a>为什么要做IDE替换</h1><p>众所周知，基于Eclipse开发的嵌入式IDE，像Ti的CCS，英飞凌的ADS，瑞萨(<del>史中史</del>) ，以及ST的STM32CubeIDE，虽然厂商做了一定程度上的支持，但是用起来非常的一眼难尽。<br><img src="https://picx.zhimg.com/80/v2-9d8193126d77f9575c62e1a8440fd370_1440w.png" alt=""><br>而STM32早已支持Cmake与Clion搭配进行项目配置与开发，开发体验有了质的提升，因此，<strong><em>我想探索一种通用性的解决办法，即Eclipse在编译时生成的Makefile文件进行逆推导得到Cmakelist，进而能够搭配代码开发体验较好的IDE进行开发编译与调试。</em></strong><br>需要提醒的是，在撰写本文时，虽然能够得到编译成功的结果，但是与Eclipse编译结果不同，仍然在解决中，但是可以将Clion作为代码编辑器进行代码编写，在Eclipse进行编译运行与调试。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>Nuclei Studio IDE for C/C++ Developers<br>Version: 2024-02.DEV<br>ToolChain来自Nuclei IDE自带的编译器，路径如图所示，就是在芯原官方提供的压缩包的toolchain文件夹内。<br><img src="https://pic1.zhimg.com/80/v2-c0bd065f7dc4ec399a60089a9d7b5f00_1440w.png" alt=""></p><p>使用工程如图所示，实际上就是官方提供的sdk工程,我把doc文件夹删除了。<br><img src="https://picx.zhimg.com/80/v2-b7c0585a82e5e68ff61bcde37ca98eb8_1440w.png" alt=""><br><img src="https://pica.zhimg.com/80/v2-02050e38c71f0557d74709fa86c9b3d0_1440w.png" alt=""></p><h1 id="替换开发步骤"><a href="#替换开发步骤" class="headerlink" title="替换开发步骤"></a>替换开发步骤</h1><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p><img src="https://pic1.zhimg.com/80/v2-c0bd065f7dc4ec399a60089a9d7b5f00_1440w.png" alt=""><br>IDE解压完成后，将NucleiStudio/toolchain/gcc/bin添加到系统环境变量PATH中，别管gcc13，那是个空文件夹。<br><img src="https://picx.zhimg.com/80/v2-7e2bee2fddca204771876edb3b0b8cee_1440w.png" alt=""><br>我这里把qemu加进去的原因是，原来是在qemu上运行程序的，我想着一起移植到CLion上（<del>但是似了</del>）<br>在终端中确认环境变量是否添加成功，运行<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">riscv64-unknown-elf-gcc -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>如果成功添加了应该会出现下图这样<br><img src="https://pica.zhimg.com/80/v2-1d30dc50f6f5d8c09fd9d035c10ad504_1440w.png" alt=""></p><h2 id="Clion项目配置"><a href="#Clion项目配置" class="headerlink" title="Clion项目配置"></a>Clion项目配置</h2><p>具体的工程我已经上传到github，仓库地址<a href="https://github.com/WwWangGuan/VeriTest">GitHub - WwWangGuan/VeriTest: 芯原杯对原有基于Esclipe IDE用CMake替换的测试工程</a><br><img src="https://picx.zhimg.com/80/v2-e49322cff1eca8876b7acab2a014b769_1440w.png" alt=""></p><h3 id="工具链配置"><a href="#工具链配置" class="headerlink" title="工具链配置"></a>工具链配置</h3><p><img src="https://pic1.zhimg.com/80/v2-2e41cf8b0f99f35857344c1b33a5f835_1440w.png" alt=""></p><p>直接新建一个工具链就好，C/C++编译器指定到原来Eclipse的编译器，gdb是我自认为应该加上去的，准确性未知。<br>但是，需要在Cmake的选项卡中指定一下工具链，这样CLion才会用新添加的工具链<br><img src="https://picx.zhimg.com/80/v2-fa47f635b53309b1c9c54a0230dbfd2d_1440w.png" alt=""><br>Q：为啥用Release？<br>A：他原来就用的Release。<br>PS：勾上图里的那个选项开发体验有巨大提升。</p><h3 id="Cmakelist-txt"><a href="#Cmakelist-txt" class="headerlink" title="Cmakelist.txt"></a>Cmakelist.txt</h3><p>重头戏来了（太折磨了）<br><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">cmake_minimum_required(VERSION 3.25)    # 指定交叉编译工具链  set(CMAKE_SYSTEM_NAME Generic)  set(CMAKE_SYSTEM_VERSION 1)  # 项目信息  project(qemu C CXX ASM)  set(CMAKE_CXX_STANDARD 17)  set(CMAKE_C_STANDARD 11)    set(CMAKE_C_COMPILER riscv64-unknown-elf-gcc)  set(CMAKE_CXX_COMPILER riscv64-unknown-elf-g++)  set(CMAKE_ASM_COMPILER riscv64-unknown-elf-gcc)  set(CMAKE_AR riscv64-unknown-elf-ar)  set(CMAKE_OBJCOPY riscv64-unknown-elf-objcopy)  set(CMAKE_OBJDUMP riscv64-unknown-elf-objdump)  set(SIZE riscv64-unknown-elf-size)  set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)    # 包含目录  include_directories(          galaxy_sdk&#x2F;bsp&#x2F;include          galaxy_sdk&#x2F;bsp&#x2F;include&#x2F;arch&#x2F;riscv&#x2F;n309        galaxy_sdk&#x2F;config&#x2F;include        galaxy_sdk&#x2F;drivers&#x2F;include        galaxy_sdk&#x2F;modules&#x2F;include        galaxy_sdk&#x2F;modules&#x2F;external&#x2F;riscv_dsp&#x2F;include        galaxy_sdk&#x2F;os&#x2F;include        galaxy_sdk&#x2F;osal&#x2F;include        galaxy_sdk&#x2F;prebuilts&#x2F;bluetooth&#x2F;health&#x2F;include        galaxy_sdk)    # 添加所有源文件  file(GLOB_RECURSE SOURCES &quot;galaxy_sdk&#x2F;bsp&#x2F;src&#x2F;*.*&quot;          &quot;galaxy_sdk&#x2F;drivers&#x2F;src&#x2F;*.*&quot;        &quot;galaxy_sdk&#x2F;src&#x2F;*.*&quot;        &quot;galaxy_sdk&#x2F;*.*&quot;)    # 链接器脚本  set(LINKER_SCRIPT $&#123;CMAKE_SOURCE_DIR&#125;&#x2F;galaxy_sdk&#x2F;n309_iot_qemu.ld)    # 通用编译选项  set(COMMON_FLAGS &quot;-march&#x3D;rv32imafc_xxldsp -mabi&#x3D;ilp32f -mtune&#x3D;nuclei-300-series -mcmodel&#x3D;medlow -mno-save-restore -O2 -ffunction-sections -fdata-sections -fno-common -Wall -Werror -g&quot;)  set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; $&#123;COMMON_FLAGS&#125;&quot;)  set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;COMMON_FLAGS&#125;&quot;)  set(CMAKE_ASM_FLAGS &quot;$&#123;CMAKE_ASM_FLAGS&#125; $&#123;COMMON_FLAGS&#125; -x assembler-with-cpp&quot;)    # 链接选项  add_link_options(          -T $&#123;LINKER_SCRIPT&#125;          -nostartfiles          -Xlinker --gc-sections        -Wl,-Map&#x3D;$&#123;CMAKE_BINARY_DIR&#125;&#x2F;qemu.map          -Wl,--no-warn-rwx-segments)    # 设置库目录  link_directories(          galaxy_sdk&#x2F;bsp&#x2F;lib          galaxy_sdk&#x2F;drivers&#x2F;lib        galaxy_sdk&#x2F;modules&#x2F;lib        galaxy_sdk&#x2F;modules&#x2F;external&#x2F;riscv_dsp        galaxy_sdk&#x2F;os&#x2F;lib        galaxy_sdk&#x2F;osal&#x2F;lib        galaxy_sdk&#x2F;prebuilts&#x2F;bluetooth&#x2F;health)    # 添加可执行文件  add_executable($&#123;PROJECT_NAME&#125;.out $&#123;SOURCES&#125;)    # 特定文件类型的编译选项  foreach(source IN LISTS SOURCES)      if (source MATCHES &quot;\\.S$&quot;)          set_source_files_properties($&#123;source&#125; PROPERTIES COMPILE_FLAGS &quot;$&#123;CMAKE_ASM_FLAGS&#125;&quot;)      endif()  endforeach()    # 链接库  target_link_libraries($&#123;PROJECT_NAME&#125;.out          -Wl,--start-group        c_nano               gcc        stdc++        semihost        osal_riscv        os_riscv        bsp_riscv        driver_riscv        common_riscv        ble        nmsis_dsp_rv32imafc_xxldsp        -Wl,--end-group)    # 生成HEX文件  add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.out POST_BUILD          COMMAND $&#123;CMAKE_OBJCOPY&#125; -O ihex $&#123;PROJECT_NAME&#125;.out $&#123;PROJECT_NAME&#125;.hex          COMMENT &quot;Building $&#123;PROJECT_NAME&#125;.hex&quot;  )    # 生成列表文件  add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.out POST_BUILD          COMMAND $&#123;CMAKE_OBJDUMP&#125; --source --all-headers --demangle --line-numbers --wide $&#123;PROJECT_NAME&#125;.out &gt; $&#123;PROJECT_NAME&#125;.lst          COMMENT &quot;Building $&#123;PROJECT_NAME&#125;.lst&quot;  )    # 打印尺寸  add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.out POST_BUILD          COMMAND $&#123;SIZE&#125; --format&#x3D;berkeley $&#123;PROJECT_NAME&#125;.out &gt; $&#123;PROJECT_NAME&#125;.siz          COMMENT &quot;Building $&#123;PROJECT_NAME&#125;.siz&quot;  )  # 打印内存使用情况  add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.out POST_BUILD          COMMAND $&#123;SIZE&#125; $&#123;PROJECT_NAME&#125;.out          COMMENT &quot;Memory usage:&quot;  )    # 清理命令  add_custom_target(clean_all          COMMAND $&#123;CMAKE_COMMAND&#125; -E rm -rf $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.o $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.d $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.out $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.hex $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.lst $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.siz          COMMENT &quot;Cleaning up generated files&quot;  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="几个需要强调的地方"><a href="#几个需要强调的地方" class="headerlink" title="几个需要强调的地方"></a>几个需要强调的地方</h4><p><del>1. 我这里是手动指定了编译器的位置，因为我测试的时候发现即使我添加了环境变量Cmake仍然识别不到</del><br>byd，又好使了</p><ol><li>项目信息看个人，要不要改随意，在第7行改就可以。</li><li>官方给的都是.a，链接的时候有顺序问题，我这里抄了一下原来的makefile，加上了-Wl,—start-group 和-Wl,—end-group ，让编译器自己找链接顺序。</li><li>如果需要添加新文件夹，添加方式和STM32的方式相同。<h3 id="配置效果"><a href="#配置效果" class="headerlink" title="配置效果"></a>配置效果</h3>如果准确无误，应该会有如下信息（Cmake）：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">C:\Users\34789\AppData\Local\Programs\CLion\bin\cmake\win\x64\bin\cmake.exe -DCMAKE_BUILD_TYPE&#x3D;Release -DCMAKE_C_COMPILER&#x3D;C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-gcc.exe -DCMAKE_CXX_COMPILER&#x3D;C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-c++.exe -G &quot;MinGW Makefiles&quot; -S G:\VeriSilicon\VeriHealthi_QEMU_SDK.202405_preliminary\VeriHealthi_QEMU_SDK.202405_preliminary\VeriTest -B G:\VeriSilicon\VeriHealthi_QEMU_SDK.202405_preliminary\VeriHealthi_QEMU_SDK.202405_preliminary\VeriTest\cmake-build-release-verisilicon-- The C compiler identification is GNU 13.1.1-- The CXX compiler identification is GNU 13.1.1-- The ASM compiler identification is GNU-- Found assembler: C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-gcc.exe-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-gcc.exe - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-c++.exe - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Configuring done (1.3s)-- Generating done (0.0s)-- Build files have been written to: G:&#x2F;VeriSilicon&#x2F;VeriHealthi_QEMU_SDK.202405_preliminary&#x2F;VeriHealthi_QEMU_SDK.202405_preliminary&#x2F;VeriTest&#x2F;cmake-build-release-verisilicon[已完成]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><img src="https://picx.zhimg.com/80/v2-ce4e264a02aaf26dac9eeab5b5ad606f_1440w.png" alt=""></p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://picx.zhimg.com/80/v2-ebca35fb7dd940600576cc6480127534_1440w.png" alt=""></p><p>愉 快 的 代 码 书 写 体 验（<del>双手指天</del>）</p><h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><p><img src="https://pic1.zhimg.com/80/v2-f0233efd30cc57f321198df0f2433521_1440w.png" alt=""></p><p>上图是CLion的编译结果，但是呢，让我们看看原来IDE是啥结果</p><p><img src="https://picx.zhimg.com/80/v2-098c6110c4509d8b4f65e0841992b496_1440w.png" alt=""></p><p>不是，哥们，怎么最终程序大小都不一样啊。<br>我试图把CLion编译的qemu.out搬到Esclipe里用，结果直接告诉我QEMU运行不了。<br>这是我写这个文章时候感到最大的挫败点，折腾了半天CLion变成了代码编辑器<del>早知道还不如Vscode来的实在。</del><br>来个大佬教教我咋解决吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cmake Clion RISCV VeriSilicon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/05/20/fpga-zuo-ye/"/>
      <url>/2024/05/20/fpga-zuo-ye/</url>
      
        <content type="html"><![CDATA[<h1 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h1><ol><li>C</li><li>entity:描述电路的所有输入输出引脚<br>archtiecture： 用VHDL描述电路行为和实现功能。</li><li>B</li><li>变量 常量 信号</li><li>×<h1 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h1></li><li>8</li><li>1</li><li>IN OUT INOUT BUFFER LINKAGE</li><li>变量 常量 信号</li><li>PROCESS function PROCEDURE</li><li>D</li><li>C</li><li>B</li><li>D<br>$$<br>\begin{equation}\begin{split}<br>已知电磁波的频率 f = 3 \times 10^9 \, \text{Hz}。在空气中传播，电磁波的波长 \lambda和传播常数 k 可以通过以下公式求得：\\</li></ol><p>\end{split}\end{equation}</p><script type="math/tex; mode=display"></script><p>\left[\matrix{\theta  \\ \dot{\theta}\\x\\\dot{x}\\\phi \\\dot{\phi}}\right]<br>$$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2024/05/14/fpga/fpga-qi-mo-fu-xi/"/>
      <url>/2024/05/14/fpga/fpga-qi-mo-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><ol><li>RTL  Register Transfer level</li><li>时序仿真是最接近真实器件运行特性的仿真。</li><li><p>综合器总是能综合出唯一的电路网表文件。然而，在实际的数字电路设计中，这种说法是不准确的。综合器在将高级设计描述（如HDL代码）转换为门级网表时，可以基于不同的优化目标（如速度、面积、功耗等）和综合策略产生不同的网表结果。同一个功能的电路描述，根据不同的综合约束和目标，可能会被综合成不同的电路网表。因此，综合出的网表文件并不唯一。</p><h1 id="HDL设计风格"><a href="#HDL设计风格" class="headerlink" title="HDL设计风格"></a>HDL设计风格</h1><h2 id="行为级描述"><a href="#行为级描述" class="headerlink" title="行为级描述"></a>行为级描述</h2><h2 id="数据流描述"><a href="#数据流描述" class="headerlink" title="数据流描述"></a>数据流描述</h2><h2 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h2><h3 id="顺序描述语句（Sequential-Statements）"><a href="#顺序描述语句（Sequential-Statements）" class="headerlink" title="顺序描述语句（Sequential Statements）"></a>顺序描述语句（Sequential Statements）</h3><p>顺序描述语句是在进程（process）、函数（function）和过程（procedure）中使用的。这些语句按照书写的顺序执行，类似于软件编程中的顺序执行。<br><strong>*构造体中的语句是并行执行的</strong>，与书写顺序无关*</p></li></ol><h1 id="端口的方向"><a href="#端口的方向" class="headerlink" title="端口的方向"></a>端口的方向</h1><p>in out inout BUFFER</p><p>variable是局部量，只能在process和子程序里面用？<br>子程序是什么？</p><p>/=是不等于，斜杠向左偏</p><p>基于FPGA/CPLD的数字系统设计流程包括：<br>设计输入、综合、适配、仿真、编程下载。<br>设计输入 综合 适配 仿真 下载</p><h1 id="数据建立时间"><a href="#数据建立时间" class="headerlink" title="数据建立时间"></a>数据建立时间</h1><p>在时钟跳变之前数据必须保持稳定无跳边的时间</p><h1 id="数据保持时间"><a href="#数据保持时间" class="headerlink" title="数据保持时间"></a>数据保持时间</h1><p>在时钟跳变之后数据必须保持稳定的时间</p><h1 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h1><p>类书参数说明</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>门控时钟？</li><li>状态机重新复习</li><li>variable singal constant区别与联系</li><li></li></ol><h1 id="基于VHDL的电路设计"><a href="#基于VHDL的电路设计" class="headerlink" title="基于VHDL的电路设计"></a>基于VHDL的电路设计</h1><h2 id="组合逻辑电路：基本门电路、多路选择器、编码器、译码器"><a href="#组合逻辑电路：基本门电路、多路选择器、编码器、译码器" class="headerlink" title="组合逻辑电路：基本门电路、多路选择器、编码器、译码器"></a>组合逻辑电路：基本门电路、多路选择器、编码器、译码器</h2><h2 id="时序逻辑电路：时钟信号的边沿检测、同步复位信号和异步复位信号的描述、计数器、状态机（枚举数据类型、多进程）"><a href="#时序逻辑电路：时钟信号的边沿检测、同步复位信号和异步复位信号的描述、计数器、状态机（枚举数据类型、多进程）" class="headerlink" title="时序逻辑电路：时钟信号的边沿检测、同步复位信号和异步复位信号的描述、计数器、状态机（枚举数据类型、多进程）"></a>时序逻辑电路：时钟信号的边沿检测、同步复位信号和异步复位信号的描述、计数器、状态机（枚举数据类型、多进程）</h2><h2 id="系统设计：任务分析、功能模块划分、分析各个模块之间的联系、利用上述基本模块来实现各个功能模块。"><a href="#系统设计：任务分析、功能模块划分、分析各个模块之间的联系、利用上述基本模块来实现各个功能模块。" class="headerlink" title="系统设计：任务分析、功能模块划分、分析各个模块之间的联系、利用上述基本模块来实现各个功能模块。"></a>系统设计：任务分析、功能模块划分、分析各个模块之间的联系、利用上述基本模块来实现各个功能模块。</h2><h1 id="设计时的其他问题和技巧"><a href="#设计时的其他问题和技巧" class="headerlink" title="设计时的其他问题和技巧"></a>设计时的其他问题和技巧</h1><h2 id="HDL语句的可综合性"><a href="#HDL语句的可综合性" class="headerlink" title="HDL语句的可综合性"></a>HDL语句的可综合性</h2><p>符合HDL语法规范的代码不一定能够综合成对应电路的设计信息<br>除法 变字长的循环语句 无线循环语句</p><h2 id="FPGA的配置问题"><a href="#FPGA的配置问题" class="headerlink" title="FPGA的配置问题"></a>FPGA的配置问题</h2><p>主模式（FPGA主动串行方式） 从模式（FPGA被动方式） JTAG配置方式（ISP）</p><h2 id="设计优化方法（面积优化和速度优化）；"><a href="#设计优化方法（面积优化和速度优化）；" class="headerlink" title="设计优化方法（面积优化和速度优化）；"></a>设计优化方法（面积优化和速度优化）；</h2><h3 id="面积优化"><a href="#面积优化" class="headerlink" title="面积优化"></a>面积优化</h3><ol><li>可以使用更小规模的FPGA器件，节省成本</li><li>为日后升级留下更多资源</li><li>FPGA资源使用过多会导致功耗上升</li><li>FPGA布线资源有限，占用资源过多会影响电路性能<h3 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h3></li><li>流水线设计，时钟周期不得小于数据从输入到输出经过的时间，系统最高频率取决于延时最小的组合逻辑块</li><li>寄存器配平。</li><li>关键路径法（优先使用）</li><li>乒乓操作法</li><li>加法数法<h2 id="数据建立和保持时间的要求；"><a href="#数据建立和保持时间的要求；" class="headerlink" title="数据建立和保持时间的要求；"></a>数据建立和保持时间的要求；</h2><h3 id="数据建立时间-1"><a href="#数据建立时间-1" class="headerlink" title="数据建立时间"></a>数据建立时间</h3>在时钟跳变之前，数据必须保持稳定的时间<h3 id="数据保持时间-1"><a href="#数据保持时间-1" class="headerlink" title="数据保持时间"></a>数据保持时间</h3>在时钟跳变之后数据保持稳定的时间</li></ol><p>数据的稳定传输必须同时满足数据建立时间和数据保持时间，应当避开在数据建立时间或在其附近读取数据。</p><h2 id="冒险现象和毛刺消除技术；"><a href="#冒险现象和毛刺消除技术；" class="headerlink" title="冒险现象和毛刺消除技术；"></a>冒险现象和毛刺消除技术；</h2><h3 id="毛刺消除"><a href="#毛刺消除" class="headerlink" title="毛刺消除"></a>毛刺消除</h3><ol><li>延时方式</li><li>逻辑方式</li><li>定时方式<br>分别用两个独立的Timer对输入信号的高低电平的持续时间进行技术，大于某个阈值再输出对应高低电平</li></ol><h2 id="FPGA设计中时钟的种类和不同时钟的特点及优化方法。"><a href="#FPGA设计中时钟的种类和不同时钟的特点及优化方法。" class="headerlink" title="FPGA设计中时钟的种类和不同时钟的特点及优化方法。"></a>FPGA设计中时钟的种类和不同时钟的特点及优化方法。</h2><h3 id="时钟种类"><a href="#时钟种类" class="headerlink" title="时钟种类"></a>时钟种类</h3><ol><li>全局时钟</li><li>门控时钟<br>驱动时钟的逻辑必须只包含一个与门或者一个或门<br>逻辑门的一个输入作为实际的时钟，逻辑门的所有其他输入必须当成地址或者控制线。</li><li>多级逻辑时钟</li><li>行波时钟<br>一个触发器的输出用作另一个触发器的时钟输入</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2024/05/04/tuo-luo-yi/adis16467/"/>
      <url>/2024/05/04/tuo-luo-yi/adis16467/</url>
      
        <content type="html"><![CDATA[<p>sadf<br><img src="https://picx.zhimg.com/80/v2-3ce7d73454de99d9c48aa0ed62dd0a92_720w.png" alt=""><br><img src="https://picx.zhimg.com/80/v2-3ce7d73454de99d9c48aa0ed62dd0a92_720w.png" alt=""><br>sdf<br><img src="https://picx.zhimg.com/80/v2-3ce7d73454de99d9c48aa0ed62dd0a92_720w.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2024/05/04/ri-ji/2024-05-04/"/>
      <url>/2024/05/04/ri-ji/2024-05-04/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>三相波形能生成了但是没出来马鞍波？</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-5-1</title>
      <link href="/2024/05/01/ri-ji/2024-5-1/"/>
      <url>/2024/05/01/ri-ji/2024-5-1/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>MPQ6533的VRG可不可以不接？感觉有点冗余，相当于驱动器做了防反接在电源的最前级，好像又有必要了。</li><li>DigiPCBA犯病，保存元件到自己的空间的时候就g了</li><li>MOS的RC snubber通用电路</li><li>SAR ADC的RC low pass filter设计</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FOC原理</title>
      <link href="/2024/04/25/foc/foc-yuan-li/"/>
      <url>/2024/04/25/foc/foc-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在机器人控制领域中，电机是一个重要的组成部分，无论是三轴云台、机械臂还是AGV，电机都在其中起到了动力输出的作用，常规的有刷电机结构简单，在实际工程中有着广泛的应用，但在机器人的运动控制中，有刷电机体现出了其控制精度不高和寿命短的缺陷，因此并未在机器人控制领域中广泛应用，而无刷电机虽然制造成本更高，但是其控制精度、可靠性和寿命会比有刷电机更加优越，被广泛应用在了机器人领域中。</p><p>通常无刷电机分成两个使用场景，第一种的典型应用场景是在无人机上，其转速非常高，对位置或力矩的控制基本没有要求，而另一种则在机器人上，转速通常最大在几百rpm，但是对位置和力矩的控制精度要求非常大，因而在驱动和控制方法上分成了几种不同的派系：</p><ol><li>在高速运动场景下，可以使用无感开环控制，因其对力矩没有要求，可以使用方波进行驱动，这种设计硬件结构十分简单，只需要控制栅极驱动器的通断，换向时只需要判断电机反电动势是否过零点，过零点即可进行换向操作。但这种方法的缺点是低速和启动性能比较差，而且噪声非常大，不适合用在精细控制领域中。</li><li>在低速高精度控制场景下，无刷电机更多采用FOC（Field-Oriented Control）进行控制，FOC被称为磁场导向控制，是一种利用变频器（VFD）控制三相交流电机的技术。这种技术通过调整变频器的输出频率、输出电压的大小及相位，来控制电机的输出。其特性是可以单独控制电机中每个绕组线圈的磁场方向和强度，类似他励式直流电机。由于在FOC算法的方程式中，三相交流电机的定子电流通过两个可视化的正交矢量分量来描述，因此这种控制方法又被称为矢量控制（Vector Control）。FOC方法可用于控制交流感应电机和直流无刷电机。最开始出现这种控制方法，就是为了提高电机的性能。在FOC控制下，电机不仅能在全速范围内平稳运行，以零速度产生额定扭矩，还具备良好的高速动态性能，如能够做到快速地加速或减速。</li></ol><p>因此，FOC的独特速度和力矩性能使得其成为了近些年来最常出现的电机控制算法，了解其对应的控制原理能够更好控制无刷电机，还可将其封装为伺服模块，大大增强了易用性。</p><h1 id="无刷电机原理"><a href="#无刷电机原理" class="headerlink" title="无刷电机原理"></a>无刷电机原理</h1><p>以三相二极内转子电机为例，定子的三相绕组有星形联结方式和三角联结方式，而三相星形联结的二二导通方式最为常用，这里使用该模型做简单讨论：<br><img src="https://pic1.zhimg.com/80/v2-7fb73dac333fecf884c3e8df356ab718_720w.webp" alt=""></p><p>如图所示，电机的三个线圈的一头均连接至中心点$O$（中心为转子，是永磁体，未画出），如果此时在AB相上通电，容易根据右手螺旋定则得出此时线圈产生的合磁场方向与$OB$成$30°$角，$N$极指向右下方，而此时，内转子受到磁场作用的力，会使得内转子的永磁铁的磁链和线圈的磁链相垂直。此时电机也就完成了一次$60°$转动，依次类推，分别在三相的两相上一次通电，也就“牵动”电机完成了一次完整旋转。<br><img src="https://pic1.zhimg.com/80/v2-bc0091ec15f7bd19094e890bf3e90418_720w.webp" alt=""><br>而我们需要对换向进行操作，则需要栅极驱动器和MOS管。<br><img src="https://pic4.zhimg.com/80/v2-de99d63cac7edac6868bd829ce92685f_720w.webp" alt=""><br>上图显示出了需要驱动无刷电机转动的三相逆变电路（图中的功率器件其实是IGBT），通过开关不同的MOS管，就能够实现对不同相和不同方向的通电和断开处理，进而也就实现了无刷电机的转向和换相。</p><p>栅极驱动器，顾名思义，是驱动栅极使得MOS管打开的芯片。<br><img src="https://pic1.zhimg.com/80/v2-56e62c22009e65d2591853bb881d3d63_720w.png" alt=""><br>上图是Ti的智能栅极驱动芯片，带上了许多保护功能，如过压保护和过流保护等，但最核心的还是框图中的Gate Driver（栅极驱动器），芯片接收来自控制器的PWM信号，高电平占周期的时长决定了MOS管的开通时长，两个MOS管相连的电路我们称之为半桥电路，如图所示，三相电机的线圈的引头连接至桥臂中央，这也是容易理解的。</p><h1 id="三相电机的旋转波形与驱动波形"><a href="#三相电机的旋转波形与驱动波形" class="headerlink" title="三相电机的旋转波形与驱动波形"></a>三相电机的旋转波形与驱动波形</h1><p>将示波器的探头连接至电机三相中的两相，如果是三通道的则更好，我们最后应该会得到三个正弦曲线，幅值相同而相邻波形相位差为$120°$。<br><img src="https://pic2.zhimg.com/80/v2-420583ae479dc60942af80ec30c0c175_720w.webp" alt=""><br>用手去旋转电机，是能够感受到强烈的阻尼感，我们上面的分析表明，转子在磁场中只有六个稳定的状态，因此在整个的旋转过程中是不平滑的，为了解决这个问题，也顺带衍生出了无刷电机中PMSM和BLDC的区别。</p><p>BLDC的解决方式比较直白，既然我转一圈要切换六次，那么就增加电机的极对数，增加的极对数越多，我一圈当中就会切换12次甚至更多，这样“颗粒感”就会变的更小，切换的时间和间距越短，电机的运行效果就越平滑。<br><img src="https://pic1.zhimg.com/80/v2-d77d7004abebc0d667fb9f5c3f862fe6_720w.png" alt=""><br>上图是一个极对数为9的无刷电机，但是电机仍然只有三根线在外面。</p><p>但是，即使我们增加了极对数，但是仍然没有解决根本上的问题，因为方波本身是不平滑的，而无刷电机的波形确实正弦波形，那就直接用正弦波去驱动不就行了？没错，这就是PMSM的解决方式，其反电动势被人为设计成正弦波的形状，我们再搭配一些软件和算法，把方波的驱动信号转换被SPWM正弦波或者SVPWM马鞍波，这样就从根本上解决了这个问题，这也就是FOC的实现原理。</p><h1 id="FOC控制原理"><a href="#FOC控制原理" class="headerlink" title="FOC控制原理"></a>FOC控制原理</h1><p>我们先在控制系统的顶层来了解一下控制流程<br><img src="https://pic1.zhimg.com/80/v2-b12a2650b001faa9cd31ecbb309eaca0_720w.webp" alt=""><br>上图中是电流闭环控制，也就是恒定力矩模式。整个控制流程是这样的：</p><ol><li>对电机三相电流进行采样得到 $𝐼_𝑎,𝐼_𝑏,𝐼_𝑐$ ​</li><li>将 $𝐼_𝑎,𝐼_𝑏,𝐼_𝑐$ ​​经过$Clark$变换得到​ $𝐼_𝛼,𝐼_𝛽$</li><li>将​ $𝐼_𝛼,𝐼_𝛽$经过$Park变换$得到​ $𝐼_𝑞,𝐼_𝑑$</li><li>计算$​𝐼_𝑞,𝐼_𝑑$和其设定值$𝐼_{𝑞_{𝑟𝑒𝑓}},𝐼_{d_{𝑟𝑒𝑓}}$,的误差</li><li>将上述误差输入两个PID控制器，得到输出的控制电压​ $𝑈_𝑞,𝑈_𝑑$</li><li>将​$𝑈_𝑞,𝑈_𝑑$进行反Park变换得到​ $𝑈_𝛼,𝑈_𝛽$</li><li>用$𝑈_𝛼,𝑈_𝛽$合成电压空间矢量，输入$SVPWM$模块进行调制，输出该时刻三个半桥的状态编码值（前文有提到）</li><li>按照前面输出的编码值控制三相逆变器的$MOS$管开关，驱动电机</li><li>循环上述步骤<h2 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h2><img src="https://pic4.zhimg.com/80/v2-de99d63cac7edac6868bd829ce92685f_720w.webp" alt=""><br>对于三相电机而言，由KCL很容易得到</li></ol><script type="math/tex; mode=display">I_a+I_b+I_C=0</script><p>定义三相坐标系如图所示<br><img src="https://picx.zhimg.com/80/v2-71dd5ef2bce9f8b3531913f2498bdf7d_720w.png" alt=""><br>这和我们之前转动电机得到的相位差结果基本一致，但是他有三个轴，分析起来太麻烦了，我们通过定义正交基向量来重新定义一个$\alpha-\beta$坐标系</p><script type="math/tex; mode=display">\left\{\begin{array}{l}I_{\alpha}=I_{a}+\cos \left(\frac{2 \pi}{3}\right) I_{b}+\cos \left(\frac{2 \pi}{3}\right) I_{c} \\I_{\beta}=\sin \left(\frac{2 \pi}{3}\right) I_{b}-\sin \left(\frac{2 \pi}{3}\right) I_{c}\end{array}\right.</script><p>相当于把原来的三个向量投影到坐标轴上，只需要控制两个变量了就能达到原来的效果，但是我们新坐标系下仍然是以正弦方式在做变化的，我们希望把它线性化，这样更容易控制和计算，也就引入了Park变换。</p><h2 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h2><p>为什么上面经过Clark变换的结果是正弦变化的呢？因为电机本身是在旋转的，我们需要消除“旋转”这一特征才能达到线性化的目的。<br>在Park变换中，我们将坐标系逆时针旋转$\theta$°，定义$\theta$为电机转子转过的角度，就像图片的这样。<br><img src="https://picx.zhimg.com/80/v2-000d05e82742dd15d575492dd00b2c07_720w.png" alt=""><br>坐标变换的结果仍然是简单的矢量投影，公式如下：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}I_{d}=I_{\alpha} \cos (\theta)+I_{\beta} \sin (\theta) \\I_{q}=-I_{\alpha} \sin (\theta)+I_{\beta} \cos (\theta)\end{array}\right.</script><p>转子转多少度那么$d-q$坐标系就转多少度，因此，“旋转”的特征被消除，我们对电机的控制最后解耦为对$I_d,I_q$的控制，也就可以搭配PID这种线性控制器来控制了。</p><h2 id="PID控制"><a href="#PID控制" class="headerlink" title="PID控制"></a>PID控制</h2><p>FOC控制中主要会用到几个控制环路，分别是电流环，速度环，位置环<br><img src="https://picx.zhimg.com/80/v2-0e858178a22a7adbebbe213b54842a25_720w.png" alt=""><br>我们首先讨论电流环，在$d-q$坐标系中，我们讲到在这个坐标系下消除了”旋转“的特征，两个向量对于转子而言分别是径向向量和切向向量，很明显，推动转子旋转的向量就是切向向量，而径向向量是我们不需要的，如果它不为0就会影响效率和力矩，因此我们希望把它控制为0，因此电流环的作用就是使径向电流尽可能为0（0就是控制器的期望），而使切向电流达到期望值。<br><img src="https://pica.zhimg.com/80/v2-421da3a6bda3d28e57ba0169e4138fcb_720w.png" alt=""><br>电流环的控制作用到这里就结束了，它负责的东西就这么多。</p><h3 id="速度环和位置环"><a href="#速度环和位置环" class="headerlink" title="速度环和位置环"></a>速度环和位置环</h3><p><img src="https://pic4.zhimg.com/80/v2-3ec15f2e8ab0b97b7818e1d94d9dbd9b_720w.webp" alt=""><br>其实在了解电流环之后剩下的两个环不难理解，这里不再赘述。<br>至此整个控制环节基本结束，但是我们注意到电流环的输出线给到了RevPark变换先还原到$\alpha-\beta$坐标系下，但是却没有RevClark变换，而是转到了一个叫做SVPWM的东西，它的输出是三相每一相的电压。</p><h2 id="SVPWM"><a href="#SVPWM" class="headerlink" title="SVPWM"></a>SVPWM</h2><p>全称Space Vector PWM，也是PWM，但是加上了空间电压矢量的前缀，我们首先把SV搞明白。</p><h3 id="Space-Vector"><a href="#Space-Vector" class="headerlink" title="Space Vector"></a>Space Vector</h3><p>我们不妨先把线圈通电，就像图中这样<br><img src="https://pic4.zhimg.com/80/v2-28c5ce7876603e45d61668e290e371e3_720w.webp" alt=""><br>我们假设每个线圈的电阻都是相同的，我们可以得到这样一个电路<br><img src="https://pic2.zhimg.com/80/v2-f4cd3936b0c1599086576e4ba5f7f9bd_720w.webp" alt=""><br>这是非常简单的一个分压电路，容易计算得出各相的相电压</p><script type="math/tex; mode=display">\begin{array}{l}U_{a}=U_{A}-U_{N}=\frac{2}{3} U_{d c} \\U_{b}=U_{B}-U_{N}=-\frac{1}{3} U_{d c} \\U_{c}=U_{C}-U_{N}=-\frac{1}{3} U_{d c}\end{array}</script><p>各相电压的方向是和电流方向相同的，我们规定正方向是指向中心的方向的话，就能得到这么一幅图<br><img src="https://pic2.zhimg.com/80/v2-33a33723f55b80d28efa4d59af68739d_720w.webp" alt=""><br>这个合成的向量是$AO$方向的，由右手螺旋定则能看出其$N$朝向下方，而根据我们前面的分析，转子会努力转到这个方向上来，也就是说，SpaceVector代表了转子的方向（或者电机角度），而改变电机转子的角度就需要去改变空间电压矢量的方向，而空间电压矢量本质上来说，是半桥的不同开关状态导致了各相电压的不同，进而影响了空间电压矢量的位置。</p><p>我们定义一个开关函数$S(x)$用来描述半桥开关时的状态</p><script type="math/tex; mode=display"> S(x)=\left\{  \begin{aligned}  1&,上桥臂导通\\ 0&,下桥臂导通  \end{aligned} \right.</script><p>注意：在一个开关动作中，上下桥臂不能同时开启，同时开启则意味着短路，为此还需要引入死区时间控制来保证这一点。<br>对于三相电机而言，$(S_a,S_b.S_c)$的组合为八个，去掉两个零矢量（0,0,0）和（1,1,1）(去掉的原因是这两个状态线圈时没有电流的，不产生力矩)，剩下的六个空间电压矢量能明显的看出来和之前的六步换向很像。我们如果想让一个空间电压矢量去旋转的任意方向，就需要对六个空间电压矢量去进行合成，也就是SVPMM技术。</p><h2 id="SVPWM-1"><a href="#SVPWM-1" class="headerlink" title="SVPWM"></a>SVPWM</h2><p><img src="https://pic1.zhimg.com/80/v2-1d0392a19bc58c20f2c440d9c06edc8c_720w.webp" alt=""><br>为了简便处理，我们不会使用六个矢量去合成，能看到这六个矢量把整个空间分成了六个扇区，我们会首先判断矢量所在扇区的位置，然后用扇区的两个电压矢量去合成扇区内的任意电压矢量，即有</p><script type="math/tex; mode=display">U_{ref}\cdot\ T=U_x \cdot T_x+U_y \cdot T_y+U^*_0 \cdot T_0^*</script><p>公式中，$T$是一个PWM周期，$T_x,T_y,T_0^*$都是对应矢量的作用时间，插入零矢量会让空间电压矢量切换的更加顺滑。<br>比如说，我们要在扇区$I$内去合成一个指定角度的空间电压矢量$U_{ref}$<br><img src="https://img-blog.csdn.net/20180207132645570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGR1Y29sbGlucw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>由正弦定理有</p><script type="math/tex; mode=display">\frac{\frac{T_6}{T}U_6}{\sin \theta}=\frac{\frac{T_4}{T}U_4}{\sin (\frac{\pi}{3}-\theta)}=\frac{U_{ref}}{\sin \frac{2\pi}{3}}</script><p>能计算出</p><script type="math/tex; mode=display">\begin{aligned}T_4&=mT\sin(\frac{\pi}{3}-\theta)\\T_6&=mT\sin\theta\end{aligned}</script><p>剩余时间则分配给零矢量，至此，整个FOC的控制部分就全部结束了，但我们还有一个问题，虽然理论上来说，只要这个电压矢量的时间持续的够长，这六个开关怎么开关都行，但是开关对于MOS是有损耗的，我们希望尽可能减少开关的次数，因此有了下面的切换顺序<br><img src="https://pic1.zhimg.com/80/v2-c69c43d31f65da0ac541be7d03102d10_720w.webp" alt=""><br>我们在实际中会把PWM配置成中心对齐模式，在这种开关控制模式下，每一次都只会开关一次，而零矢量被分配在了起始和中间位置，有效降低了开关次数的同时也就降低了PWM的谐波分量。同理也可以列出其他扇区的切换顺序。<br><img src="https://pic1.zhimg.com/80/v2-f5aed28538a791f5e760a0bc66081a9c_720w.webp" alt=""><br>至此，整个FOC的九个步骤全部完成.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/14/kong-zhi-li-lun/dong-tai-xi-tong-de-jian-mo-yu-fen-xi/dong-tai-xi-tong-de-jian-mo-yu-fen-xi/"/>
      <url>/2024/04/14/kong-zhi-li-lun/dong-tai-xi-tong-de-jian-mo-yu-fen-xi/dong-tai-xi-tong-de-jian-mo-yu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="拉普拉斯变换"><a href="#拉普拉斯变换" class="headerlink" title="拉普拉斯变换"></a>拉普拉斯变换</h1><script type="math/tex; mode=display">\mathscr{L}[f(x)]=F(s)=\int_0^\infty f(t)e^{-st}dt=\int_0^\infty f(t)e^{-(\sigma +jw)}</script><script type="math/tex; mode=display">\mathscr{L}(e^{-at})=\int_0^\infty e^{-(a+s)t}dt =\frac{1}{a+s}</script><script type="math/tex; mode=display">\mathscr{L}[af(t)+bg(t)]=a\mathscr{L}[f(t)]+b\mathscr{L}[g(t)]</script><script type="math/tex; mode=display">\mathscr{L}[sinat]=\int_0^{\infty}\frac{e^{jat}-e^{-jat}}{2j}e^sdt=\frac{1}{2j}(\mathscr{L}[e^{jat}]+\mathscr{L}[e^{-jat}])=\frac{a}{s^2+a^2}</script><script type="math/tex; mode=display">\mathscr{L}[\frac{df(t)}{dt}]=\int_0^{\infty}e^{-s}df(t)=sF(s)-F(0)</script><script type="math/tex; mode=display">\mathscr{L}[f(t)*g(t)]=F(s)G(s)</script><p>后续不再推导，有时间在补充，拉普拉斯逆变换就是个记公式的过程。</p><h1 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/08/stm32/rtthread/"/>
      <url>/2024/04/08/stm32/rtthread/</url>
      
        <content type="html"><![CDATA[<h1 id="线程启动与切换过程详解"><a href="#线程启动与切换过程详解" class="headerlink" title="线程启动与切换过程详解"></a>线程启动与切换过程详解</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/06/robomaster/2024rmul-fu-pan/"/>
      <url>/2024/04/06/robomaster/2024rmul-fu-pan/</url>
      
        <content type="html"><![CDATA[<h1 id="不能将就"><a href="#不能将就" class="headerlink" title="不能将就"></a>不能将就</h1><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li>自瞄稳定性不够熟悉，不稳定。</li><li>导航 </li><li>哨兵先不动 需要电控机械配合</li><li>机械臂交给电控<h1 id="机械"><a href="#机械" class="headerlink" title="机械"></a>机械</h1></li><li>人手不够。</li><li>走线设计问题。</li><li>大三同学去留问题。</li><li>文档。<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2024/04/03/stm32/freertos/"/>
      <url>/2024/04/03/stm32/freertos/</url>
      
        <content type="html"><![CDATA[<h1 id="中断模式和中断事件模式"><a href="#中断模式和中断事件模式" class="headerlink" title="中断模式和中断事件模式"></a>中断模式和中断事件模式</h1><p>两者的区别在于中断的事件模式仅仅会将设备从低功耗条件下唤醒而不执行代码，也就是说，没有ISR。</p><p>byd,osDelay怎么不切换线程。。。</p><h1 id="Kernel-Settings"><a href="#Kernel-Settings" class="headerlink" title="Kernel Settings"></a>Kernel Settings</h1><h2 id="USE-PREEMPTION"><a href="#USE-PREEMPTION" class="headerlink" title="USE_PREEMPTION"></a>USE_PREEMPTION</h2><p>1：抢占式调度器（preemptive a. 抢占的）<br>0：时间片调度（cooperative a. 协作的）<br>USE_PREEMPTION 是 <strong>RTOS 的调度方式选择，为 1 时使用抢占式调度器，为 0 时使用协程</strong>，如果使用抢占式调度器的话内核会在每个时钟节拍中断中进行任务切换，当使用协程的话会在如下地方进行任务切换</p><ol><li>一个任务调用了函数 taskYIELD()。</li><li>一个任务调用了可以使任务进入阻塞态的 API 函数。</li><li>应用程序明确定义了在中断中执行上下文切换。<h2 id="CPU-CLOCK-HZ"><a href="#CPU-CLOCK-HZ" class="headerlink" title="CPU_CLOCK_HZ"></a>CPU_CLOCK_HZ</h2></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/29/za-ji/le-yu-zhu-ren-de-hu-gua-yu-lei-feng-you-shi-me-qu-bie/"/>
      <url>/2024/03/29/za-ji/le-yu-zhu-ren-de-hu-gua-yu-lei-feng-you-shi-me-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>胡适所谓乐于助人的行为，大多是资助他人完成学业或者资助好友，比较典型的例子是资助林语堂</p><blockquote><p>在当时，与胡适一同到美国留学的林语堂便是众多贫困子弟中的一个，并且由于家境贫困，即使林语堂在空闲时间全部用于打工赚钱，仍然无法凑齐学费，日常生活也经常是饿一顿饱一顿的。眼看学费自筹无望，担心学校给处分的林语堂求助胡适，希望能够借得资金以供自己读书所需。胡适得知此事，立马给林语堂汇去了一千元美金，为了让他安心，<strong>胡适说这是北京大学预支的薪水，需要毕业后打工还债。</strong><br>林语堂得到钱解了自己的燃眉之急，心中虽然对胡适越俎代庖的做法有所不满，但也无法倒打一耙。林语堂毕业后再次求学深造，学费无助，又向胡适求助，这一次，胡适还说是“北大预支”。到林语堂学有所成，收拾一切回国来到北京大学，准备还当年“欠下的债”，才知道这是胡适当年为了让自己安心而编的谎话。</p></blockquote><p>不管怎么说，尽管上课的时候认为他是一个公知，单单从这个来看，这个人的本性还是不错的，但是资助他人的理由真的是他<strong>愿意去不计后果和利益</strong>而资助吗？我们并不知道，胡适夫人江冬秀评价他：“一生装的像个慈善家”，不知道她在收拾他可怜的存款的时候的自言自语是真的觉得他的丈夫胸怀天下，还是处于别的原因呢？我们无从得知。</p><p>他无疑是一个十分复杂的人，但是我个人更倾向于他本身的善良，他愿意去帮助别人，是他自己的本性，尽管胡适在政治上表现得非常差劲，“非常天真”，政治上的问题和他的善良本性无关。</p><p>对于雷锋而言，这是从小到大听过来的，无疑从现有史实挑不出刺，是过去二十世纪四五十年代典型的忠厚老实的中国人，他真的是从本心出发，愿意去帮助别人。</p><p>所以，我认为，这俩人的乐于助人貌似没什么区别，硬要去分辨的话就只有请他们的好友和史实来判断了。</p><p>参考文献:<br><a href="https://zhuanlan.zhihu.com/p/427291393">胡适去世后江冬秀说他：“一生装得像个慈善家” - 知乎</a><br><a href="https://xingminghu.commons.gc.cuny.edu/etc/hushih/mao_on_hushi/">替胡适恢复名誉 | Xingming Hu | 胡星铭</a><br><a href="https://sd.ifeng.com/zbc/detail_2014_09/19/2930982_0.shtml">胡适最令毛泽东生气的话：他当时水平考不上北大_山东频道_凤凰网</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9B%B7%E9%94%8B">雷锋 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E8%83%A1%E9%81%A9">胡适 - 维基百科，自由的百科全书</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>问题</title>
      <link href="/2024/03/22/za-ji/wen-ti/"/>
      <url>/2024/03/22/za-ji/wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="TVS和ESD的区别，用来防止栅极过冲使用ESD是否可行"><a href="#TVS和ESD的区别，用来防止栅极过冲使用ESD是否可行" class="headerlink" title="TVS和ESD的区别，用来防止栅极过冲使用ESD是否可行"></a>TVS和ESD的区别，用来防止栅极过冲使用ESD是否可行</h1><p><a href="https://zhuanlan.zhihu.com/p/157498935">ESD和TVS管</a><br><strong>国际上习惯将用于静电防护的器材统称为ESD（即TVS管也属于ESD）</strong><br>还是用TVS吧，我害怕。<br>还是没搞明白。</p><h1 id="如何正确使用示波器"><a href="#如何正确使用示波器" class="headerlink" title="如何正确使用示波器"></a>如何正确使用示波器</h1><p>ADI an-1144</p><h1 id="TVS的各类封装及其大小"><a href="#TVS的各类封装及其大小" class="headerlink" title="TVS的各类封装及其大小"></a>TVS的各类封装及其大小</h1><h1 id="PowerGood的指示作用-LED？"><a href="#PowerGood的指示作用-LED？" class="headerlink" title="PowerGood的指示作用 LED？"></a>PowerGood的指示作用 LED？</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>工作记录</title>
      <link href="/2024/03/22/za-ji/gong-zuo-ji-lu/"/>
      <url>/2024/03/22/za-ji/gong-zuo-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="2024-3-22"><a href="#2024-3-22" class="headerlink" title="2024/3/22"></a>2024/3/22</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/01/roboamaster-kai-fa-ban/ying-jian-fang-an/"/>
      <url>/2024/03/01/roboamaster-kai-fa-ban/ying-jian-fang-an/</url>
      
        <content type="html"><![CDATA[<p>主控：STM32F103CBT6<br>锂电池充放电管理：IP5306，带有四颗LED灯指示电量。<br>充电口：MicroUSB<br>气体压力传感器：AGR10系列表压型传感器。<br>运算放大器：OPA376<br>选用3.7V电池或者18560锂电池。<br>ADC读取气压数据<br>IIC与OLED屏幕连接用以显示数据 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/02/18/chao-ji-dian-rong/zhuan-li/"/>
      <url>/2024/02/18/chao-ji-dian-rong/zhuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="一种基于Type3型补偿器的超级电容组及其控制器"><a href="#一种基于Type3型补偿器的超级电容组及其控制器" class="headerlink" title="一种基于Type3型补偿器的超级电容组及其控制器"></a>一种基于Type3型补偿器的超级电容组及其控制器</h1><h2 id="技术领域"><a href="#技术领域" class="headerlink" title="技术领域"></a>技术领域</h2><p>本发明涉及机器人电池技术领域，特别适用一种基于Type3型补偿器的超级电容组及其控制器</p><h2 id="背景技术"><a href="#背景技术" class="headerlink" title="背景技术"></a>背景技术</h2><h2 id="发明内容"><a href="#发明内容" class="headerlink" title="发明内容"></a>发明内容</h2><p>本专利正是基于现有技术的上述需求而提出的，本专利要解决的技术问题是，在电源输出功率受限制的情况下，给出一种超级电容组及其控制器，能够平滑补偿机器人需要远超出电源输出功率下的应用场景，如紧急功率补充和高峰功率需求等，并利用超级电容的储能能力，实现了多余动能回收利用，提高了电源的使用效率。<br>本专利还利用外置隔离电源的方法使得超级电容控制器的上侧功率管能够常开，降低了功率管的导通损耗，进一步提高了电源使用效率。<br>本专利提供的技术方案包括：超级电容组和超级电容控制器。<br>所述超级电容组包括11个超级电容单体和过压保护电路。<br>进一步地，所述超级电容单体为2.7V，50F，单体之间通过串联形成电容组，理论最大能量2004J，充电至2.65V，最终电压29.15V，理论能量1931.1875J；<br>所述过压保护电路由BW6101超级电容保护芯片及其外围电路组成。<br>所述超级电容控制器包括采集模块，MCU控制模块，通信模块，功率模块和辅助电源模块。<br>所述MCU控制模块对接收的数据进行处理，输出PWM信号控制功率模块调节输出并通过通信模块将必要数据传输至机器人控制系统。<br>所述功率模块为Buck-Boost双向DCDC变换器，包括八个MOSFET功率开关管，一个电感，两个栅极驱动器和一个隔离电源模块。<br>所述通信模块包括CAN通信和UART串口通信，所述MCU控制模块通过所述CAN接口接入机器人CAN总线，与机器人控制系统新型数据交换；所述UART串口通信将与上位机相连接，传输必要调试数据并显示波形帮助调试。<br>所述采集模块包括电压采集模块和电流采集模块，对所述功率模块和超级电容组进行电压和电流采样，并送至所述MCU控制模块的ADC输入通道。<br>所述辅助电源模块包括两个Buck降压DCDC电路，一个LDO降压电路，一个高精度电压基准源和一个隔离电源模块。<br>进一步地。所诉电压采集模块使用运算放大器搭建的采集电路，将采集的电压信号进行缩小。所述运算放大器选用ADI<br>公司的<br>进一步地，所述电流采集模块使用电流感应放大器，型号为德州仪器的INA240。<br>进一步地，所述MCU控制模块包括单片机及其外围电路。所述单片机为ST公司的STM32G474RET6。所述外围电路包括去耦电容，高速外部晶振和复位电路。<br>进一步地，所述CAN通信包括CAN收发器及其外围电路，所述CAN收发器选用TJA1044。所述外围电路包括去耦电容，信号线匹配电阻和CAN终端电阻。<br>进一步地，所述串口通信包括USB转UART芯片及其外围电路，所述USB转UART芯片选用CH340K。所述外围电路包括退耦电容和信号线匹配电阻。<br>进一步地，所述辅助电源模块的LDO降压电路主要为MCU控制模块和高精度电压基准源提供电力，所述Buck降压DCDC电路第一个为24V转12V，为功率模块中的栅极驱动器和辅助电源模块中的隔离电源模块提供电源；第二个Buck降压DCDC电路为24V转5V，为LDO和通信模块中的CAN收发器和USB转UART芯片提供电源。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2024/01/31/roboamaster-kai-fa-ban/zhuan-li/"/>
      <url>/2024/01/31/roboamaster-kai-fa-ban/zhuan-li/</url>
      
        <content type="html"><![CDATA[<ol><li>发明和实用新型专利申请应提交的文件基本相同，即：请求书、说明书、说明书附图、权利要求书、说明书摘要及摘要附图。但某些发明专利申请可以不提交说明书附图和摘要附图。<h1 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h1></li><li>导航路径规划。1</li><li>超电 1</li><li>平衡车打滑检测 1</li><li>平衡车占坑 （？）</li><li>rtt多线程信息机制（占坑）1</li><li>机械臂控制系统。1</li><li>自瞄+CDC？0</li><li><p>英雄占坑（RTT电控框架）1<br>18号中期考核 晚上八点</p></li><li><p>发票 预算</p></li><li>赞助 优信 3D打印耗材 Polymaker </li><li>英雄 机械大更新</li><li>全向轮 裁判系统 </li><li>完整裁判系统购买（delay）凑平步的</li><li>哨兵云台 </li><li>队服</li><li>开学测无人机电机</li><li>操作手训练</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CMake</title>
      <link href="/2024/01/30/cmake/cmake/"/>
      <url>/2024/01/30/cmake/cmake/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">set(CMAKE_SYSTEM_NAME Generic)  # 指定构建系统为通用系统set(CMAKE_SYSTEM_VERSION 1)  cmake_minimum_required(VERSION 3.26)  # 指定最低CMake版本要求# specify cross-compilers and tools  set(CMAKE_C_COMPILER arm-none-eabi-gcc)  set(CMAKE_CXX_COMPILER arm-none-eabi-g++)  set(CMAKE_ASM_COMPILER arm-none-eabi-gcc)  set(CMAKE_AR arm-none-eabi-ar)  set(CMAKE_OBJCOPY arm-none-eabi-objcopy)  set(CMAKE_OBJDUMP arm-none-eabi-objdump)  set(SIZE arm-none-eabi-size)  set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)    # project settings  project(Competitoin_version C CXX ASM)  set(CMAKE_CXX_STANDARD 17)  set(CMAKE_C_STANDARD 11)    #Uncomment for hardware floating point  add_compile_definitions(ARM_MATH_CM4;ARM_MATH_MATRIX_CHECK;ARM_MATH_ROUNDING)  add_compile_options(-mfloat-abi&#x3D;hard -mfpu&#x3D;fpv4-sp-d16)  add_link_options(-mfloat-abi&#x3D;hard -mfpu&#x3D;fpv4-sp-d16)    #Uncomment for software floating point  #add_compile_options(-mfloat-abi&#x3D;soft)    #add_compile_options(-mcpu&#x3D;cortex-m4 -mthumb -mthumb-interwork)  #add_compile_options(-ffunction-sections -fdata-sections -fno-common -fmessage-length&#x3D;0)    # uncomment to mitigate c++17 absolute addresses warnings  #set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wno-register&quot;)    # Enable assembler files preprocessing  add_compile_options($&lt;$&lt;COMPILE_LANGUAGE:ASM&gt;:-x$&lt;SEMICOLON&gt;assembler-with-cpp&gt;)    if (&quot;$&#123;CMAKE_BUILD_TYPE&#125;&quot; STREQUAL &quot;Release&quot;)      message(STATUS &quot;Maximum optimization for speed&quot;)      add_compile_options(-Ofast)  elseif (&quot;$&#123;CMAKE_BUILD_TYPE&#125;&quot; STREQUAL &quot;RelWithDebInfo&quot;)      message(STATUS &quot;Maximum optimization for speed, debug info included&quot;)      add_compile_options(-Ofast -g)  elseif (&quot;$&#123;CMAKE_BUILD_TYPE&#125;&quot; STREQUAL &quot;MinSizeRel&quot;)      message(STATUS &quot;Maximum optimization for size&quot;)      add_compile_options(-Os)  else ()      message(STATUS &quot;Minimal optimization, debug info included&quot;)      add_compile_options(-Og -g)  endif ()    include_directories(Core&#x2F;Inc      Drivers&#x2F;STM32F4xx_HAL_Driver&#x2F;Inc          Drivers&#x2F;STM32F4xx_HAL_Driver&#x2F;Inc&#x2F;Legacy           Drivers&#x2F;CMSIS&#x2F;Device&#x2F;ST&#x2F;STM32F4xx&#x2F;Include         Drivers&#x2F;CMSIS&#x2F;Include          bsp)    add_definitions(-DDEBUG -DUSE_HAL_DRIVER -DSTM32F411xE)    file(GLOB_RECURSE SOURCES &quot;Core&#x2F;*.*&quot; &quot;Drivers&#x2F;*.*&quot; &quot;bsp&#x2F;*.*&quot;)    set(LINKER_SCRIPT $&#123;CMAKE_SOURCE_DIR&#125;&#x2F;STM32F411CEUX_FLASH.ld)    add_link_options(-Wl,-gc-sections,--print-memory-usage,-Map&#x3D;$&#123;PROJECT_BINAY_DIR&#125;&#x2F;$&#123;PROJECT_NAME&#125;.map)  add_link_options(-mcpu&#x3D;cortex-m4 -mthumb -mthumb-interwork)  add_link_options(-T $&#123;LINKER_SCRIPT&#125;)    add_executable($&#123;PROJECT_NAME&#125;.elf $&#123;SOURCES&#125; $&#123;LINKER_SCRIPT&#125;)    set(HEX_FILE $&#123;PROJECT_BINARY_DIR&#125;&#x2F;$&#123;PROJECT_NAME&#125;.hex)  set(BIN_FILE $&#123;PROJECT_BINARY_DIR&#125;&#x2F;$&#123;PROJECT_NAME&#125;.bin)    add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.elf POST_BUILD          COMMAND $&#123;CMAKE_OBJCOPY&#125; -Oihex $&lt;TARGET_FILE:$&#123;PROJECT_NAME&#125;.elf&gt; $&#123;HEX_FILE&#125;          COMMAND $&#123;CMAKE_OBJCOPY&#125; -Obinary $&lt;TARGET_FILE:$&#123;PROJECT_NAME&#125;.elf&gt; $&#123;BIN_FILE&#125;          COMMENT &quot;Building $&#123;HEX_FILE&#125;  Building $&#123;BIN_FILE&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="语法杂记"><a href="#语法杂记" class="headerlink" title="语法杂记"></a>语法杂记</h1><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p>在CMake中，<code>set()</code> 函数用于定义变量及其值。这是CMake脚本中非常基本和重要的一个功能，用于配置项目构建过程中需要的各种参数。这个函数的基本语法是：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set(VARIABLE_NAME value1 value2 ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，<code>VARIABLE_NAME</code> 是你想要设置的变量的名称，而后面跟着的是一个或多个值，这些值将被赋给这个变量。变量的值可以是字符串、文件路径、布尔值等。</p><p>例如:</p><ul><li><p>设置一个简单的字符串变量：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set(MY_VARIABLE &quot;Hello World&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后可以使用<code>$&#123;MY_VARIABLE&#125;</code>来引用这个值。</p></li><li><p>设置文件或目录路径：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set(SOURCE_FILES main.cpp utils.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里<code>SOURCE_FILES</code> 变量包含了两个源文件的名称。</p></li><li><p>设置一个列表：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set(FILES file1.txt file2.txt file3.txt)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，<code>FILES</code> 变量现在包含了三个文件名的列表。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Cmake C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号与系统</title>
      <link href="/2024/01/25/xin-hao-yu-xi-tong/xin-hao-yu-xi-tong/"/>
      <url>/2024/01/25/xin-hao-yu-xi-tong/xin-hao-yu-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="信号与系统"><a href="#信号与系统" class="headerlink" title="信号与系统"></a>信号与系统</h1><h2 id="1-1-连续时间和离散时间信号"><a href="#1-1-连续时间和离散时间信号" class="headerlink" title="1.1 连续时间和离散时间信号"></a>1.1 连续时间和离散时间信号</h2><p>我们只考虑两种类型的信号，如上所示，前者在自变量的连续值上有定义，而后者只在离散时间点上有定义，为了区分这两类信号，我们用$t$表示连续时间变量，用$n$表示离散时间变量，譬如，$x(t)$是一个连续时间信号，而$x[n]$代表离散时间信号（或者离散时间序列）</p><h3 id="1-1-2-信号能量与功率"><a href="#1-1-2-信号能量与功率" class="headerlink" title="1.1.2 信号能量与功率"></a>1.1.2 信号能量与功率</h3><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><ol><li>周期信号相加最后为周期信号的条件是两周期之比为有理数</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>硬件组考核</title>
      <link href="/2023/12/09/dian-zi-dian-li/ying-jian-zu-kao-he/ying-jian-zu-kao-he/"/>
      <url>/2023/12/09/dian-zi-dian-li/ying-jian-zu-kao-he/ying-jian-zu-kao-he/</url>
      
        <content type="html"><![CDATA[<p>自行阅读学习有关Buck电路的相关知识，并阅读MP2315S的DataSheet，对其典型应用电路进行分析，并回答下列问题：</p><ol><li>$R3$的作用是什么？它是怎么影响电源的？</li><li>如何控制开启和关闭芯片？</li><li>什么是前馈电容？</li><li>电感应该如何选型？</li><li>如果有一24V电源输入，我该如何更改电路使其能够输出12V电压？</li><li>如何计算所需电感感值？假设电源输入24V，输出5V3A（选做）</li><li>如果输出电容总计50uF左右，应该选取5个10uF电容还是使用100nF+10uF+22uF+22uF？为什么？</li><li>该电路的Layout要求。</li><li>试给出一使用该芯片的降压电路，电源输入24V，输出5V3A，给出原理图和PCB文件<br>（以上所有问题均可自由在互联网上查找答案，但需指明在何处看到了什么文章，看到了哪句话使你觉得是这个问题的答案。）<br>于周一中午12：00前给出收集问卷，请将答案以pdf文件上传。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HRTIM</title>
      <link href="/2023/12/09/chao-ji-dian-rong/hrtim/"/>
      <url>/2023/12/09/chao-ji-dian-rong/hrtim/</url>
      
        <content type="html"><![CDATA[<p>前置条件：STM32G474，170MHz（HSE），定时器使能如图所示<br><img src="https://pic1.zhimg.com/80/v2-2aec432984e65fd476b03343c6d2ffb3_720w.png" alt=""></p><h1 id="Master-Timer"><a href="#Master-Timer" class="headerlink" title="Master Timer"></a>Master Timer</h1><h2 id="Time-Base-Setting"><a href="#Time-Base-Setting" class="headerlink" title="Time Base Setting"></a>Time Base Setting</h2><h3 id="PrecalerRatio"><a href="#PrecalerRatio" class="headerlink" title="PrecalerRatio"></a>PrecalerRatio</h3><p>用于设置定时器分频</p><h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p>设置定时器周期，至少为三个HRTIM时钟周期。</p><h3 id="RepetitionCounter"><a href="#RepetitionCounter" class="headerlink" title="RepetitionCounter"></a>RepetitionCounter</h3><p>重复周期计数器 用途未知。</p><h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>貌似都是continuous mode 后面再说</p><h2 id="Timing-Unit"><a href="#Timing-Unit" class="headerlink" title="Timing Unit"></a>Timing Unit</h2><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h2><p>STM32 定时器的 Preload 功能是一种非常有用的特性，它允许在不影响当前计时周期的情况下，预先设置定时器的自动重装载寄存器（ARR）或比较寄存器（比如捕获/比较寄存器 CCR）。这个功能在生成精确的时间延迟或测量时间间隔，以及在PWM（脉冲宽度调制）输出时控制波形的具体形状时非常有用。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>PWM波形生成</strong>：在PWM应用中，经常需要调整周期或占空比来控制电机速度、LED亮度等。使用preload功能，可以在当前周期结束前预设下一周期的参数，这样可以避免在周期中间更改参数可能导致的突然跳变或不稳定现象。</li><li><strong>时间控制</strong>：在需要精确控制时间间隔的应用中，比如通信协议的实现，可以通过预装载ARR来准确设置时间间隔，确保通信的准确性和稳定性。</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><strong>自动重装载寄存器（ARR）Preload</strong>：当ARR preload功能被启用时，对ARR寄存器的更新不会立即生效，而是在当前计数周期结束时自动更新。这保证了计时周期的稳定性和准确性。</li><li><strong>捕获/比较寄存器（CCR）Preload</strong>：对于CCR，preload功能同样允许在不干扰当前输出状态的情况下更新其值。在PWM模式下，这可以用来平滑地调整占空比。</li></ul><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><strong>配置TIMx_CR1的ARPE位</strong>：通过设置TIMx的控制寄存器CR1中的ARPE位（自动重装载预装载使能），可以启用ARR的preload功能。</li><li><strong>配置TIMx_CCMRx的OCxPE位</strong>：对于CCR的preload功能，需要在TIMx的捕获/比较模式寄存器CCMRx中设置OCxPE位（输出比较x预装载使能）。</li><li><strong>加载新值</strong>：将新的周期值写入ARR或新的比较值写入CCR。</li><li><strong>更新请求</strong>：通常，需要一个更新事件（如计数器溢出）来使预装载的值生效。在某些模式下，可以通过软件生成一个立即更新的事件。</li></ol><h1 id="Repetition-Update"><a href="#Repetition-Update" class="headerlink" title="Repetition Update"></a>Repetition Update</h1><p>STM32G474微控制器的高分辨率定时器（HRTIM）是一个高级功能，旨在满足精确的定时和波形生成需求。其中的“Repetition Update”功能是该定时器的一个重要特性。</p><p>“Repetition Update”的主要作用是控制何时更新定时器的寄存器。在HRTIM中，有一些寄存器是受保护的，这意味着在定时器运行时，这些寄存器的值不能随意改变，以避免产生不稳定的输出波形或是不准确的定时行为。因此，“Repetition Update”允许用户设定一个重复计数器，指定定时器完成多少周期后才更新这些寄存器的内容。</p><p>使用“Repetition Update”功能的优势包括：</p><ol><li><strong>增强稳定性</strong>：通过在适当的时机更新寄存器值，可以避免在输出周期中间改变设置，从而保持输出波形的稳定。</li><li><strong>提高灵活性</strong>：用户可以根据需要配置更新频率，这对于需要频繁调整输出波形或定时参数的应用非常有用。</li><li><strong>优化性能</strong>：在特定的应用中，如电机控制，可以通过精确地调整更新频率来优化系统的响应时间和效率。</li></ol><p>在实际应用中，如果需要定时器在不同的输出周期内实现不同的行为，或者根据外部事件调整定时器的行为，这时“Repetition Update”就显得尤为重要。例如，在PWM（脉冲宽度调制）应用中，可能需要在不同的PWM周期中应用不同的占空比设置，而这些设置的更新就可以依赖于“Repetition Update”功能来实现定时和同步更新。</p><h2 id="by-the-way"><a href="#by-the-way" class="headerlink" title="by the way"></a>by the way</h2><p><del>没太看懂，但是大家都加上了我也加上吧（）</del></p><h1 id="HRTIM中心对齐PWM"><a href="#HRTIM中心对齐PWM" class="headerlink" title="HRTIM中心对齐PWM"></a>HRTIM中心对齐PWM</h1><p>使用Master同步两个定时器（Timer A和Timer B），两个子定时器只有一个输出（TA1/TB1）。</p><h2 id="如果不同步的后果"><a href="#如果不同步的后果" class="headerlink" title="如果不同步的后果"></a>如果不同步的后果</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">HAL_HRTIM_WaveformCountStart(&amp;hhrtim1,HRTIM_TIMERID_TIMER_A);  HAL_HRTIM_WaveformOutputStart(&amp;hhrtim1,HRTIM_OUTPUT_TA1);  HAL_HRTIM_WaveformCountStart(&amp;hhrtim1, HRTIM_TIMERID_TIMER_B);  HAL_HRTIM_WaveformOutputStart(&amp;hhrtim1, HRTIM_OUTPUT_TB1);    __HAL_HRTIM_SETCOMPARE(&amp;hhrtim1, HRTIM_TIMERINDEX_TIMER_A, HRTIM_COMPAREUNIT_1, 200);  __HAL_HRTIM_SETCOMPARE(&amp;hhrtim1, HRTIM_TIMERINDEX_TIMER_B, HRTIM_COMPAREUNIT_1, 200);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么写的后果是在示波器上两个PWM输出端会发生相移，不是预期中的两个PWM波的起点是相同的。<br><del>byd照片没了，艹</del><br>如果你不用主定时器去同步的话，请在Start初始化的时候一起初始化，譬如：<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">HAL_HRTIM_WaveformCountStart(&amp;hhrtim1,HRTIM_TIMERID_TIMER_A | HRTIM_TIMERID_TIMER_B);  HAL_HRTIM_WaveformOutputStart(&amp;hhrtim1,HRTIM_OUTPUT_TA1 | HRTIM_OUTPUT_TB1);      __HAL_HRTIM_SETCOMPARE(&amp;hhrtim1, HRTIM_TIMERINDEX_TIMER_A, HRTIM_COMPAREUNIT_1, 200);  __HAL_HRTIM_SETCOMPARE(&amp;hhrtim1, HRTIM_TIMERINDEX_TIMER_B, HRTIM_COMPAREUNIT_1, 200);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这样的话就能看见两个一模一样的PWM波形了。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>尝试使用Up-Down Countering去生成中心对齐PWM，示波器上能看见周期翻倍了，但是Duty被锁死在了0.5，问题可复现，尚未有解决方案。</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h1 id="Master-定时器"><a href="#Master-定时器" class="headerlink" title="Master 定时器"></a>Master 定时器</h1><p><img src="https://pic1.zhimg.com/80/v2-52027b3db7f468bb81bea0171ec1f668_1440w.png" alt=""><br>后面都是disable，开了PreLoad和重复更新<br>这里跟着CSDN配置的，开了中断源，NVIC也开中断了，但是我没用中断输出，我直接<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">HAL_HRTIM_WaveformCountStart(&amp;hhrtim1,HRTIM_TIMERID_Master);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>实测无影响。但是没测试过关了之后什么样，有时间再说</p><h2 id="TimerA"><a href="#TimerA" class="headerlink" title="TimerA"></a>TimerA</h2><p><img src="https://picx.zhimg.com/80/v2-3e2f6cce2cb1e510c811f208ee054d07_1440w.png" alt=""><br><img src="https://pica.zhimg.com/80/v2-b7217745a46a8454de907f9715b62451_1440w.png" alt=""><br>子定时器如果想用Master去做同步更新，就要在 Reset Trigger Source里面选上跟随Master周期更新，开了两个比较的单元，没用2的原因是貌似跟ADC有关，<del>然后3和1又是一样的就直接用3了</del>。<br>这里TimerA是用来生成中心对齐PWM波形的，TimerB是生成了一个正常的PWM波形，用来和中心对齐的波形进行对比<br>Set Source是选了Counting到比较单元1的值之后再变成高电平，Reset Source则是在每个周期的开始和计数到比较单元3之后波形变成低电平。<br>实际波形图<br>![[IMG_20240507_203349.jpg]]</p>]]></content>
      
      
      
        <tags>
            
            <tag> HRTIM STM32 超级电容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栅极驱动器</title>
      <link href="/2023/12/08/dian-zi-dian-li/dc-dc/zha-ji-qu-dong-qi/"/>
      <url>/2023/12/08/dian-zi-dian-li/dc-dc/zha-ji-qu-dong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="栅极电阻作用"><a href="#栅极电阻作用" class="headerlink" title="栅极电阻作用"></a>栅极电阻作用</h1><ol><li>抑制LC震荡，防止$V_{GS}$过大烧坏MOS。</li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> DC-DC </tag>
            
            <tag> 栅极驱动器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/10/16/dian-zi-dian-li/lm5122/lm5122-xue-xi-bi-ji/"/>
      <url>/2023/10/16/dian-zi-dian-li/lm5122/lm5122-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://wv9y1mjo8hb.feishu.cn/space/api/box/stream/download/asynccode/?code=NDdhNzMxNmFlOGZiZTViMmY3YTMxMDFhM2U0MDU4MWRfSGZlOHdocHhLMHNtYmYxS1pvMlkwOXNaMEkxV1ZJTGVfVG9rZW46Vzc4ZWJyWUFab2Z0S254eTBEaGNpUVljbnJkXzE2OTc0NTU0MTI6MTY5NzQ1OTAxMl9WNA" alt=""></p><h1 id="引脚解析"><a href="#引脚解析" class="headerlink" title="引脚解析"></a>引脚解析</h1><h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><p>BST是用来驱动高侧MOS的栅极驱动器电源，连接至外部自举二极管与一个电容，芯片内部有一电荷泵为电容充电用以驱动MOS。</p><h2 id="CSN-CSP"><a href="#CSN-CSP" class="headerlink" title="CSN/CSP"></a>CSN/CSP</h2><p>本质上是一个运算放大器的同相输入端与反相输入端，其与一个采样电阻相连接用以对输入电流进行采样。</p><h2 id="RES"><a href="#RES" class="headerlink" title="RES"></a>RES</h2><p>打嗝工作模式的选择<br><a href="https://www.eet-china.com/mp/a146201.html">峰值电流模式的过流保护：Hiccup打嗝工作模式</a></p><h2 id="SLOPE"><a href="#SLOPE" class="headerlink" title="SLOPE"></a>SLOPE</h2><p>斜坡补偿调整<br><a href="https://bbs.21dianyuan.com/thread-47567-1-1.html">https://bbs.21dianyuan.com/thread-47567-1-1.html</a></p><h2 id="SYNCIN-RT"><a href="#SYNCIN-RT" class="headerlink" title="SYNCIN/RT"></a>SYNCIN/RT</h2><p>外部连接一下拉电阻用以调整内部晶振的频率，其频率会影响内部开关频率。</p><h2 id="UVLO"><a href="#UVLO" class="headerlink" title="UVLO"></a>UVLO</h2><p>欠压保护编程引脚</p><p>如果 UVLO 引脚电压低于 0.4V，则调节器处于关闭模式，所有功能被禁用。如果 UVLO 引脚电压高于 0.4V 且低于 1.2V，则调节器处于待机模式，VCC 稳压器工作，HO 和LO 输出端无开关。如果 UVLO 引脚电压高于 1.2V，则启动顺序开始。当 UVLO 超过 1.2V 时，UVLO 引脚上的 A10- μA 电流源启动，并流过外部 UVLO 电阻，以提供迟滞。UVLO 引脚不应悬空。 —-DataSheet</p><h2 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h2><p>控制器的工作模式选择，主要是强制PWM模式和二极管仿真模式的切换</p><p><a href="https://e2echina.ti.com/blogs_/b/power_house/posts/buck">https://e2echina.ti.com/blogs_/b/power_house/posts/buck</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/09/21/dian-zi-dian-li/pcb/usb-hub/"/>
      <url>/2023/09/21/dian-zi-dian-li/pcb/usb-hub/</url>
      
        <content type="html"><![CDATA[<p>每一个USB3.1接口有六个数据线，阻抗均为90</p><h1 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h1><p>选用GL3510<br>引脚注意如下</p><ol><li>Pin32 下拉禁用下游端口充电，上拉启用充电</li><li>Pin16 串接一20k电阻下拉</li><li>FN_A、FN_B和FN_C，看上去应该上拉</li><li>3.3V和1.2V供电部分，每一个VP12，AVDD和DVDD连接一个100nF MLCC</li><li>数字供电和模拟供电需要隔离</li><li>VCC供给IC的5V记得滤波</li><li>SSTX需要100nF耦合电容，对称放置，靠近连接器,建议封装0402但必须小于0603</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/09/20/stm32/an-jian-fifo/"/>
      <url>/2023/09/20/stm32/an-jian-fifo/</url>
      
        <content type="html"><![CDATA[<p>FIFO是 First Input First Output的缩写，先入先出队列</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记</title>
      <link href="/2023/09/07/dian-zi-dian-li/dc-dc/za-ji/"/>
      <url>/2023/09/07/dian-zi-dian-li/dc-dc/za-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="线性电源"><a href="#线性电源" class="headerlink" title="线性电源"></a>线性电源</h1><p>压降（Dropout Voltage）</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol><li>$V_I$</li><li>$V_O$</li><li>压差</li><li>噪声</li><li>静态电流<br>DCDC和LDO之间需要插入一个磁珠和电容以形成低通滤波器滤除DCDC输出端的高频信号，使得LDO的输入端更纯净<br>设计注意事项<br>输入电容和输出电容要放在紧靠VIN，VOUT和GND的地方<br>IC的电源端口都必须经过电容<br>反馈信号要经过输出电容以后再引出到负载<br>输出侧和输入测的地要在IC处合在一起成为公共点<br>尽量加大焊盘面积<br>反馈组件应该放在靠近IC的地方<br>传统LDO不能并联而电流源型LDO可以</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> DC-DC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Armfly课程笔记</title>
      <link href="/2023/08/14/stm32/armfly-ke-cheng-bi-ji/"/>
      <url>/2023/08/14/stm32/armfly-ke-cheng-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="启动文件解析"><a href="#启动文件解析" class="headerlink" title="启动文件解析"></a>启动文件解析</h1><p>堆栈大小</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用通信阻抗要求</title>
      <link href="/2023/08/10/dian-zi-dian-li/layout-yao-qiu/chang-yong-tong-xin-zu-kang-yao-qiu/"/>
      <url>/2023/08/10/dian-zi-dian-li/layout-yao-qiu/chang-yong-tong-xin-zu-kang-yao-qiu/</url>
      
        <content type="html"><![CDATA[<h2 id="USB接口"><a href="#USB接口" class="headerlink" title="USB接口"></a>USB接口</h2><p>是Universal Serial Bus的缩写，即通用串行总线，是一个外部总线标准，用于规范电脑与外部设备的连接和通讯。是应用在PC领域的接口技术。<br>PCB-layout规则：<br>a. 总长度尽量控制在1800mil；<br>b. USB特性阻抗为90Ω,USB3.0的SSTX/SSRX极性可交换，长度误差5mil，USB2.0不可交换<br>c. 电源管脚走线宽度≥30mil;<br>d. O_USB_OC[0:3]/ 阻抗为60 Ω ± 15%。<br>e. ESD器件尽量靠近接口放置。<br>f. 信号长度，要求主板信号长度与底板信号长度之和不超过18inch”。</p><h2 id="VGA接口"><a href="#VGA接口" class="headerlink" title="VGA接口"></a>VGA接口</h2><p>是Video Graphics Array的缩写，即视频图形阵列，具有分辨率高、显示速率快、颜色丰富等优点。VGA接口不但是CRT显示设备的标准接口，同样也是LCD液晶显示设备的标准接口，具有广泛的应用范围。目前台式机的视频接口多是VGA接口。<br>PCB-layout规则：<br>a. 布局：一字形或L形；<br>b. R、G 、B、Hsync和Vsync需要加粗 15mil，做包地处理，隔离层走线。阻抗为75Ω。<br>c. TVS管在布局时，要尽量靠近连接器侧。<br>d. 其余信号阻抗为50Ω。<br>e. VGA_RED、VGA_GRN、VGA_BLU、VGA_HSYNC、VGA_VSYNC为模拟信号，这些模拟信号的地为VGAGND，在地层上要分割出这种地。数字信号和模拟信号要各自布在自己的‘地’的上。布线时把这模拟信号布在TOP层最好，每条信号线用两条各自相应的地线平行夹裹跟随。在这模拟地的上下各信号层不允许布数字信号线。当然上述模拟信号线也不要在数字地上各信号层走线。</p><h2 id="SATA接口"><a href="#SATA接口" class="headerlink" title="SATA接口"></a>SATA接口</h2><p>是Serial ATA的缩写，即串行ATA。它是一种电脑总线，主要功能是用作主板和大量存储设备（如硬盘及光盘驱动器）之间的数据传输。这是一种完全不同于并行PATA的新型硬盘接口类型，由于采用串行方式传输数据而得名。串行接口还具有结构简单、支持热插拔的优点。<br>PCB-layout规则：<br>a. 走线时尽量不打过孔； 最大过孔数为2个，换参考层处150mil内增加连接不同参考层过孔，每个信号对要求一个过孔。<br>b. 注意差分线控制特性阻抗：90Ω；<br>c. 走线时注意邻近地平面走线，不许跨切割，除测点外尽量不要有via,且不可有stub，同时注意立体包地处理。<br>d. Differential pair信号上的耦合电容需放置到SATA conector端且对称放置。<br>e. ESD防护器件紧挨接口放置，后端放置差分线匹配电容。<br>f. 信号长度，要求主板信号长度与底板信号长度之和不超过4inch。</p><h2 id="AUDIO接口"><a href="#AUDIO接口" class="headerlink" title="AUDIO接口"></a>AUDIO接口</h2><p>音频接口,可将计算机、录像机等的音频信号输入进来，通过自带扬声器播放。还可以通过音频输出接口，连接功放、外接喇叭。<br>PCB-layout规则：<br>1.信号线阻抗：65Ω；<br>2.左、右声道（HPL HPR）走线长度≥12mil；<br>3.模拟信号要进行包地处理；<br>4.AGND需铺到插座，同时电源拉最小30mil宽；<br>5.TVS管要尽量靠近端口放置，磁珠要放在TVS管后端。</p><h2 id="RS232接口"><a href="#RS232接口" class="headerlink" title="RS232接口"></a>RS232接口</h2><p>RS232接口简称串口，也称串行通信接口或串行通讯接口（通常指COM接口），是采用串行通信方式的扩展接口。串行接口 （Serial Interface）是指数据一位一位地顺序传送。其特点是通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，但传送速度较慢，且传输距离有限。<br>PCB-layout规则：<br>a. TXD、RXD尽量不要同层平行走线，如果一定要同层，要求间距至少5W以上;<br>b. 输入输出之间不要交叉在一起，用地隔开;<br>c. TVS管紧挨接口放置，之后紧接着放置电容位置，最后面放磁珠，用于滤波。</p><h2 id="HDMI接口"><a href="#HDMI接口" class="headerlink" title="HDMI接口"></a>HDMI接口</h2><p>是High Definition Multimedia Interface的简称，即高清多媒体接口。是一种全数字化视频和声音发送接口，可以发送未压缩的音频及视频信号。HDMI可用于机顶盒、DVD播放机、个人计算机、电视、游戏主机、综合扩大机、数字音响与电视机等设备。HDMI可以同时发送音频和视频信号，由于音频和视频信号采用同一条线材，大大简化系统线路的安装难度。<br>PCB-layout规则：<br>a.差分线阻抗是100Ω；<br>b.ESD器件一定要靠近HDMI端子放置；<br>c.信号线的TVS管要并排放置，不可以一前一后。<br>d.四对差分线之间的间距要保证在15mil以上；<br>e.临近GND层走线。</p><h2 id="DVI接口"><a href="#DVI接口" class="headerlink" title="DVI接口"></a>DVI接口</h2><p>是Digital Visual Interface的简称，即数字视频接口。DVI是基于TMDS(Transition Minimized Differential Signaling，转换最小差分信号)技术来传输数字信号。TMDS运用先进的编码算法把8bit数据(R、G、B中的每路基色信号)通过最小转换编码为10bit数据(包含行场同步信息、时钟信息、数据DE、纠错等)，经过DC平衡后，采用差分信号传输数据，它和LVDS、TTL相比有较好的电磁兼容性能，可以用低成本的专用电缆实现长距离、高质量的数字信号传输。数字视频接口（DVI）是一种国际开放的接口标准，在PC、DVD、高清晰电视（HDTV）、高清晰投影仪等设备上有广泛的应用。<br>PCB-layout规则：<br>1.信号换层时请在距离过孔50mil内增加回流地过孔；<br>2.信号长度最长不超过8000mil；<br>3.每个信号走线不能超过两个过孔；<br>4.信号必须要参考GND层，差分对之间的间距要≥15mil。</p><h2 id="LVDS接口"><a href="#LVDS接口" class="headerlink" title="LVDS接口"></a>LVDS接口</h2><p>是Low Voltage Differential Signaling的简称，即低电压差分信号，又称RS-644总线接口，是20世纪90年代才提出的一种数据传输和接口技术。是一种低摆幅的差分信号技术，它使得信号能在差分PCB线对或平衡电缆上以几百Mbps的速率传输，其低压幅和低电流驱动输出实现了低噪声和低功耗。<br>PCB-layout规则：<br>a. LVDS 输出差分信号走线阻抗 100Ω，走线尽可能等长；<br>b. 100Ω终端电阻尽量靠近LVDS接收器放置，差分信号走线时尽量少用通孔；<br>c. LVDS各输出差分信号通道间隔至少大于2倍S1（一对差分信号正负通道间隔为S1）。</p><h2 id="CAN接口"><a href="#CAN接口" class="headerlink" title="CAN接口"></a>CAN接口</h2><p>是Controller Area Network的简称，即控制器局域网络。CAN 的高性能和可靠性已被认同，并被广泛地应用于工业自动化、船舶、医疗设备、工业设备等方面。现场总线是当今自动化领域技术发展的热点之一，被誉为自动化领域的计算机局域网。它的出现为分布式控制系统实现各节点之间实时、可靠的数据通信提供了强有力的技术支持。<br>PCB-layout规则：<br>1.差分信号线走线等长；<br>2.信号特性阻抗为100Ω；<br>3.CAN总线一般采用“手牵手”式连接、“T”型连接、星型拓扑结构。</p><h2 id="IDE接口"><a href="#IDE接口" class="headerlink" title="IDE接口"></a>IDE接口</h2><p>是Integrated Drive Electronics的缩写，即电子集成驱动器，是把“硬盘控制器”与“盘体”集成在一起的硬盘驱动器。把盘体与控制器集成在一起减少硬盘接口的电缆数目与长度，数据传输的可靠性得到增强，硬盘制造起来变得更容易的技术。但是由于其数据传输速度慢、线缆长度过短、连接设备少以及传输总线数量多等缺点，使得IDE接口已逐渐被淘汰，目前渐渐已被SATA接口代替。<br>PCB-layout规则：<br>a.信号线阻抗特性为50Ω；<br>b. 信号线保持等长走线；<br>c.信号线线宽4mil，间距8mil，同时VIA控制在两个以内，不能跨切割面；<br>d.防护器件TVS管紧贴接口放置。</p><h2 id="网口"><a href="#网口" class="headerlink" title="网口"></a>网口</h2><p>网口可作为两种功能，分为管理网口和以太网网口。对于管理网口而来，可对板卡设备进行在线加载软件大包；对于以太网网口，在其MAC层LINK UP后也可进行在线加载软件大包，同时也可进行数据的传输与交换，速率更快，稳定性好。<br>PCB-layout规则：<br>a. 外壳地与DGND之间的桥接电容要靠近外壳地管脚放置。<br>b. TX+、TX-和RX+、RX-两组差分对之间的间距要≥4W。<br>c. 网络差分特性阻抗为100欧姆。<br>d. 尽量做到差分对之间等长。<br>e. 变压器底部的内层电源/地平面需要挖空，且尽量不要走信号线；<br>f. 换参考层处150mil内增加连接不同参考层过孔，每个信号对要求一个过孔。</p><h2 id="PS-2接口"><a href="#PS-2接口" class="headerlink" title="PS/2接口"></a>PS/2接口</h2><p>PS/2是一种鼠标和键盘的专用接口，是一种6针的圆型接口，但键盘只使用其中的4针传输数据和供电，其余2个为空脚。PS/2接口的传输速率比COM接口稍快一些，而且是ATX主板的标准接口，是应用最为广泛的键盘接口之一。鼠标是浅绿色接口，键盘是紫色接口，这两个接口不能混插，否则会使其不工作。<br>PCB-layout规则：<br>a.因为速率一般为15KHZ，没有太严苛的走线要求；<br>b.需注意MS_CLK/DATA和KB_CLK/DATA两组线各自平行走线。</p><p><del>6can2 1can1 裁判系统串口</del></p><p>通常走100hm阻抗<br>隔层参考不需要包地<br>实在不行3W<br>走线尽量远离差分线<br>差分线下的平面尽量完整，否则阻抗不连续会形成干扰。</p><p>同层参考的是同一层的GND，且信号需要包地，线宽要比信号线宽，要打地过孔，成对打。（回流路径最小）<br>必须靠近焊盘<br>过孔和地线一样宽<br>eg：6mil信号线，包地的地线至少7mil<br>阻抗表示方式<br>G/5/6.1/5/6.1/5/G<br>G 地线<br>5  线距<br>6.1 线宽<br>过孔<br>0.4mm<em>0.6mm 走600mA<br>0.3</em>0.5 走300mA</p><p>BGA 0.2*0.4 只能在BGA用，之后全部换成大的<br>最多只能出现两种过孔，最好都用一种</p><p>PCB设计规范 查板单<br>40mil走1A<br>上下拉电阻不能低于8mil</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32H74x(75x)硬件设计规则</title>
      <link href="/2023/07/25/dian-zi-dian-li/stm32h74x-75x-ying-jian-she-ji-gui-ze/"/>
      <url>/2023/07/25/dian-zi-dian-li/stm32h74x-75x-ying-jian-she-ji-gui-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="供电部分"><a href="#供电部分" class="headerlink" title="供电部分"></a>供电部分</h1><p>MCU需要1.71~3.6V的工作电压，主$V_{DD}$断电时，由$V_{BAT}$电压（1.2~3.6V）供电<br>$V_{BAT}$：1.2~3.6 V：当$V_{DD}$不存在时，为 RTC、外部 32 kHz 振荡器和备份寄存器（通过电源开关）供电。<br>$V_{DD}$:I/O引脚和系统模拟部分供电，比如复位、电源管理、振荡器等<br>$V_{DDA}$:用于ADC、DAC、运放、比较器和电压基准供电，这部分供电是独立的。<br>$V_{REF}$:用于模拟外设（ADC/DAC）的外部基准电压。<br>$V_{REF}$可连接至$V_{DDA}$。 如果有单独的外部<br>参考电压施加到$V_{REF}$，必须连接一个100nF和一个1uF的电容。<br>在所有情况下，$V_{REF}$ 必须保持低于$V_{DDA}$。<br>当$V_{DDA}$ 高于 2 V 并且使用 ADC 时，$V_{REF}$下限为 2 V，否则为 1.62 V。<br>$V_{DD33USB}$和$V_{DD50USB}$:USB收发器的外部电源。<br>当使用$V_{DD50USB}$供电时，该引脚必须连接到 USB的VBUS 上并外加一个4.7 μF 去耦电容(CIN)。<br>此外、$V_{DD33USB}$ 必须连接到一个 1 μF 的电容，其最大 ESR 应为 600 mΩ。<br>当 $V_{DD33USB}$ 用于为 USB 收发器供电（3.0 至 3.6 V）时，如果$V_{DD50USB}$引脚可用，则必须将$V_{DD33USB}$连接到 $V_{DD50USB}$引脚。<br>如果$V_{DD50USB}$引脚可用，则必须连接到$V_{DD33USB}$，而$V_{DD33USB}$必须连接两个外部去耦电容。必须连接到两个外部去耦电容（一个 100 nF 陶瓷电容和一个1 μF 钽或陶瓷电容）。<br>$V_{DDLDO}$:1.62 至 3.6 V,稳压器的外部电源</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟电子技术</title>
      <link href="/2023/07/13/dian-zi-dian-li/mo-ni-dian-lu/mo-ni-dian-zi-ji-zhu/"/>
      <url>/2023/07/13/dian-zi-dian-li/mo-ni-dian-lu/mo-ni-dian-zi-ji-zhu/</url>
      
        <content type="html"><![CDATA[<p>参考书籍：</p><ol><li>模拟电子技术 第2版：电子工业出版社 (美)Robert L.Boylestad,(美)Louis Nashelsky著</li><li>模拟电子技术基础（第四版）</li><li>新概念模拟电路 杨建国著<h1 id="半导体二极管"><a href="#半导体二极管" class="headerlink" title="半导体二极管"></a>半导体二极管</h1><h2 id="半导体基本知识"><a href="#半导体基本知识" class="headerlink" title="半导体基本知识"></a>半导体基本知识</h2><h3 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h3>纯净的，具有晶体结构的半导体成为本征半导体。<h3 id="本征载流子"><a href="#本征载流子" class="headerlink" title="本征载流子"></a>本征载流子</h3>仅由于外部原因引起材料中的自由电子称为本征载流子<h3 id="掺杂半导体"><a href="#掺杂半导体" class="headerlink" title="掺杂半导体"></a>掺杂半导体</h3>半导体材料可以通过在相对纯净的半导体材料中添加特定的杂质原子来改变其特性，即使只添加千万分之一的杂质。<h4 id="N型半导体（电子型半导体）"><a href="#N型半导体（电子型半导体）" class="headerlink" title="N型半导体（电子型半导体）"></a>N型半导体（电子型半导体）</h4>N型半导体是向硅（锗）晶体内掺入五价元素杂质（P/Sb）而形成的。<br>以磷原子为例，其有五个价电子，与硅原子形成四个共价键后还会多出一个电子，这个剩余的电子与其所属原子间的联系相对松散，只需要外界给予较少的能量就能成为自由电子从而在新构成的N型材料内自由运动。<br>由于磷原子与硅原子在形成4个共价键后还能给出一个电子，故称磷原子为施主原子，磷成为施主杂质或N型杂质，<del>其中N的意义为Negative。</del><br>明显自由电子为多数载流子，空穴为少数载流子。<h4 id="P型半导体（空穴型半导体）"><a href="#P型半导体（空穴型半导体）" class="headerlink" title="P型半导体（空穴型半导体）"></a>P型半导体（空穴型半导体）</h4>也是向硅晶体内掺杂，但是掺入三价元素（B/Ga）。<br>以镓原子为例，其与硅原子形成三个共价键，但是硅原子还剩余一个未成键的自由电子，因此在晶体中形成了空穴，当其相邻共价键上的电子吸收外来能量激发时，就有可能填补上这个空穴，从而在外加电场的作用下形成空穴电流。<br>由于镓原子和硅原子形成三个共价键后，硅原子并没有形成8电子稳定构型，而是形成了空穴，需要从杂质原子的空位中吸收电子，故称镓原子为受主原子。<br>明显空穴为多数载流子，自由电子为少数载流子。<h2 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h2></li></ol><h3 id="偏置电压"><a href="#偏置电压" class="headerlink" title="偏置电压"></a>偏置电压</h3><blockquote><p>偏置是指为得到一定的响应而在设备两端所加的电压，对于二极管而言，偏置电压的正负与其极性相同。</p></blockquote><h3 id="无偏置"><a href="#无偏置" class="headerlink" title="无偏置"></a>无偏置</h3><p>在<strong>无外加电场的情况下</strong>，当N型半导体和P型半导体结合在一起时，由于两种材料的载流子分布数量恰好相反，因此空穴与自由电子会向对方的区域扩散并结合，使得原来P区和N区的电中性被破坏，在交界面附近形成了一个很薄的空间电荷区，或者说形成了一个<strong>内部电场</strong>（并非由外加电压形成的），也叫内联电场。虽然这些离子也带电，但是由于物质结构的原因，它们并不能自由移动，因此他们不导电，因此空间电荷区的电阻率很高<br>在这个区域内，由于多数载流子已经扩散到对方的区域并复合掉，因此此区域也成为<strong>耗尽层</strong>，其实也就形成了一个二极管<br>对于内联电场，P区内电子被夺走显正电性，N区内空穴被中和显负电性，明显它对多数载流子的扩散有阻止作用，阻止作用是两方面的，对于N区域来说，首先要克服耗尽层正离子层的引力，其次还要克服负离子层的阻力，才能够到达P区，因此，此时耗尽层也可看为是一个阻挡层，但是其对少数载流子有加强作用，少数载流子会向对方所在的区域漂移，与扩散作用的运动方向恰好相反。并且参与扩散的多子数目等于参与漂移的少子的数目，从而达到动态平衡，空间电荷区不再发生变化，于是形成了稳定的PN结，对于P区与N区杂质浓度相同时，正负离子区的宽度也相同，称为<strong>对称结</strong>，<br>当两侧杂质浓度不同时，浓度高一侧的离子区宽度低于浓度低的离子区宽度，此时称为<strong>不对称PN结</strong>；但是两种结的外部特性都是相同的，即在<strong><em>半导体二极管两端不施加偏置电压时，在单一方向上的电流为零</em></strong></p><h3 id="反向偏置"><a href="#反向偏置" class="headerlink" title="反向偏置"></a>反向偏置</h3><p><img src="https://pica.zhimg.com/80/v2-b269a241d8f30d69e3799e4c7dd2d53a_1440w.png" alt=""><br>当将电压反向加在PN结上（正极接N，负极接P）时，P型半导体中的空穴和N型半导体中的电子被外加电压吸引，使得P型半导体中的负离子和N型半导体中的正离子急剧增多，导致耗尽层加宽，加宽到了多子无法通过耗尽层，如上图所示。<br>但是，外加电场并未影响到少子，少子进入耗尽层的数量仍然不变，与无偏置情况下的数量相同。<br>反向饱和电流用$I_{S}$表示。</p><h3 id="正向偏置"><a href="#正向偏置" class="headerlink" title="正向偏置"></a>正向偏置</h3><p>当讲电压正向加在PN结(正极接P，负极接N)上时，外加电压将会吸引P型半导体的阴离子和N型半导体的阳离子，使得耗尽层变窄。随着外加电压的变大，耗尽层变得更窄，更多的多子可以通过PN结，这将导致电流呈指数级增长。</p><p><del>对于少子而言，耗尽层宽度的下降使得P型半导体中的电子和N型半导体中的空穴流进对方的区域</del></p><h2 id="二极管的一般特性"><a href="#二极管的一般特性" class="headerlink" title="二极管的一般特性"></a>二极管的一般特性</h2><p><img src="https://pic1.zhimg.com/80/v2-609b053bed915f3b0805b2dd6c26ab94_1440w.png" alt=""></p><h3 id="一般特性"><a href="#一般特性" class="headerlink" title="一般特性"></a>一般特性</h3><p>我们使用<strong>肖克利方程</strong>来描述半导体二极管的一般特性</p><script type="math/tex; mode=display">I_{D}=I_{S}(e^{\frac{U_D}{nU_T}}-1)</script><p>其中，$I_D$是通过二极管的电流,$I_{S}$是反向饱和电流，$U_{D}$是加在二极管上的正偏电压，$n$是影响因子，范围在1~2之间，但除非特殊说明，否则都按1处理。<br>我们定义$U_{T}$是热电压，由下式决定</p><script type="math/tex; mode=display">U_{T}=\frac{kT}{q}</script><p>其中，$k$是玻尔兹曼常数，为$1.38 \times 10^{-23}J/K$，T是热力学温度，q是电子的电荷量，为$1.6\times 10^{-19}C$。<br>整理得$$<br>I_D=I_S\,e^{\frac{qU_D}{kT}}-I_S</p><script type="math/tex; mode=display">对其分析，明显得：1. $U_D<0$时,当$U_D$趋于负无穷时，$e^{\frac{qU_D}{kT}}$趋于零，此时$I_D$几乎等于$-I_S$，在图中对应反向偏置区域。2. $U_D>0$时，式中的指数部分将快速增长并超过第二部分，图中曲线随者电压的增大而趋向于垂直。但是，在实际的元件中，**反向饱和电流通常会比肖克利方程中的$I_S$大得多**，这是因为一些没有包含在肖克利方程中的因素引起的，譬如耗尽区载流子的产生以及表面漏电流。此外，pn结的接触面积与反向饱和电流的大小有着直接的对应关系。### 齐纳区域![](https://picx.zhimg.com/80/v2-467233537e8ecd41e1923e463311c2e2_1440w.png)# 双极性晶体管（Bipolar Junction Transistor）![](https://picx.zhimg.com/80/v2-1a992cb541f3ea58c8c348f321e70058_1440w.png)三极管其电路符号如图所示，一共有三个引脚，分别为基极（Base），集电极（Collector）和发射极（Emitter）。注意，带箭头的引脚即为发射极，箭头向外的为NPN型，相反即为PNP型。图示右侧给出了等效电路关系，其本质上是一个$CCCS$，对于NPN管，若发射极电流是流出的，则基极和集电极电流是流入的，PNP则相反对于NPN管，我们定义***发射结电压***为其基极电压与发射级电压之差，即</script><p>u_{BE}=u_B-u_E</p><script type="math/tex; mode=display">此值为正时才能使基极与发射级时导通关系。根据图中给出的等效电路关系，由基尔霍夫定律与受控源规律，我们有：</script><p>\begin{equation}\begin{split}<br>i_B+i_C=&amp;i_E   \\<br>i_C=&amp; \beta i_B<br>\end{split}\end{equation}</p><script type="math/tex; mode=display">其中，$\beta$是电流放大倍数。## 伏安特性曲线### 输入伏安特性BJT的输入伏安特性是指其基极电流$i_B$与发射结电压$u_{BE}$的关系，其可能受到$u_{CE}$的影响![](https://pica.zhimg.com/80/v2-724d9c1d99a20894a799bc19797f0b42_1440w.png)![](https://pica.zhimg.com/80/v2-ae48e0a58305fa6987defe57d5f99148_1440w.png)如图所示，除$u_{CE}=$比较特殊外，其余曲线基本重合——称为一簇线，即为晶体管的输入伏安特性，可使用如下表达式近似表述：</script><p>i_B=I_S(e^{\frac{u_{BE}}{U_T}}-1)</p><script type="math/tex; mode=display">其中，$u_T$是热电压，是一个与绝对温度成比值的值，27℃时约为26$mV$,$I_S$是反向饱和电流，虽然每个晶体管的值都不同，但很小，当$u_{BE} \rightarrow +\infty$时，明显$i_B \rightarrow -I_S$。一般的，当$u_{BE}>0.7V$时，基极开始出现较为明显的电流。### 输出伏安特性输出伏安特性是指在一个确定的基极电流下，集电极电流$i_C$与$u_{CE}$的关系。![](https://pic1.zhimg.com/80/v2-858061a0b491dd926f14912dbeb8c9c6_1440w.png)在理想情况下，集电极电流应该只与基极电流成正比，但是现实情况是：![](https://pic1.zhimg.com/80/v2-734d2112d269eb29211b29e5a1aa3958_1440w.png)#### 输出区域划分1. 放大区在放大区中，图中曲线为微微上翘的平直曲线，在此区域内，集电极电流几乎不受$u_{CE}$控制，近似满足下式：</script><p>i_C=\beta i_B</p><p>$$</p><ol><li>饱和区<br>图中的左侧区域，在此区域内，集电极电流随着$u_{CE}$的增大而增大。<br>我们定义$U_{CES}$为晶体管的饱和压降，是饱和区和放大区的分界电压，一般认为约为0.3V，但显然，随着$i_B$的上升，饱和压降也会上升</li><li>截止区<br>当基极电流为零时，集电极电流并不为零，而是存在与$u_{CE}$相关的漏电流。我们定义$I_B=0$时的区域为截止区，其含义为晶体管处于几乎没有电流进出的状态，就像完全关闭一样。<h4 id="简化的输出伏安特性"><a href="#简化的输出伏安特性" class="headerlink" title="简化的输出伏安特性"></a>简化的输出伏安特性</h4>![[Pasted image 20231008223252.png]]</li></ol><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IIC</title>
      <link href="/2023/07/11/stm32/iic/"/>
      <url>/2023/07/11/stm32/iic/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>IIC（Inter-Integrated Circuit ,内部集成电路)总线是一种由飞利浦Philip公司开发的串行总线。是两条串行的总线，它由一根数据线（SDA）和一根 时钟线（SDL）组成。I2C总线上可以接多个I2C设备，每个器件都有一个唯一的地址识别。同一时间只能有一个主设备，其他为从设备。通常MCU作为主设备控制，外设作为从设备。<br>IIC通信模式为半双工通信，同一时间只能单向通信。 </p><h1 id="电路组成"><a href="#电路组成" class="headerlink" title="电路组成"></a>电路组成</h1><p>I2C总线为漏极开路结构(OD)，因此它们必须接有上拉电阻,阻值常为4.7K或者10K。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/07/09/dian-zi-dian-li/pcb/pcb-she-ji-gui-ze/"/>
      <url>/2023/07/09/dian-zi-dian-li/pcb/pcb-she-ji-gui-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么信号线要串联电阻"><a href="#为什么信号线要串联电阻" class="headerlink" title="为什么信号线要串联电阻"></a>为什么信号线要串联电阻</h2><p>按键和CPU之间串联的电阻起保护作用。按键肯定是存在机械抖动的，开发板上面的硬件没有做硬件滤波处理，即使设计了硬件滤波电路，软件上还是需要进行滤波。</p><ol><li>保护GPIO，避免软件错误将IO设置为输出，如果设置为低电还好，如果设置输出的是高电平，按键按下会直接跟GND(低电平)连接，从而损坏MCU。</li><li><p>保护电阻也起到按键隔离作用，这些GPIO可以直接用于其它实验。</p></li><li><p>电源平铺 散热</p></li><li>电源走不下 顶层+底层总宽度满足奥求就可以</li><li>外框包地打过孔[[source/_posts/控制理论/readme]]</li><li>ME 多线走线</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SuperCap</title>
      <link href="/2023/07/09/chao-ji-dian-rong/supercap/"/>
      <url>/2023/07/09/chao-ji-dian-rong/supercap/</url>
      
        <content type="html"><![CDATA[<h1 id="超级电容功率控制器"><a href="#超级电容功率控制器" class="headerlink" title="超级电容功率控制器"></a>超级电容功率控制器</h1><h2 id="双向BuckBoost原理"><a href="#双向BuckBoost原理" class="headerlink" title="双向BuckBoost原理"></a>双向BuckBoost原理</h2><p><img src="https://pic1.zhimg.com/80/v2-103cc0c450fc12c4723054bd0efafd4b_1440w.png" alt=""><br>其本质上也是Buck-Boost的基本拓补结构<br><img src="https://pic1.zhimg.com/80/v2-6687a142cd61eb44dc30ab01ffdd9e4c_1440w.png" alt=""><br>只需将图内续流二极管换成Mos管即可</p><h3 id="Buck模式"><a href="#Buck模式" class="headerlink" title="Buck模式"></a>Buck模式</h3><p>工作在Buck状态下时，Q4导通，Q3截止，Q1、Q2交替开关，也就是变成了经典Buck电路拓补结构<br><img src="https://pica.zhimg.com/80/v2-ca50fe2d1baa11937e1aa7c5e236e5e2_1440w.png" alt=""></p><h3 id="Boost模式"><a href="#Boost模式" class="headerlink" title="Boost模式"></a>Boost模式</h3><p><img src="https://picx.zhimg.com/80/v2-9b2c241093b59dcb1c6987d3ef1a4aee_1440w.png" alt=""><br>由经典Boost电路不难得出，如果想工作在Boost状态，Q1工作在满占空比状态，Q2常开，Q3、Q4交替开关</p><h3 id="BuckBoost"><a href="#BuckBoost" class="headerlink" title="BuckBoost"></a>BuckBoost</h3><p><del>四开关不就是干这个的吗</del></p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>使用超级电容与裁判系统供电并联的方案，当底盘功率小于限定功率时，电池的剩余功率走buck回路给电容组充电，当所需底盘功率高于限定功率时， 超级电容走Boost回路和裁判系统一起给底盘供电。<br>为了防止电流回灌到裁判系统中，在裁判系统电源输入端串接以理想二极管回路。</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ol><li>如何实现上管MOS工作在满占空比状态，自举升压可能不太行。</li><li>开关频率与电源效率的平衡。</li><li><del>环路带宽？</del></li><li>HRTIM和ADC采样+DMA重点学习。</li><li>元器件选型与电源效率的关系。</li><li>电机电流如果回灌回来能否进行有效利用？</li><li></li></ol><h2 id="超级电容均压板"><a href="#超级电容均压板" class="headerlink" title="超级电容均压板"></a>超级电容均压板</h2><p>计划使用主动均衡电路<br><img src="https://pic1.zhimg.com/80/v2-d973d70449df0612034c47e848c1cba2_1440w.png" alt=""><br>如图所示，SC为超级电容，其和一个小电容并联，充电电源和两列电容之间用4个MOS管隔开，充电时，左侧MOS等效为开关闭合，右侧MOS截止，先给小电容充电，随后左侧MOS截止，右侧MOS闭合，小电容给超级电容充电，如此循环往复达到超级电容的主动均压，只需给一个高频PWM即可。</p><h3 id="均压速率影响因素"><a href="#均压速率影响因素" class="headerlink" title="均压速率影响因素"></a>均压速率影响因素</h3><p>有人做过相关Matlab仿真,结果如图所示<br><img src="https://picx.zhimg.com/80/v2-10102bcb9e8165ef687dc9d29c76b7e7_1440w.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 超级电容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2023/07/09/xian-xing-dai-shu/xian-xing-dai-shu/"/>
      <url>/2023/07/09/xian-xing-dai-shu/xian-xing-dai-shu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路分析</title>
      <link href="/2023/07/09/dian-zi-dian-li/lm3150mhx/dian-lu-fen-xi/"/>
      <url>/2023/07/09/dian-zi-dian-li/lm3150mhx/dian-lu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><img src="https://pica.zhimg.com/80/v2-31edd6ee23e2deb3d1fc7208c1ea0177_1440w.png" alt=""></p><h1 id="芯片引脚分析"><a href="#芯片引脚分析" class="headerlink" title="芯片引脚分析"></a>芯片引脚分析</h1><h2 id="VCC"><a href="#VCC" class="headerlink" title="VCC"></a>VCC</h2><blockquote><p>Nominally regulated to 5.95V. Connect a 1.0 µF to 2.2 µF decoupling capacitor from this pin to ground.</p></blockquote><p>Design Guide要求串联一个容值在1.0uF和2.2uF的电容，可以看到图中C5是一个2.2uF的电容串联接地。</p><h2 id="VIN"><a href="#VIN" class="headerlink" title="VIN"></a>VIN</h2><blockquote><p>Supply pin to the device. Nominal input range is 6V to 42V.</p></blockquote><p>明显此脚接电源输入，电压范围在6V到42V。</p><h2 id="EN"><a href="#EN" class="headerlink" title="EN"></a>EN</h2><blockquote><p>To enable the IC apply a logic high signal to this pin greater than 1.26V typical or leave floating. To disable the part, ground the EN pin.</p></blockquote><p>引脚需要给一个高于1.26V的输入电压来让芯片工作，或者电压保持浮动，原理图上选择串联一个10k电阻。Electrical Characteristic里给出的电压范围是1.14V~1.26V。<br>没找到应该怎么算这个电阻的阻值<del>（<em>还是说整个值仿真一下之后发现行就怼上去了</em>）</del>，Design Guide还要求其工作在开漏状态时应串联一个1000pF的电容（推荐值）。</p><h2 id="FB（FeedBack）"><a href="#FB（FeedBack）" class="headerlink" title="FB（FeedBack）"></a>FB（FeedBack）</h2><blockquote><p>Internally connected to the regulation, over-voltage, and short-circuit comparators. The regulation setting is 0.6V at this pin. Connect to feedback resistor divider between the output and ground to set the output voltage.</p></blockquote><p>似乎此脚的输入电压应该调到0.6V，并且连接到输出和接地之间的反馈电阻用以调整输出电压。</p><h2 id="SGND"><a href="#SGND" class="headerlink" title="SGND"></a>SGND</h2><blockquote><p>Ground for all internal bias and reference circuitry. Should be connected to PGND at a single point.</p></blockquote><p>信号地，应该和PGND连一起。</p><h2 id="SS（Soft-Start）"><a href="#SS（Soft-Start）" class="headerlink" title="SS（Soft Start）"></a>SS（Soft Start）</h2><blockquote><p>An internal 7.7 µA current source charges an external capacitor to provide the soft-start function.</p></blockquote><p>此处需外接一电容，充电后提供软起动功能<br>计算公式</p><script type="math/tex; mode=display">C_{SS}=\frac{I_{SS}t_{SS}}{V_{ref}}</script><p>其中$V_{ref}=0.6V$，$I_{SS}=7.7 \mu A$，$t_{SS}$需要在开始的几秒之内测出来？(我理解是这个意思)</p><h2 id="RON"><a href="#RON" class="headerlink" title="RON"></a>RON</h2><blockquote><p>Function:An external resistor from VIN to this pin sets the high-side switch on-time.</p></blockquote><p>从VIN到该引脚的外部电阻设置高压侧开关接通时间。<br>由datasheet有以下关系</p><script type="math/tex; mode=display">D=\frac{t_{on}}{t_{on}t_{off}}=t_{on}f_s \approx \frac{V_{OUT}}{V_{IN}}</script><p>易得</p><script type="math/tex; mode=display">f_s=\frac{V_{OUT}}{K R_{on}}</script><p>其中K为常数，$K=100pC$。</p><h2 id="PGND"><a href="#PGND" class="headerlink" title="PGND"></a>PGND</h2><p>SGND里写了</p><h2 id="ILIM（Current-Limit）"><a href="#ILIM（Current-Limit）" class="headerlink" title="ILIM（Current Limit）"></a>ILIM（Current Limit）</h2><blockquote><p>Monitors current through the low-side switch and triggers current limit operation if the inductor valley current exceeds a user defined value that is set by $R_{LIM}$ and the Sense current, $I_{LIM-TH}$, sourced out of this pin during operation.</p></blockquote><p>监控通过低压侧开关的电流，如果电感器谷电流（最小电流）超过用户定义的值（由$R_{LIM}$设置），则触发电流限制操作，并且在操作过程中检测电流$I_{LIN-TH}$来自此引脚。<br>由datasheet，$R_{LIM}$可以按下方算式进行估计</p><script type="math/tex; mode=display">\begin{equation}\begin{split} &I_{CL}=I_{OCL}-\frac{\Delta I_L}{2} \\&R_{ILM}=\frac{I_{CL}R_{DS(on)_{max}}}{I_{LIM-TH}}\end{split}\end{equation}</script><p>其中$I_{OCL}$是自定义的最大输出电流，$R_{DS(on)_{max}}$是低位MOS管在预期最大MOS管温度下的电阻值，$I_{LIM-TH}$典型内部电流源为$85 \mu A$。<br>还有一个</p><script type="math/tex; mode=display">\Delta I_L=\frac{(V_{IN}-V_{OUT})t_{on}}{L}</script><h2 id="SW-Switch-Node"><a href="#SW-Switch-Node" class="headerlink" title="SW(Switch Node)"></a>SW(Switch Node)</h2><blockquote><p>Switch pin of controller and high-gate driver lower supply rail. A boost capacitor is also connected between this pin and BST pin</p></blockquote><p>SW和BST之间连接一个升压电容<br>Design Guide推荐值为0.47uF<br>此外SW向外连接了一个电感（续流？），直接输出VOUT<br><strong>这里不是很懂，但是Design Example上是这样的。</strong></p><h2 id="HG-High-Side-Gate-Drive"><a href="#HG-High-Side-Gate-Drive" class="headerlink" title="HG(High-Side Gate Drive)"></a>HG(High-Side Gate Drive)</h2><blockquote><p>Gate drive signal to the high-side NMOS switch. The high-side gate driver voltage is supplied by the differential voltage between the BST pin and SW pin.</p></blockquote><p>高位NMOS的Gate信号端，Design Example上面上下两个MOS管连在了一起，上位的D连接下位的S。（为啥..？）</p><h2 id="BST-Connection-for-Bootstrap-Capacitor"><a href="#BST-Connection-for-Bootstrap-Capacitor" class="headerlink" title="BST(Connection for Bootstrap Capacitor)"></a>BST(Connection for Bootstrap Capacitor)</h2><p>见SW</p><h2 id="LG"><a href="#LG" class="headerlink" title="LG"></a>LG</h2><blockquote><p>Gate drive signal to the low-side NMOS switch. The low-side gate driver voltage is supplied by VCC.</p></blockquote><p>低位NMOS的Gate信号端，VCC直接给低位NMOS供电。</p><h2 id="PGND-1"><a href="#PGND-1" class="headerlink" title="PGND"></a>PGND</h2><blockquote><p>Synchronous rectifier MOSFET source connection. Tie to power ground plane. Should be tied to SGND at a single point.</p></blockquote><p>和SGND连一起。</p><h1 id="电压输入与输出附近"><a href="#电压输入与输出附近" class="headerlink" title="电压输入与输出附近"></a>电压输入与输出附近</h1><p>注意到在$VIN$和$VOUT$的附近都有三四个电容，放电容的意义是起一定的缓冲作用，相当于微型UPS用以保护芯片。<br><del>我怎么觉得不止这一个作用</del><br>输出和输入端用了两个连接器（XT30PW-F和XT30UPB-F），用以连接供电线缆</p><h1 id="电压输出大小"><a href="#电压输出大小" class="headerlink" title="电压输出大小"></a>电压输出大小</h1><p>根据Design Guide有</p><script type="math/tex; mode=display">V_{OUT}=V_{FB}\frac{R_{FB1}+R_{FB2}}{R_{FB1}}</script><p>其中，$R_{FB1}$是下方的电阻，$R_{FB2}$是上方的电阻，<br>上方原理图中，$R_{FB1}$为10k，$R_{FB2}$为300k，$V_{FB}$为0.6V<br>经计算得</p><script type="math/tex; mode=display">V_{OUT}=18.6V</script>]]></content>
      
      
      <categories>
          
          <category> 电子电力 </category>
          
          <category> LM3150MHX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DC-DC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C</title>
      <link href="/2023/07/09/c/c/"/>
      <url>/2023/07/09/c/c/</url>
      
        <content type="html"><![CDATA[<h1 id="混合编译"><a href="#混合编译" class="headerlink" title="混合编译"></a>混合编译</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef __cplusplus  extern &quot;C&quot; &#123;  #endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这段代码是用于在C++代码中使用C语言的函数接口时进行编译器兼容性处理的。<br>实际上，#ifdef __cplusplus 表示如果当前编译器是C++编译器，则执行下面的语句块。extern “C” { 表示将下面的代码块用C语言的方式进行编译和链接。</p><p>这样就可以在C++代码中使用C语言的函数接口而不会出现编译错误。</p><h1 id="堆栈作用"><a href="#堆栈作用" class="headerlink" title="堆栈作用"></a>堆栈作用</h1><p>堆和栈是两种不同的内存分配方式，它们在单片机中具有不同的作用和特点：</p><ol><li><p>堆（Heap）：</p><ul><li>堆是一块动态分配的内存区域，用于存储程序运行时动态分配的数据。</li><li>堆的大小不固定，可以根据需要动态调整，通常比栈大得多。</li><li>堆的分配和释放由程序员手动控制，通常使用动态内存分配函数（如malloc()、free()）进行操作。</li><li>堆的数据可以在程序的任意位置访问，具有较长的生命周期。</li></ul></li><li><p>栈（Stack）：</p><ul><li>栈是一种自动分配和释放的内存区域，用于存储函数调用、局部变量，返回地址，函数的形参等临时数据。</li><li>栈的大小固定，由编译器或操作系统预先分配。通常比堆小，但速度更快。</li><li>栈的分配和释放由编译器自动管理，遵循“<strong>先进后出</strong>”的原则。</li><li>栈的数据只能在当前函数的作用域内访问，具有较短的生命周期。<br>对于STM32而言，堆栈在启动文件中设定<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2>此修饰符用来控制变量与函数的存储方式和可见性</li></ul></li><li>对局部变量使用static声明则此变量只会在第一次调用时初始化，之后的调用会保留上一次调用的值，并且其生命周期会延长到整个程序的运行期间而非整个函数的运行期间。</li><li>在函数外部使用static关键字声明的变量称为静态全局变量。静态全局变量的作用域仅限于声明它的源文件，其他文件无法访问。</li><li>静态函数：使用static关键字声明的函数称为静态函数。静态函数只能在声明它的源文件中使用，不能被其他文件调用。<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2>C语言中的extern关键字用于声明一个全局变量或函数，该变量或函数在其他文件中定义。它的作用是告诉编译器该变量或函数是在其他文件中定义的，需要在当前文件中使用。</li></ol><p>extern关键字可以放在变量或函数的声明前面，表示该变量或函数在其他文件中已经定义。例如：<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">extern int count; &#x2F;&#x2F; 声明一个全局变量count，在其他文件中定义extern void printMessage(); &#x2F;&#x2F; 声明一个函数printMessage()，在其他文件中定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p>通过使用extern关键字，可以将全局变量或函数的定义分散在多个文件中，提高代码的模块化和可维护性。<br>需要注意的是，extern关键字只是告诉编译器该变量或函数在其他文件中定义，具体的定义仍需在其他文件中进行。如果没有在其他文件中定义，编译器将会报错。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define HSE_VALUE ((uint32_t)8000000) \\外部高速时钟频率<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>这段代码定义了一个宏常量HSE_VALUE，其值为8000000。在单片机中，HSE_VALUE通常用于定义外部高速时钟（HSE）的频率。通过定义HSE_VALUE，可以方便地在程序中使用该值进行时钟配置和计算等操作。<br>在这个例子中，HSE_VALUE的值被定义为8000000，即外部高速时钟的频率为8MHz。在实际应用中，可以根据实际的硬件配置和需要进行适当的修改。</li></ol><p>使用宏常量的好处是可以提高代码的可读性和可维护性。通过使用HSE_VALUE宏常量，可以避免在代码中多次写入具体的数值，而只需要引用宏常量即可。这样，在需要修改外部高速时钟频率时，只需要修改一处定义即可，不需要在代码中逐个修改相关的数值，提高了代码的可维护性。</p><ol><li>(uint32_t)8000000 是一个类型转换表达式，将常量8000000转换为32位无符号整数类型（uint32_t）。在单片机编程中，类型转换常常用于将不同的数据类型进行转换，以满足特定的需求。在这个例子中，将8000000转换为uint32_t类型，可能是为了确保在计算或操作中使用32位无符号整数的正确性。<br>类型转换的目的可以是为了避免数据溢出、提高计算精度、满足特定的数据格式要求等。在使用类型转换时，需要注意数据范围是否适合目标类型，以及可能引起的数据丢失或截断等问题。</li></ol><h1 id="递归包含"><a href="#递归包含" class="headerlink" title="递归包含"></a>递归包含</h1><p>递归包含是指在头文件中包含其他头文件时，可能会出现循环依赖的情况。例如，头文件A包含头文件B，而头文件B又包含头文件A，这样就形成了递归包含。<br>递归包含可能会导致以下问题：</p><ol><li>编译错误：当头文件A包含头文件B时，编译器会先处理头文件A的内容，然后再处理头文件B的内容。如果头文件B中又包含了头文件A，就会产生循环依赖，编译器无法解析这种情况，导致编译错误。</li><li>重复定义：如果递归包含导致某个符号在多个头文件中被定义多次，就会导致重复定义的错误。这会导致链接错误，使得程序无法正常编译和运行。<br>可以采取以下几种解决方法以避免递归包含：</li><li>使用前置声明：如果只需要使用某个类型的指针或引用，可以使用前置声明来替代头文件的包含。这样可以避免直接包含头文件，减少循环依赖的可能性。</li><li>使用头文件保护宏：在每个头文件的开头和结尾使用头文件保护宏，可以防止同一个头文件被重复包含。这样可以避免递归包含和重复定义的问题。<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1>C语言中的断言（assertion）是一种用于在程序中检查条件是否满足的机制。它可以帮助程序员在开发过程中发现和诊断错误，并提供一种简单的调试工具。</li></ol><p>断言的基本用法是在代码中插入一个条件判断，如果条件为假（即false），则会触发断言失败，并输出相关的错误信息。断言的目的是在程序运行时快速定位错误，并提供有关错误信息的提示，以便于调试和修复问题。</p><p>在C语言中，可以使用 <code>&lt;assert.h&gt;</code> 头文件中的 <code>assert()</code> 宏来实现断言功能。<code>assert()</code> 宏接受一个条件表达式作为参数，如果条件为假，则会触发断言失败，打印出错信息，并终止程序的执行。</p><p>以下是一个简单的示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;assert.h&gt;int main() &#123;    int x &#x3D; 5;    assert(x &#x3D;&#x3D; 10);  &#x2F;&#x2F; 断言条件 x &#x3D;&#x3D; 10    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述示例中，断言条件 <code>x == 10</code> 显然是不满足的，因此运行程序时会触发断言失败，输出类似以下的错误信息：</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">Assertion failed: x &#x3D;&#x3D; 10, file example.c, line 6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过断言，我们可以在程序中插入一些条件检查，帮助我们在开发过程中发现和解决问题。但需要注意的是，断言通常用于调试阶段，而在生产环境中，可以通过定义 <code>NDEBUG</code> 宏来禁用断言，以提高程序的性能和效率。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>0x00000002U 是一个十六进制的无符号整数常量，表示十进制的2。</p><p>解析这个数据时，按照以下步骤进行：</p><ol><li>“0x” 表示这是一个十六进制数。</li><li>“00000002” 是十六进制数的具体数值部分。</li><li>“U” 表示这是一个无符号整数。(unsigned int)</li></ol><p>将十六进制数”00000002” 转换为十进制数，结果为2。由于数据类型被指定为无符号整数，因此该数值为正数。</p><h1 id="杂记-1"><a href="#杂记-1" class="headerlink" title="杂记"></a>杂记</h1><ol><li><pre class="line-numbers language-C" data-language="C"><code class="language-C">volatile const init_fn_t *fn_ptr;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>volatile: 这个关键字用来告诉编译器，这个变量的值可能会在程序控制之外的情况下改变，比如由于硬件的变动或者并行执行的线程。这意味着编译器在优化代码时不能假设这个值在两次读取之间是不变的，它必须在每次使用时直接从内存中读取它的值。</li></ol><p>const: 这个关键字表示指针指向的数据是常量，不可以被修改。注意，const 在 * 的左边，表明被指向的数据是常量，而指针本身可以修改，即可以指向不同的 init_fn_t 实例。</p><p>init_fn_t: 这通常是一个函数指针的类型定义。在C或C++中，init_fn_t 可能定义为特定类型的函数指针，用于初始化操作或其他目的。</p><p>fn_ptr: 这是变量名，指的是一个指向 init_fn_t 类型数据的指针。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定时器</title>
      <link href="/2023/07/09/stm32/ding-shi-qi/"/>
      <url>/2023/07/09/stm32/ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<p>对于STM32F4x，其有2 个高级控制定时器、10 个通用定时器和 2 个基本定时器。</p><p><img src="https://picx.zhimg.com/80/v2-4211c12913d9b34f3ba486b6409f30f1_1440w.png" alt="" title="STM32定时器汇总"></p><p><img src="https://picx.zhimg.com/80/v2-5f07297b26daffd8a1956a2bc9731a01_1440w.png" alt="STM32定时器特性"></p><p><img src="https://picx.zhimg.com/80/v2-f95d0963cfb4d534a8f6689cfbbd3a96_1440w.png" alt="STM32F1系统结构图"></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="CNT"><a href="#CNT" class="headerlink" title="CNT"></a>CNT</h3><p>计数器寄存器内的计数值</p><h3 id="ARR"><a href="#ARR" class="headerlink" title="ARR"></a>ARR</h3><p>重装载值</p><h3 id="Counter-Mode"><a href="#Counter-Mode" class="headerlink" title="Counter Mode"></a>Counter Mode</h3><p>计数模式<br>一共有五种计数模式</p><ol><li>Up</li><li>Down</li><li>Center Aligned Mode（1/2/3）<br>PSC 预分频系数<br>Auto-reload Preload 自动重装载<br>internal Clock Division(CKD) 内部时钟分频因子<h1 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h1>对于计数器的计数频率，我们有<script type="math/tex; mode=display">f_{timer}=\frac{T_{clk}}{PSC}</script>因此实际我们所需的定时周期在计数频率确定之后，只需更改ARR即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HAL笔记</title>
      <link href="/2023/07/09/stm32/hal-bi-ji/"/>
      <url>/2023/07/09/stm32/hal-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>以下所有笔记均基于安富莱V6板</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>为防止递归包含使用如下宏定义进行头文件保护<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __STM32F4xx_HAL_CONF_H #define __STM32F4xx_HAL_CONF_H&#x2F;&#x2F; 在这里定义你的配置#endif &#x2F;* __STM32F4xx_HAL_CONF_H *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>递归包含是指在头文件中包含其他头文件时，可能会出现循环依赖的情况。例如，头文件A包含头文件B，而头文件B又包含头文件A，这样就形成了递归包含。<br>递归包含可能会导致以下问题：</p><ol><li>编译错误：当头文件A包含头文件B时，编译器会先处理头文件A的内容，然后再处理头文件B的内容。如果头文件B中又包含了头文件A，就会产生循环依赖，编译器无法解析这种情况，导致编译错误。</li><li>重复定义：如果递归包含导致某个符号在多个头文件中被定义多次，就会导致重复定义的错误。这会导致链接错误，使得程序无法正常编译和运行。</li></ol></blockquote><p>在配置文件中对于HAL库模块的启用使用了宏定义，如：<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* ########################## Module Selection ############################## *&#x2F;  &#x2F;**  * @brief This is the list of modules to be used in the HAL driver  *&#x2F;  #define HAL_MODULE_ENABLED    &#x2F;* #define HAL_CRYP_MODULE_ENABLED *&#x2F;  #define HAL_ADC_MODULE_ENABLED  #define HAL_CAN_MODULE_ENABLED  &#x2F;* #define HAL_CRC_MODULE_ENABLED *&#x2F;  &#x2F;* #define HAL_CAN_LEGACY_MODULE_ENABLED *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>注释掉的即为未启用的模块，在配置文件的后面，如果你启用了该模块，那么会包含相对应的头文件<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef HAL_RCC_MODULE_ENABLED  #include &quot;stm32f4xx_hal_rcc.h&quot;  #endif &#x2F;* HAL_RCC_MODULE_ENABLED *&#x2F;    #ifdef HAL_GPIO_MODULE_ENABLED  #include &quot;stm32f4xx_hal_gpio.h&quot;  #endif &#x2F;* HAL_GPIO_MODULE_ENABLED *&#x2F;    #ifdef HAL_EXTI_MODULE_ENABLED  #include &quot;stm32f4xx_hal_exti.h&quot;  #endif &#x2F;* HAL_EXTI_MODULE_ENABLED *&#x2F;    #ifdef HAL_DMA_MODULE_ENABLED  #include &quot;stm32f4xx_hal_dma.h&quot;  #endif &#x2F;* HAL_DMA_MODULE_ENABLED *&#x2F;    #ifdef HAL_CORTEX_MODULE_ENABLED  #include &quot;stm32f4xx_hal_cortex.h&quot;  #endif &#x2F;* HAL_CORTEX_MODULE_ENABLED *&#x2F;    #ifdef HAL_ADC_MODULE_ENABLED  #include &quot;stm32f4xx_hal_adc.h&quot;  #endif &#x2F;* HAL_ADC_MODULE_ENABLED *&#x2F;    #ifdef HAL_CAN_MODULE_ENABLED  #include &quot;stm32f4xx_hal_can.h&quot;  #endif &#x2F;* HAL_CAN_MODULE_ENABLED *&#x2F;    #ifdef HAL_CAN_LEGACY_MODULE_ENABLED  #include &quot;stm32f4xx_hal_can_legacy.h&quot;  #endif &#x2F;* HAL_CAN_LEGACY_MODULE_ENABLED *&#x2F;    #ifdef HAL_CRC_MODULE_ENABLED  #include &quot;stm32f4xx_hal_crc.h&quot;  #endif &#x2F;* HAL_CRC_MODULE_ENABLED *&#x2F;    #ifdef HAL_CRYP_MODULE_ENABLED  #include &quot;stm32f4xx_hal_cryp.h&quot;  #endif &#x2F;* HAL_CRYP_MODULE_ENABLED *&#x2F;    #ifdef HAL_DMA2D_MODULE_ENABLED  #include &quot;stm32f4xx_hal_dma2d.h&quot;  #endif &#x2F;* HAL_DMA2D_MODULE_ENABLED *&#x2F;    #ifdef HAL_DAC_MODULE_ENABLED  #include &quot;stm32f4xx_hal_dac.h&quot;  #endif &#x2F;* HAL_DAC_MODULE_ENABLED *&#x2F;  ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>在配置文件中包含了对晶振频率的设定，需和外界保持一致。<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* ########################## HSE&#x2F;HSI Values adaptation ##################### *&#x2F;  &#x2F;**  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.  * This value is used by the RCC HAL module to compute the system frequency  * (when HSE is used as system clock source, directly or through the PLL).  *&#x2F;  #if !defined (HSE_VALUE)  #define HSE_VALUE 25000000U &#x2F;*!&lt; Value of the External oscillator in Hz *&#x2F;  #endif &#x2F;* HSE_VALUE *&#x2F;    #if !defined (HSE_STARTUP_TIMEOUT)  #define HSE_STARTUP_TIMEOUT 100U &#x2F;*!&lt; Time out for HSE start up, in ms *&#x2F;  #endif &#x2F;* HSE_STARTUP_TIMEOUT *&#x2F;    &#x2F;**  * @brief Internal High Speed oscillator (HSI) value.  * This value is used by the RCC HAL module to compute the system frequency  * (when HSI is used as system clock source, directly or through the PLL).  *&#x2F;  #if !defined (HSI_VALUE)  #define HSI_VALUE ((uint32_t)16000000U) &#x2F;*!&lt; Value of the Internal oscillator in Hz*&#x2F;  #endif &#x2F;* HSI_VALUE *&#x2F;    &#x2F;**  * @brief Internal Low Speed oscillator (LSI) value.  *&#x2F;  #if !defined (LSI_VALUE)  #define LSI_VALUE 32000U &#x2F;*!&lt; LSI Typical Value in Hz*&#x2F;  #endif &#x2F;* LSI_VALUE *&#x2F; &#x2F;*!&lt; Value of the Internal Low Speed oscillator in Hz  The real value may vary depending on the variations  in voltage and temperature.*&#x2F;  &#x2F;**  * @brief External Low Speed oscillator (LSE) value.  *&#x2F;  #if !defined (LSE_VALUE)  #define LSE_VALUE 32768U &#x2F;*!&lt; Value of the External Low Speed oscillator in Hz *&#x2F;  #endif &#x2F;* LSE_VALUE *&#x2F;    #if !defined (LSE_STARTUP_TIMEOUT)  #define LSE_STARTUP_TIMEOUT 5000U &#x2F;*!&lt; Time out for LSE start up, in ms *&#x2F;  #endif &#x2F;* LSE_STARTUP_TIMEOUT *&#x2F;    &#x2F;**  * @brief External clock source for I2S peripheral  * This value is used by the I2S HAL module to compute the I2S clock source  * frequency, this source is inserted directly through I2S_CKIN pad.  *&#x2F;  #if !defined (EXTERNAL_CLOCK_VALUE)  #define EXTERNAL_CLOCK_VALUE 12288000U &#x2F;*!&lt; Value of the External audio frequency in Hz*&#x2F;  #endif &#x2F;* EXTERNAL_CLOCK_VALUE *&#x2F;    &#x2F;* Tip: To avoid modifying this file each time you need to use different HSE,  &#x3D;&#x3D;&#x3D; you can define the HSE value in your toolchain compiler preprocessor. *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>需要注意的是，对于启动时的超时时间（XX_STARTUP_TIMEOUT）建议改为5000（5s），防止启动失败时出问题。</p><p>以下是HAL系统配置选项<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* ########################### System Configuration ######################### *&#x2F;  &#x2F;**  * @brief This is the HAL system configuration section  *&#x2F;  #define VDD_VALUE 3300U &#x2F;*!&lt; Value of VDD in mv *&#x2F;  #define TICK_INT_PRIORITY 15U &#x2F;*!&lt; tick interrupt priority *&#x2F;  #define USE_RTOS 0U  #define PREFETCH_ENABLE 1U  #define INSTRUCTION_CACHE_ENABLE 1U  #define DATA_CACHE_ENABLE 1U<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>比较重要的是TICK_INT_PRIORITY，这个是设置滴答中断优先级的，15是最低优先级。<br>目前HAL库还不支持RTOS宏定义配置</p><p>在配置文件的最后，是关于断言功能的<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef USE_FULL_ASSERT  &#x2F;**  * @brief The assert_param macro is used for function&#39;s parameters check.  * @param expr If expr is false, it calls assert_failed function  * which reports the name of the source file and the source  * line number of the call that failed.  * If expr is true, it returns no value.  * @retval None  *&#x2F;  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))  &#x2F;* Exported functions ------------------------------------------------------- *&#x2F;  void assert_failed(uint8_t* file, uint32_t line);  #else  #define assert_param(expr) ((void)0U)  #endif &#x2F;* USE_FULL_ASSERT *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>其主要作用是用来判断函数形参是否有效。默认情况下是关闭的。<br>用一个HAL库函数举例<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  ##### IO operation functions #####  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;@endverbatim  * @&#123;  *&#x2F;    &#x2F;**  * @brief Reads the specified input port pin.  * @param GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or  * x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.  * @param GPIO_Pin specifies the port bit to read.  * This parameter can be GPIO_PIN_x where x can be (0..15).  * @retval The input port pin value.  *&#x2F;  GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)  &#123;  GPIO_PinState bitstatus;    &#x2F;* Check the parameters *&#x2F;  assert_param(IS_GPIO_PIN(GPIO_Pin));    if((GPIOx-&gt;IDR &amp; GPIO_Pin) !&#x3D; (uint32_t)GPIO_PIN_RESET)  &#123;  bitstatus &#x3D; GPIO_PIN_SET;  &#125;  else  &#123;  bitstatus &#x3D; GPIO_PIN_RESET;  &#125;  return bitstatus;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>对于HAL的各个API都用到了断言功能，但是即使使能了断言，仍然需要自己定义函数<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">void assert_failed(uint8_t* file, uint32_t line)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>下面给出一个参考<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*ST 库函数使用了 C 编译器的断言功能，如果定义了 USE_FULL_ASSERT ，那么所有的 ST 库函数将检查函数形参是否正确。如果不正确将调用是否正确。如果不正确将调用 assert_failed() assert_failed() 函数函数，这个函数是一个死循环，便于用户检查代码。LINE__ 表示源代码行号。 关键字__FILE__表示源代码文件名。断言功能使能后将增大代码大小，推荐用户仅在调试时使能，在正式发布软件是禁止。断言功能使能后将增大代码大小，推荐用户仅在调试时使能，在正式发布软件是禁止。 用户可以选择是否使能用户可以选择是否使能STST固件库的断言供能。使能断言的方法有两种：固件库的断言供能。使能断言的方法有两种：(1) 在在CC编译器的预定义宏选项中定义编译器的预定义宏选项中定义USE_FULL_ASSERTUSE_FULL_ASSERT。。 (2) 在本文件取消在本文件取消&quot;#define USE_FULL_ASSERT 1&quot;&quot;#define USE_FULL_ASSERT 1&quot;行的注释。 *&#x2F;void assert_failed(uint8_t* file, uint32_t line)&#123; &#x2F;* 用户可以添加自己的代码报告源代码文件名和代码行号，比如将错误文件和行号打印到串口printf(&quot;Wrong parameters value: file %s on line %d\\rr\\n&quot;, file, line) *&#x2F;&#x2F;* 这是一个死循环，断言失败时程序会在此处死机，以便于用户查错这是一个死循环，断言失败时程序会在此处死机，以便于用户查错 *&#x2F;while (1) &#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="gpio-h-c"><a href="#gpio-h-c" class="headerlink" title="gpio.h/.c"></a>gpio.h/.c</h2><p>似乎这里只有一个函数“ void MX_GPIO_Init()”<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;** Configure pins as  * Analog  * Input  * Output  * EVENT_OUT  * EXTI  * Free pins are configured automatically as Analog (this feature is enabled through  * the Code Generation settings)  *&#x2F;  void MX_GPIO_Init(void)  &#123;    GPIO_InitTypeDef GPIO_InitStruct &#x3D; &#123;0&#125;;    &#x2F;* GPIO Ports Clock Enable *&#x2F;  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOI_CLK_ENABLE();  __HAL_RCC_GPIOC_CLK_ENABLE();  __HAL_RCC_GPIOF_CLK_ENABLE();  __HAL_RCC_GPIOH_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  __HAL_RCC_GPIOJ_CLK_ENABLE();  __HAL_RCC_GPIOG_CLK_ENABLE();  __HAL_RCC_GPIOD_CLK_ENABLE();  __HAL_RCC_GPIOK_CLK_ENABLE();    &#x2F;*Configure GPIO pins : PE2 PE3 PE4 PE5  PE6 PE7 PE8 PE9  PE10 PE11 PE12 PE13  PE14 PE15 PE0 PE1 *&#x2F;  GPIO_InitStruct.Pin &#x3D; GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5  |GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9  |GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13  |GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;  GPIO_InitStruct.Mode &#x3D; GPIO_MODE_ANALOG;  GPIO_InitStruct.Pull &#x3D; GPIO_NOPULL;  HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);    &#x2F;*Configure GPIO pins : PI8 PI10 PI11 PI12  PI13 PI14 PI15 PI0  PI1 PI2 PI3 PI4  PI5 PI6 PI7 *&#x2F;  GPIO_InitStruct.Pin &#x3D; GPIO_PIN_8|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12  |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0  |GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4  |GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;  GPIO_InitStruct.Mode &#x3D; GPIO_MODE_ANALOG;  GPIO_InitStruct.Pull &#x3D; GPIO_NOPULL;  HAL_GPIO_Init(GPIOI, &amp;GPIO_InitStruct);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这里只摘取了部分代码，后面的基本都是相同的</p><blockquote><p>GPIO_InitTypeDef结构体一般用于配置GPIO引脚的初始化参数。这个结构体包含了多个成员变量，用来设置引脚的模式、速度、上拉/下拉设置等。</p></blockquote><p>在这行代码中，GPIO_InitStruct变量被初始化为0，这意味着所有的成员变量都被设置为0。这样做是为了确保在后续的代码中，如果没有特别指定某个成员变量的值，那么它们的默认值都是0。<br>随后开启GPIO的时钟并开始配置引脚，这里的每一个GPIO_PIN之前都用宏定义定义了地址，使用或位操作符将多个引脚组合在一起。<br>这里统一设置为了模拟模式和浮空状态，随后进入HAL_GPIO_INIT函数进行初始化<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;**  * @brief Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.  * @param GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or  * x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains  * the configuration information for the specified GPIO peripheral.  * @retval None  *&#x2F;  void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)  &#123;  uint32_t position;  uint32_t ioposition &#x3D; 0x00U;  uint32_t iocurrent &#x3D; 0x00U;  uint32_t temp &#x3D; 0x00U;    &#x2F;* Check the parameters *&#x2F;  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));  assert_param(IS_GPIO_PIN(GPIO_Init-&gt;Pin));  assert_param(IS_GPIO_MODE(GPIO_Init-&gt;Mode));    &#x2F;* Configure the port pins *&#x2F;  for(position &#x3D; 0U; position &lt; GPIO_NUMBER; position++)  &#123;  &#x2F;* Get the IO position *&#x2F;  ioposition &#x3D; 0x01U &lt;&lt; position;  &#x2F;* Get the current IO position *&#x2F;  iocurrent &#x3D; (uint32_t)(GPIO_Init-&gt;Pin) &amp; ioposition;    if(iocurrent &#x3D;&#x3D; ioposition)  &#123;  &#x2F;*--------------------- GPIO Mode Configuration ------------------------*&#x2F;  &#x2F;* In case of Output or Alternate function mode selection *&#x2F;  if(((GPIO_Init-&gt;Mode &amp; GPIO_MODE) &#x3D;&#x3D; MODE_OUTPUT) || \  (GPIO_Init-&gt;Mode &amp; GPIO_MODE) &#x3D;&#x3D; MODE_AF)  &#123;  &#x2F;* Check the Speed parameter *&#x2F;  assert_param(IS_GPIO_SPEED(GPIO_Init-&gt;Speed));  &#x2F;* Configure the IO Speed *&#x2F;  temp &#x3D; GPIOx-&gt;OSPEEDR;  temp &amp;&#x3D; ~(GPIO_OSPEEDER_OSPEEDR0 &lt;&lt; (position * 2U));  temp |&#x3D; (GPIO_Init-&gt;Speed &lt;&lt; (position * 2U));  GPIOx-&gt;OSPEEDR &#x3D; temp;    &#x2F;* Configure the IO Output Type *&#x2F;  temp &#x3D; GPIOx-&gt;OTYPER;  temp &amp;&#x3D; ~(GPIO_OTYPER_OT_0 &lt;&lt; position) ;  temp |&#x3D; (((GPIO_Init-&gt;Mode &amp; OUTPUT_TYPE) &gt;&gt; OUTPUT_TYPE_Pos) &lt;&lt; position);  GPIOx-&gt;OTYPER &#x3D; temp;  &#125;    if((GPIO_Init-&gt;Mode &amp; GPIO_MODE) !&#x3D; MODE_ANALOG)  &#123;  &#x2F;* Check the parameters *&#x2F;  assert_param(IS_GPIO_PULL(GPIO_Init-&gt;Pull));    &#x2F;* Activate the Pull-up or Pull down resistor for the current IO *&#x2F;  temp &#x3D; GPIOx-&gt;PUPDR;  temp &amp;&#x3D; ~(GPIO_PUPDR_PUPDR0 &lt;&lt; (position * 2U));  temp |&#x3D; ((GPIO_Init-&gt;Pull) &lt;&lt; (position * 2U));  GPIOx-&gt;PUPDR &#x3D; temp;  &#125;    &#x2F;* In case of Alternate function mode selection *&#x2F;  if((GPIO_Init-&gt;Mode &amp; GPIO_MODE) &#x3D;&#x3D; MODE_AF)  &#123;  &#x2F;* Check the Alternate function parameter *&#x2F;  assert_param(IS_GPIO_AF(GPIO_Init-&gt;Alternate));  &#x2F;* Configure Alternate function mapped with the current IO *&#x2F;  temp &#x3D; GPIOx-&gt;AFR[position &gt;&gt; 3U];  temp &amp;&#x3D; ~(0xFU &lt;&lt; ((uint32_t)(position &amp; 0x07U) * 4U)) ;  temp |&#x3D; ((uint32_t)(GPIO_Init-&gt;Alternate) &lt;&lt; (((uint32_t)position &amp; 0x07U) * 4U));  GPIOx-&gt;AFR[position &gt;&gt; 3U] &#x3D; temp;  &#125;    &#x2F;* Configure IO Direction mode (Input, Output, Alternate or Analog) *&#x2F;  temp &#x3D; GPIOx-&gt;MODER;  temp &amp;&#x3D; ~(GPIO_MODER_MODER0 &lt;&lt; (position * 2U));  temp |&#x3D; ((GPIO_Init-&gt;Mode &amp; GPIO_MODE) &lt;&lt; (position * 2U));  GPIOx-&gt;MODER &#x3D; temp;    &#x2F;*--------------------- EXTI Mode Configuration ------------------------*&#x2F;  &#x2F;* Configure the External Interrupt or event for the current IO *&#x2F;  if((GPIO_Init-&gt;Mode &amp; EXTI_MODE) !&#x3D; 0x00U)  &#123;  &#x2F;* Enable SYSCFG Clock *&#x2F;  __HAL_RCC_SYSCFG_CLK_ENABLE();    temp &#x3D; SYSCFG-&gt;EXTICR[position &gt;&gt; 2U];  temp &amp;&#x3D; ~(0x0FU &lt;&lt; (4U * (position &amp; 0x03U)));  temp |&#x3D; ((uint32_t)(GPIO_GET_INDEX(GPIOx)) &lt;&lt; (4U * (position &amp; 0x03U)));  SYSCFG-&gt;EXTICR[position &gt;&gt; 2U] &#x3D; temp;    &#x2F;* Clear Rising Falling edge configuration *&#x2F;  temp &#x3D; EXTI-&gt;RTSR;  temp &amp;&#x3D; ~((uint32_t)iocurrent);  if((GPIO_Init-&gt;Mode &amp; TRIGGER_RISING) !&#x3D; 0x00U)  &#123;  temp |&#x3D; iocurrent;  &#125;  EXTI-&gt;RTSR &#x3D; temp;    temp &#x3D; EXTI-&gt;FTSR;  temp &amp;&#x3D; ~((uint32_t)iocurrent);  if((GPIO_Init-&gt;Mode &amp; TRIGGER_FALLING) !&#x3D; 0x00U)  &#123;  temp |&#x3D; iocurrent;  &#125;  EXTI-&gt;FTSR &#x3D; temp;    temp &#x3D; EXTI-&gt;EMR;  temp &amp;&#x3D; ~((uint32_t)iocurrent);  if((GPIO_Init-&gt;Mode &amp; EXTI_EVT) !&#x3D; 0x00U)  &#123;  temp |&#x3D; iocurrent;  &#125;  EXTI-&gt;EMR &#x3D; temp;    &#x2F;* Clear EXTI line configuration *&#x2F;  temp &#x3D; EXTI-&gt;IMR;  temp &amp;&#x3D; ~((uint32_t)iocurrent);  if((GPIO_Init-&gt;Mode &amp; EXTI_IT) !&#x3D; 0x00U)  &#123;  temp |&#x3D; iocurrent;  &#125;  EXTI-&gt;IMR &#x3D; temp;  &#125;  &#125;  &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>以下是GPIO初始化结构体定义<br><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;**  * @brief GPIO Init structure definition  *&#x2F;  typedef struct  &#123;  uint32_t Pin; &#x2F;*!&lt; Specifies the GPIO pins to be configured.  This parameter can be any value of @ref GPIO_pins_define *&#x2F;    uint32_t Mode; &#x2F;*!&lt; Specifies the operating mode for the selected pins.  This parameter can be a value of @ref GPIO_mode_define *&#x2F;    uint32_t Pull; &#x2F;*!&lt; Specifies the Pull-up or Pull-Down activation for the selected pins.  This parameter can be a value of @ref GPIO_pull_define *&#x2F;    uint32_t Speed; &#x2F;*!&lt; Specifies the speed for the selected pins.  This parameter can be a value of @ref GPIO_speed_define *&#x2F;    uint32_t Alternate; &#x2F;*!&lt; Peripheral to be connected to the selected pins.  This parameter can be a value of @ref GPIO_Alternate_function_selection *&#x2F;  &#125;GPIO_InitTypeDef;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>STM32的定时器预加载功能是指在定时器的计数器中设置一个预加载值，当计数器的值达到这个预设值时，可以触发一个事件或中断。这个功能在STM32微控制器的定时器操作中非常有用，尤其是在需要精确控制时间事件时。 </p><h2 id="重复周期计数器"><a href="#重复周期计数器" class="headerlink" title="重复周期计数器"></a>重复周期计数器</h2><p>在STM32微控制器中，一个重复周期计数器（Repeat Counter）通常是指定时器中的一个功能，它允许定时器在计数达到预设值后自动重置并重新开始计数。这种功能对于创建周期性事件非常有用，如周期性中断或定期检查某个条件。</p><p>使用重复周期计数器的基本步骤如下：</p><ol><li><p><strong>定时器配置</strong>：首先设置定时器的基本参数，包括时钟源、预分频值（用于确定计数器的计数速度）和自动重载值（ARR，用于设定计数器达到该值时重置）。</p></li><li><p><strong>设置重复计数器（如果可用）</strong>：某些STM32定时器模型中含有一个专门的重复计数器（REP寄存器），可以用来设置定时器在自动重载后重复计数的次数。如果设置为N，则定时器将完成N+1个周期后产生一个更新事件（包括中断，如果已启用）。</p></li><li><p><strong>中断配置（可选）</strong>：如果需要在每个周期结束时执行特定的操作，可以配置并启用更新事件中断（UIE）。</p></li><li><p><strong>启动定时器</strong>：最后，启动定时器以开始计数。</p><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2></li><li><p><strong>单脉冲模式（Single-Shot Mode）</strong>：在这种模式下，HRTIM在每次启动时只生成一个脉冲。这种模式通常用于精确控制时间长度的单次事件。</p></li><li><p><strong>重复模式（Repetitive Mode）</strong>：HRTIM会不断重复生成波形。这种模式适用于需要连续产生周期性波形的应用。</p></li><li><p><strong>连续模式（Continuous Mode）</strong>：在连续模式下，HRTIM持续运行，不断循环计数。这种模式通常用于持续跟踪时间或产生连续的波形。</p></li><li><p><strong>比较模式（Compare Mode）</strong>：HRTIM可以在计数器值达到预设值时生成一个事件。这种模式适用于需要在特定时间点执行操作的应用。</p></li><li><p><strong>捕获模式（Capture Mode）</strong>：在捕获模式下，HRTIM能够捕获并记录外部事件（如输入信号的边沿）发生时的计数器值，这对于测量外部事件的时间非常有用。</p></li><li><p><strong>死区时间管理（Dead-Time Management）</strong>：用于PWM（脉宽调制）应用，以防止H桥类型驱动器中的上下桥臂同时导通。</p></li><li><p><strong>波形模式（Waveform Mode）</strong>：这是一种高级模式，用于生成复杂的波形。在这种模式下，可以使用多个HRTIM通道并配置不同的事件和操作。</p></li><li><p><strong>突发模式（Burst Mode）</strong>：允许HRTIM在特定条件下自动启动和停止，实现对周期和脉冲的精确控制。</p></li></ol><h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 HAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAL与LL库区别</title>
      <link href="/2023/07/09/stm32/hal-yu-ll-ku-qu-bie/"/>
      <url>/2023/07/09/stm32/hal-yu-ll-ku-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>指带inline关键字的函数，作用是将函数直接嵌入到调用此函数的代码中，从而降低调用此函数的时间，适合频繁调用的场景</p><h1 id="两种库的区别"><a href="#两种库的区别" class="headerlink" title="两种库的区别"></a>两种库的区别</h1><p>LL库：寄存器纯享版<br>HAL库：程序员专享版<br>两种库可以混合使用</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高等数学</title>
      <link href="/2023/07/09/gao-deng-shu-xue/gao-deng-shu-xue/"/>
      <url>/2023/07/09/gao-deng-shu-xue/gao-deng-shu-xue/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-向量代数与空间解析几何"><a href="#第八章-向量代数与空间解析几何" class="headerlink" title="第八章  向量代数与空间解析几何"></a>第八章  向量代数与空间解析几何</h1><h2 id="8-1-向量及线性运算"><a href="#8-1-向量及线性运算" class="headerlink" title="8.1 向量及线性运算"></a>8.1 向量及线性运算</h2><h3 id="方向角与方向余弦"><a href="#方向角与方向余弦" class="headerlink" title="方向角与方向余弦"></a>方向角与方向余弦</h3><p>非零向量$\mathbf{r}=(x,y,z)= \overrightarrow{OM}$与坐标轴的夹角$\alpha、\beta、\gamma$称为向量$r$的方向角，易知</p><script type="math/tex; mode=display">\cos \alpha=\frac{x}{|O M|}=\frac{x}{|r|}</script><p>相应的，有</p><script type="math/tex; mode=display">\cos \beta=\frac{y}{|\boldsymbol{r}|}, \cos \gamma=\frac{z}{|\boldsymbol{r}|}</script><p>显然</p><script type="math/tex; mode=display">\begin{equation}\begin{split}(\cos \alpha, \cos \beta, \cos \gamma)=\left(\frac{x}{|\boldsymbol{r}|}, \frac{y}{|\boldsymbol{r}|}, \frac{z}{|\boldsymbol{r}|}\right)=\frac{1}{|\boldsymbol{r}|}(x, y, z)&=\frac{\boldsymbol{r}}{|\boldsymbol{r}|}=\boldsymbol{e}_r \\\cos^2 \alpha+\cos^2 \beta+cos^2 \gamma=1\end{split}\end{equation}</script><p>$\cos \alpha, \cos \beta, \cos \gamma$称为向量$\mathbf{r}$的方向余弦，并且以方向余弦为坐标的向量是与此向量同方向的单位向量</p><h3 id="向量的投影"><a href="#向量的投影" class="headerlink" title="向量的投影"></a>向量的投影</h3><ol><li>$Pri_{u}a=|a| \cos \varphi$</li><li>投影对加法和数乘运算封闭<h2 id="向量积-混合积"><a href="#向量积-混合积" class="headerlink" title="向量积 混合积"></a>向量积 混合积</h2><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3>向量积符合下列运算规律</li><li>$\boldsymbol{b} \times \boldsymbol{a}=-\boldsymbol{a} \times \boldsymbol{b}$</li><li>$(\boldsymbol{a}+\boldsymbol{b}) \times \boldsymbol{c}=\boldsymbol{a} \times \boldsymbol{c}+\boldsymbol{b} \times \boldsymbol{c}$</li><li>$(\lambda \boldsymbol{a}) \times \boldsymbol{b}=\boldsymbol{a} \times(\lambda \boldsymbol{b})=\lambda(\boldsymbol{a} \times \boldsymbol{b})(\lambda$ 为数 $)$<br>向量积的运算（行列式形式），向量积运算之后得到的结果仍然是向量<script type="math/tex; mode=display">\boldsymbol{a} \times \boldsymbol{b}=\left|\begin{array}{ccc}\boldsymbol{i} & \boldsymbol{j} & \boldsymbol{k} \\a_x & a_y & a_z \\b_x & b_y & b_z\end{array}\right|</script><h3 id="混合积"><a href="#混合积" class="headerlink" title="混合积"></a>混合积</h3>对于三个向量$\mathbf{a,b,c}$，先做ab的向量积，随后再与c做数量积，这样得到的数量叫做向量$\mathbf{a,b,c}$的混合积，记作<script type="math/tex; mode=display">[\mathbf{abc}]=\left|\begin{array}{lll}a_x & a_y & a_z \\b_x & b_y & b_z \\c_x & c_y & c_z\end{array}\right|</script>其几何意义为：由abc为棱构成的平行六面体的体积<br>常用性质：三个向量$\mathbf{a,b,c}$共面的充要条件为$[\mathbf{abc}]=0$<h2 id="平面及其方程"><a href="#平面及其方程" class="headerlink" title="平面及其方程"></a>平面及其方程</h2><h3 id="平面的点法式方程"><a href="#平面的点法式方程" class="headerlink" title="平面的点法式方程"></a>平面的点法式方程</h3>此方法需知某平面的法向量与平面内一点，因此称为点法式<br>由于平面的法向量与平面内的任意一条向量的数量积都为0，设$\mathbf{M}=(x,y,z)$是某平面内任意一点，$\mathbf{M_0}=(x_0,y_0,z_0)$是某平面内一点，平面的一条法向量为$\mathbf{n}=(A,B,C)$,明显有<script type="math/tex; mode=display">\begin{equation}\begin{split}\overrightarrow{MM_0}\cdot N=A\left(x-x_0\right)+B\left(y-y_0\right)+C\left(z-z_0\right)=0\end{split}\end{equation}</script>即得到平面点法式方程。<h3 id="平面的一般方程"><a href="#平面的一般方程" class="headerlink" title="平面的一般方程"></a>平面的一般方程</h3>定理：任意一个空间平面都可以用一个三元一次方程$A x+B y+C z+D=0$表示。<br>对于<strong>特殊的三元一次方程组，应该熟悉其图形特点</strong>，如：</li><li>当A=0时，平面是一个平行于x轴的平面，</li><li>当D=0时，平面过原点</li><li>当A=B=0时，平面平行于$xOy$平面<h3 id="两平面的夹角"><a href="#两平面的夹角" class="headerlink" title="两平面的夹角"></a>两平面的夹角</h3>两个平面法向量的夹角称为两平面的夹角<br>公式的证明过程实际上是两个平面的法向量的数量积运算经过变换得到的<br>公式：<script type="math/tex; mode=display">\cos \theta=\frac{\left|A_1 A_2+B_1 B_2+C_1 C_2\right|}{\sqrt{A_1^2+B_1^2+C_1^2} \sqrt{A_2^2+B_2^2+C_2^2}}</script>和高中部分的解析几何部分还是很像的<br>注：两平面平行或重合相当于其法向量对应成比例<h3 id="平面外一点到平面的距离公式"><a href="#平面外一点到平面的距离公式" class="headerlink" title="平面外一点到平面的距离公式"></a>平面外一点到平面的距离公式</h3>点 $P_0\left(x_0, y_0, z_0\right)$ 到平面 $A x+B y+C z+D=0$ 的距离公式<script type="math/tex; mode=display">d=\frac{\left|A x_0+B y_0+C z_0+D\right|}{\sqrt{A^2+B^2+C^2}}</script>证明思路：还是数量积的运算，令平面上某一点$P_1$法向量为$n$，明显有<script type="math/tex; mode=display">d=\left|\overrightarrow{P_1 P_0}\right||\cos \theta|=\frac{\left|P_1 P_0 \cdot \boldsymbol{n}\right|}{|\boldsymbol{n}|}</script>![[Pasted image 20230616170842.png]]<br><del>后续的自己慢慢算吧，跟高中的证明直线外一点到直线的距离是一样的</del><h2 id="空间直线及其方程"><a href="#空间直线及其方程" class="headerlink" title="空间直线及其方程"></a>空间直线及其方程</h2><h3 id="空间直线的一般式方程"><a href="#空间直线的一般式方程" class="headerlink" title="空间直线的一般式方程"></a>空间直线的一般式方程</h3>两个空间平面的交线会得到一条空间直线，由此得出空间直线的一般式方程<script type="math/tex; mode=display">\left\{\begin{array}{l}A_1 x+B_1 y+C_1 z+D_1=0 \\A_2 x+B_2 y+C_2 z+D_2=0\end{array}\right.</script>此方程组称为空间直线的一般式方程，是由两个空间平面的一般式方程组成的方程组<h3 id="空间直线的点向式方程（对称式方程）"><a href="#空间直线的点向式方程（对称式方程）" class="headerlink" title="空间直线的点向式方程（对称式方程）"></a>空间直线的点向式方程（对称式方程）</h3>在平面内，我们可以由斜率和平面内一点去建立直线的方程，而在空间内也是类似，但是斜率变成了空间直线的方向向量。<br>如果一个向量平行于一条已知直线，那么这个向量叫做这条直线的方向向量，其坐标称为这条直线的一组方向数，它的方向余弦叫做这条直线的方向余弦。<br>对于直线$L$上一点$\mathbf{M_0}=(x_0,y_0,z_0)$和其一方向向量$\mathbf{s}=(m,n,p)$，其点向式方程为<script type="math/tex; mode=display">\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}=t</script>加上t的意义在于导出其参数方程<script type="math/tex; mode=display">\left\{\begin{array}{l}x=x_0+m t \\y=y_0+n t \\z=z_0+p t \end{array}\right.</script>注：</li><li>当 $m 、 n$ 和 $p$ 中有一个为零, 例如 $m=0$, 而 $n$ 与 $p \neq 0$ 时, 这方程组应理解为<script type="math/tex; mode=display">\left\{\begin{array}{l}x-x_0=0, \\\frac{y-y_0}{n}=\frac{z-z_0}{p}\end{array}\right.</script></li><li>当$m 、n$和$p$中有两个为零, 例如$m = n=0$, 而$p \neq 0$时, 这方程组应理解为<script type="math/tex; mode=display">\left\{\begin{array}{l}x-x_{0}=0 \\y-y_{0}=0 \end{array}\right.</script><h3 id="两直线的夹角"><a href="#两直线的夹角" class="headerlink" title="两直线的夹角"></a>两直线的夹角</h3>还是两直线的方向余弦的数量积运算，两直线的夹角$\varphi$计算公式为<script type="math/tex; mode=display">\cos \varphi=\frac{\left|m_{1} m_{2}+n_{1} n_{2}+p_{1} p_{2}\right|}{\sqrt{m_{1}^{2}+n_{1}^{2}+p_{1}^{2}} \sqrt{m_{2}^{2}+n_{2}^{2}+p_{2}^{2}}}</script><h3 id="平面与直线的夹角"><a href="#平面与直线的夹角" class="headerlink" title="平面与直线的夹角"></a>平面与直线的夹角</h3>实际上是平面的法向量与直线的方向余弦的数量积运算<br>![[Pasted image 20230616180753.png]]<br>设直线的方向向量为$\mathbf{s}=(m,n,p)$，平面的法向量为$\mathbf{n}=(A,B,C)$，直线与平面的夹角为$\varphi$，那么<script type="math/tex; mode=display">\varphi=\left|\frac{\pi}{2}-(\widehat{s, n})\right|</script>绝对值的意义在于向量夹角可能为钝角。<br>因此<script type="math/tex; mode=display">\sin \varphi=|\cos (\boldsymbol{s}, \boldsymbol{n})|</script>则有<script type="math/tex; mode=display">\sin \varphi=\frac{|A m+B n+C p|}{\sqrt{A^{2}+B^{2}+C^{2}} \sqrt{m^{2}+n^{2}+p^{2}}} .</script>注意到如果平面与直线垂直，那么法向量与方向向量对应成比例<h2 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h2><h3 id="旋转曲面"><a href="#旋转曲面" class="headerlink" title="旋转曲面"></a>旋转曲面</h3>以一条平面曲线绕其平面上的一条直线旋转一周得到的曲面叫做<strong>旋转曲面</strong>，旋转曲线和定直线依次叫做旋转曲面的<strong>母线</strong>和<strong>轴</strong>。<br>对于在$yOz$平面上的曲线<script type="math/tex; mode=display">f(y,z)=0</script>如果将其绕$z$轴旋转，想得到它对应的旋转曲面的方程，只需用剩下的两个坐标，即$x,y$，将$y$替换为$\pm \sqrt{x^2+y^2}$即可<br>原理：当平面曲线绕$z$轴旋转时，$z$轴上的坐标不变，但是注意到曲线上的点到$z$轴的距离<script type="math/tex; mode=display">d=\sqrt{x^2+y^2}=|y|</script>因此旋转曲面的$y$替换为$\pm \sqrt{x^2+y^2}$<h3 id="柱面"><a href="#柱面" class="headerlink" title="柱面"></a>柱面</h3>直线$L$沿着定曲线$C$平行移动形成的轨迹叫做柱面，其中<br>定曲线$C$称为柱面的准线，动直线$L$称为柱面的母线<br>一般的，如果只含$x,y$的方程$F(x,y)=0$在空间直角坐标系中表示母线平行于$z$轴的平面，准线是$xOy$平面上的曲线$F(x,y)=0$。<br><del>依此类推，后面就不写了</del><h2 id="空间曲线及其方程"><a href="#空间曲线及其方程" class="headerlink" title="空间曲线及其方程"></a>空间曲线及其方程</h2><del>感觉不是很重要，过了QaQ</del></li></ol><h1 id="多元函数微分法及其应用"><a href="#多元函数微分法及其应用" class="headerlink" title="多元函数微分法及其应用"></a>多元函数微分法及其应用</h1><h3 id="多元函数的基本概念"><a href="#多元函数的基本概念" class="headerlink" title="多元函数的基本概念"></a>多元函数的基本概念</h3><h4 id="聚点"><a href="#聚点" class="headerlink" title="聚点"></a>聚点</h4><p>如果对于任意给定的$\delta&gt;0$，其去心邻域$\mathring{U}(P, \delta)$内总有$E$的点，那么称这个点是$E$的聚点。<br>例：对于平面点集<script type="math/tex">E=\{(x,y)|1<x^2+y^2 \leq2\}</script><br>明显$x^2+y^2=1$上的点不是$E$上的点，但是是$E$上的聚点</p><h4 id="多元函数的极限"><a href="#多元函数的极限" class="headerlink" title="多元函数的极限"></a>多元函数的极限</h4><p>对于二元函数$F(P)=f(x,y)$，设其定义域为$D$，$P_0=(x_0,y_0)$是$D$的聚点，如果对于任意给定的正数$\varepsilon$，总存在正数$\delta$，使得在定义域$D$内的点在任意方向上趋近$P_0$时，都有</p><script type="math/tex; mode=display">|f(P)-A|=|f(x,y)-A|<\varepsilon</script><p>成立，那么称$A$为函数$f(x,y)$当$(x,y)\rightarrow (x_0,y_0)$时的（二重）极限。记作</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(p)=A</script><h4 id="多元函数的连续性"><a href="#多元函数的连续性" class="headerlink" title="多元函数的连续性"></a>多元函数的连续性</h4><p>对于二元函数$F(P)=f(x,y)$，设其定义域为$D$，$P_0=(x_0,y_0)$是$D$的聚点，且$P_0 \in D$，如果</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(x,y)=f(x_0,y_0)</script><p>那么称函数$f(x,y)$在点$P_0$连续</p><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><ol><li>介值定理</li><li>有界性与最大值最小值定理<br>对于在有界闭区域上的多元连续函数一定在此区域内有界，且能取到其最小值和最大值<h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><h4 id="函数关于自变量的对称性"><a href="#函数关于自变量的对称性" class="headerlink" title="函数关于自变量的对称性"></a>函数关于自变量的对称性</h4>函数表达式中任意两个自变量对调之后仍然表示原来的函数，这种函数的偏导数具有形式不变性（同济P67）<h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4>For example，二元函数在其定义域内的点上对$x$的偏导数，其几何意义为该点处的切线对$x$轴的斜率。<h4 id="高阶偏导数"><a href="#高阶偏导数" class="headerlink" title="高阶偏导数"></a>高阶偏导数</h4>定理：如果函数$z=f(x, y)$的两个二阶混合偏导数$\frac{\partial^{2} z}{\partial y \partial x}$及$\frac{\partial^{2} z}{\partial x \partial y}$在区域$D$内 连续, 那么在该区域内这两个二阶混合偏导数必相等.<br>注：可导不一定连续（多元微积分）。<h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><h4 id="偏微分"><a href="#偏微分" class="headerlink" title="偏微分"></a>偏微分</h4>对于<script type="math/tex; mode=display">f(x+\Delta x,y )-f(x,y)\approx f_x(x,y)</script>左端称作二元函数$f(x,y)$对$x$的偏增量，右端称作称作二元函数$f(x,y)$对$x$的偏微分。<h4 id="全微分-1"><a href="#全微分-1" class="headerlink" title="全微分"></a>全微分</h4>定义：设函数$z=f(x, y)$在点$(x, y)$的某邻域内有定义, 如果函数在点$(x, y)$的全增量$\Delta z=f(x+\Delta x, y+\Delta y)-f(x, y)$可表示为$\Delta z=A \Delta x+B \Delta y+o(\rho)$,其中$A$和$B$不依赖于$\Delta x$和$\Delta$而仅与$x$和$y$有关, $\rho=\sqrt{(\Delta x)^{2}+(\Delta y)^{2}}$, 那么称 函数$z=f(x, y)$在点$(x, y)$可微分, 而$A \Delta x+B \Delta y$称为函数$z=f(x, y)$在点$(x, y)$的全微分, 记作$\mathrm{d} z$, 即<script type="math/tex">\mathrm{d} z=A \Delta x+B \Delta y</script><br>如果函数在区域$D$内各点处都可微分，那么称函数在$D$内可微分。<br>全微分等于其偏微分之和，称为多元函数的叠加原理。<br>注：可微一定连续，微分通常用来做近似计算处理。<br>注：全微分具有形式不变性<h5 id="可微的条件"><a href="#可微的条件" class="headerlink" title="可微的条件"></a>可微的条件</h5></li><li>（必要条件）如果多元函数在某点可微，那么其偏导数一定存在。</li><li>（充分条件）如果多元函数的所有偏导数在某点连续，那么函数在该点可微。<h3 id="复合函数求导法则"><a href="#复合函数求导法则" class="headerlink" title="复合函数求导法则"></a>复合函数求导法则</h3>主要方法是画函数关系图，根据关系图和链式求导法则写式子<br>例：$u=e^{x^3+y^2+z},z=x \sin y$，求<script type="math/tex; mode=display">\frac{\partial u}{\partial x},\frac{\partial u}{\partial y}</script>函数关系图如图所示<br><img src="https://pic4.zhimg.com/v2-9ca8ae2f25e51a364edda41e48ff3bb3_b.jpg" alt=""><br>根据关系图有：$$\begin{equation}\begin{split}\frac{\partial u}{\partial x}&=\frac{\partial u}{\partial z}\frac{\partial z}{\partial x}+\frac{\partial u}{\partial x} \\\frac{\partial u}{\partial y}&=\frac{\partial u}{\partial z}\frac{\partial z}{\partial y}+\frac{\partial u}{\partial y}\end{split}\end{equation}$$</li></ol><h3 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h3><h4 id="隐函数存在定理1"><a href="#隐函数存在定理1" class="headerlink" title="隐函数存在定理1"></a>隐函数存在定理1</h4><p>设函数$F(x, y)$在点$P\left(x_{0}, y_{0}\right)$的某一邻域内具有连续偏导数, 且$F\left(x_{0}, y_{0}\right)=0, F_{y}\left(x_{0}, y_{0}\right) \neq 0$, 则方程$F(x, y)=0$在点$\left(x_{0}, y_{0}\right)$的某一 邻域内恒能唯一确定一个连续且具有连续导数的函数$y=f(x)$, 它满足条件$y_{0}=   f\left(x_{0}\right)$ , 并有</p><script type="math/tex; mode=display">\frac{\mathrm{d} y}{\mathrm{~d} x}=-\frac{F_{x}}{F_{y}} .</script><p>实际上是把$y=f(x)$带入函数$F(x,y)$之后对$x$求偏导，有</p><script type="math/tex; mode=display">\begin{equation}\begin{split}F(x,f(x))=0\\F_x+F_y\frac{dy}{dx}=0\end{split}\end{equation}</script><p>变换后即为上面公式</p><h4 id="隐函数存在定理2"><a href="#隐函数存在定理2" class="headerlink" title="隐函数存在定理2"></a>隐函数存在定理2</h4><p>设函数$F(x, y, z)$在点$P\left(x_{0}, y_{0}, z_{0}\right)$的某一邻域内具有连续偏导数, 且$F\left(x_{0}, y_{0}, z_{0}\right)=0, F_{z}\left(x_{0}, y_{0}, z_{0}\right) \neq 0$，则方程$F(x, y, z)=0$在点$\left(x_{0}, y_{0}, z_{0}\right)$的某一邻域内恒能唯一确定一个连续且具有连续偏导数的函数$z=   f(x, y)$，它满足条件  $z_{0}=f\left(x_{0}, y_{0}\right)$, 并有</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=-\frac{F_{x}}{F_{z}}, \frac{\partial z}{\partial y}=-\frac{F_{y}}{F_{z}}</script><p>与上面的证明过程大体相同，将$z=f(x,y)$带入求偏导即得上式。</p><p>例：设$F(x,y)$有二阶连续偏导，已知<script type="math/tex">F(\frac{x}{z},\frac{y}{z})=0</script>求</p><script type="math/tex; mode=display">dz</script><p><img src="https://pic3.zhimg.com/v2-ab40835bee904e1b508903cc024afb96_b.jpg" alt=""><br>注意到$F$是一个隐函数，而我要求$dz$，而根据函数关系图发现可以确定一个函数$z=f(x,y)$，也就是说上面的隐函数实际上是$G(x,y,z)=F(u,v)=0$<br>根据函数关系图写式子</p><script type="math/tex; mode=display">\begin{equation}\begin{split}\frac{\partial F}{\partial x}=&\frac{\partial F}{\partial u} \frac{\partial u}{\partial x}+\frac{\partial F}{\partial u} \frac{\partial u}{\partial z} \frac{\partial z}{\partial x}+\frac{\partial F}{\partial v} \frac{\partial v}{\partial z} \frac{\partial z}{\partial x}=0 \\\frac{\partial F}{\partial y}=&\frac{\partial F}{\partial v}\frac{\partial v}{\partial z}\frac{\partial z}{\partial y}+\frac{\partial F}{\partial v}\frac{\partial v}{\partial y}+\frac{\partial F}{\partial u}\frac{\partial u}{\partial z}\frac{\partial z}{\partial y}=0\end{split}\end{equation}</script><p>按约定下标书写，有</p><script type="math/tex; mode=display">\begin{equation}\begin{split}F_{1}^{\prime} \frac{1}{z}+F_{1}^{\prime} \cdot\left(-\frac{x}{z^{2}}\right) \cdot \frac{\partial z}{\partial x}+F_{2}^{\prime} \cdot\left(-\frac{y}{z^{2}}\right) \cdot \frac{\partial z}{\partial x}=0\\F_{2}^{\prime} (\frac{-y}{z^2})\frac{\partial z}{\partial y}+F_2^{\prime}\frac{1}{z}+F_1^{\prime}(\frac{-x}{z^2})\frac{\partial z}{\partial y}=0 \\\end{split}\end{equation}</script><p>可以解出来$\frac{\partial z}{\partial y}$和$\frac{\partial z}{\partial x}$，因此全微分为</p><script type="math/tex; mode=display">dz=\frac{\partial z}{\partial x}dx+\frac{\partial z}{\partial y}+dy</script><h4 id="对于方程组的情况"><a href="#对于方程组的情况" class="headerlink" title="对于方程组的情况"></a>对于方程组的情况</h4><p>例题：设$xu-yv=0,yu+xy=1$,求：</p><script type="math/tex; mode=display">\frac{\partial u}{\partial x}, \frac{\partial u}{\partial y}, \frac{\partial v}{\partial x} \text { 和 } \frac{\partial v}{\partial y}</script><p>对于题给方程组，两侧对$x$求导并移项，有：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}x \frac{\partial u}{\partial x}-y \frac{\partial v}{\partial x}=-u \\y \frac{\partial u}{\partial x}+x \frac{\partial v}{\partial x}=-v\end{array}\right.</script><p>明显这是一个线性方程组，定义其系数行列式为$J$，由克莱姆法则有</p><script type="math/tex; mode=display">\begin{array}{l}\frac{\partial u}{\partial x}=\frac{\left|\begin{array}{rr}-u & -y \\-v & x\end{array}\right|}{\left|\begin{array}{rr}x & -y \\y & x\end{array}\right|}=-\frac{x u+y v}{x^{2}+y^{2}}, \\\frac{\partial v}{\partial x}=\frac{\left|\begin{array}{rr}x & -u \\y & -v\end{array}\right|}{\left|\begin{array}{rr}x & -y \\y & x\end{array}\right|}=\frac{y u-x v}{x^{2}+y^{2}} .\end{array}</script><p>书中所谓的雅可比式$J$实际上就是方程组的系数行列式。</p><h3 id="多元函数微分学的几何应用"><a href="#多元函数微分学的几何应用" class="headerlink" title="多元函数微分学的几何应用"></a>多元函数微分学的几何应用</h3><p>多元函数的全导数也就是多元函数对应的曲线的切线的方向向量，再在曲线上取一点即可写出点向式方程<br>注：空间曲线需写成参数方程形式<br>通过曲线上某一点并且与该点的切线相垂直的直线称为曲线在该点处的法平面，明显法平面的法向量就是切线的方向向量，因此写出点法式方程即可</p><h3 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h3><h4 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h4><p>定理 如果函数$f(x, y)$在点$P_{0}\left(x_{0}, y_{0}\right)$可微分, 那么函数在该点沿任一方向$l$的方向导数存在,且</p><script type="math/tex; mode=display">\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0} . y_{0}\right)}=f_{x}\left(x_{0}, y_{0}\right) \cos \alpha+f_{y}\left(x_{0}, y_{0}\right) \cos \beta</script><p>$\text { 其中 } \cos \alpha \text { 和 } \cos \beta \text { 是方向 } l \text { 的方向余弦. }$</p><h4 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h4><p>![[Pasted image 20230617225551.png]]<br>![[Pasted image 20230617225916.png]]</p><h3 id="多元函数极值"><a href="#多元函数极值" class="headerlink" title="多元函数极值"></a>多元函数极值</h3><ol><li>如果多元函数在某点具有偏导数而且在此处取得极值，那么其偏导数的函数值均为零</li><li>![[Pasted image 20230617230223.png]]<h4 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h4>对于自变量有附加条件的极值称为条件极值，比如在$V=xyz$再加一个条件$a^2=2(xy+xz+yz)$，这类极值点的求法通常使用拉格朗日乘数法<br>例：试求函数<script type="math/tex; mode=display">z=f(x,y)</script>在条件<script type="math/tex; mode=display">\varphi(x,y)=0</script>下取得极值的必要条件。<br>解：<br>不妨设在$(x_0,y_0)$取得极值，$\varphi(x,y)=0$可以确定一个连续且具有连续导数的函数$y=\psi(x)$，有<script type="math/tex; mode=display">\left.\frac{\mathrm{d} y}{\mathrm{~d} x}\right|_{x=x_{0}}=-\frac{\varphi_{x}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}</script>带回原函数有<script type="math/tex; mode=display">z=f[x, \psi(x)]</script>此时对$x$求导，由于$x$为唯一变量，因此只需令导数为零即求得取得极值的条件<script type="math/tex; mode=display">\left.\frac{\mathrm{d} z}{\mathrm{~d} x}\right|_{x=x_{0}}=f_{x}\left(x_{0}, y_{0}\right)+\left.f_{y}\left(x_{0}, y_{0}\right) \frac{\mathrm{d} y}{\mathrm{~d} x}\right|_{x=x_{0}}=0</script>联立上式有<script type="math/tex; mode=display">f_{x}\left(x_{0}, y_{0}\right)-f_{y}\left(x_{0}, y_{0}\right) \frac{\varphi_{x}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}=0</script>不妨令<script type="math/tex; mode=display">\frac{f_{y}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}=-\lambda</script>上述条件变为<script type="math/tex; mode=display">\left\{\begin{array}{l}f_{x}\left(x_{0}, y_{0}\right)+\lambda \varphi_{x}\left(x_{0}, y_{0}\right)=0\\f_{y}\left(x_{0}, y_{0}\right)+\lambda \varphi_{y}\left(x_{0}, y_{0}\right)=0 \\\varphi\left(x_{0}, y_{0}\right)=0 \end{array}\right.</script>引进拉格朗日函数<script type="math/tex; mode=display">L(x, y)=f(x, y)+\lambda \varphi(x, y)</script>其中$\lambda$称为拉格朗日算子，不难看出可以写成<script type="math/tex; mode=display">\left\{\begin{array}{l}L_x(x_0,y_0)=0\\L_y(x_0,y_0)=0\\\varphi\left(x_{0}, y_{0}\right)=0 \end{array}\right.</script>解出极值点之后带回原函数检验即可，对于自变量多于两个而条件多于一个的场景，拉格朗日函数加上对应的条件函数并乘上未知系数，联立方程组时将所有的拉格朗日函数的偏导数和条件全部联立解方程即可。<h1 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h1><h2 id="正项项级数审敛法"><a href="#正项项级数审敛法" class="headerlink" title="正项项级数审敛法"></a>正项项级数审敛法</h2></li><li>比较审敛法及其极限形式</li><li>比值审敛法</li><li>根植审敛法</li><li><p>如果</p><script type="math/tex; mode=display">\lim\limits_{n \rightarrow +\infty}u_n \ne0</script><p>则级数一定发散 </p></li><li><p>对数审敛法</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
