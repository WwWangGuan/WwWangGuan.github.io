<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>XMOS开发环境搭建</title>
      <link href="/2024/09/28/qian-ru-shi-ruan-jian/xmos/xmos-kai-fa-huan-jing-da-jian/"/>
      <url>/2024/09/28/qian-ru-shi-ruan-jian/xmos/xmos-kai-fa-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="2024-9-28"><a href="#2024-9-28" class="headerlink" title="2024.9.28"></a>2024.9.28</h1><p>妈的，ssh一直连不上，这又犯什么病了，主仓库能clone子模块就寄</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cmake </tag>
            
            <tag> 编译器 </tag>
            
            <tag> XMOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/25/dian-zi-dian-li/controlling-output-ripple-and-achieving-esr-independence-in-constant-on-time-cot-regulator-designs/"/>
      <url>/2024/09/25/dian-zi-dian-li/controlling-output-ripple-and-achieving-esr-independence-in-constant-on-time-cot-regulator-designs/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>Texas Instruments AN-1481<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240924110326.png" alt="image.png"></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LT8708-SuperCapController</title>
      <link href="/2024/09/24/dian-zi-dian-li/chao-ji-dian-rong/lt8708-supercapcontroller/"/>
      <url>/2024/09/24/dian-zi-dian-li/chao-ji-dian-rong/lt8708-supercapcontroller/</url>
      
        <content type="html"><![CDATA[<h1 id="Design-Requirement"><a href="#Design-Requirement" class="headerlink" title="Design Requirement"></a>Design Requirement</h1><p> 电容侧电压欠压保护<br> 底盘侧电压过压保护<br>借用部分Gmaster2022开源的设计参数</p><table><thead><tr><th>输入电压</th><th>14-28V</th><th></th></tr></thead><tbody><tr><td>输入电流</td><td>±8A</td><td></td></tr><tr><td>输出电压</td><td>14V-30V</td><td></td></tr><tr><td>输出电流</td><td>±8A</td><td></td></tr><tr><td>电容电压</td><td>5V-2</td><td></td></tr></tbody></table><h2 id="LT8708"><a href="#LT8708" class="headerlink" title="LT8708"></a>LT8708</h2><h3 id="Chip-Diagram"><a href="#Chip-Diagram" class="headerlink" title="Chip Diagram"></a>Chip Diagram</h3><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241010182741.png"></p><h3 id="Typical-Applicatio"><a href="#Typical-Applicatio" class="headerlink" title="Typical Applicatio"></a>Typical Applicatio</h3><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240923104201.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240923104211.png"></p><h4 id="For-SuperCap"><a href="#For-SuperCap" class="headerlink" title="For SuperCap"></a>For SuperCap</h4><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240929142259.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240929142311.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240929142323.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240929142330.png"></p><h3 id="Monitor-Pin"><a href="#Monitor-Pin" class="headerlink" title="Monitor Pin"></a>Monitor Pin</h3><table><thead><tr><th>引脚</th><th>功能</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>VOUTLOMON</td><td>$V_{OUT}$欠压监测引脚</td><td>在$V_{OUT}$、VOUTLOMON 和 GND 之间连接一个 ±1% 电阻分压器，以设置$V_{OUT}$上的欠压电平。当$V_{OUT}$低于该电平时，反向导通被禁用，以防止从$V_{OUT}$汲取电流。</td><td></td></tr><tr><td>VINHIMON</td><td>$V_{IN}$过压监测引脚</td><td>在$V_{IN}$、VINHIMON 和 GND 之间连接一个 ±1% 的电阻分压器，以设置 VIN 上的过压电平。当 VIN 高于该电平时，反向导通被禁用，以防止电流流入$V_{IN}$。</td><td></td></tr><tr><td>ICP</td><td>正向$V_{OUT}$电流监测引脚</td><td>从该引脚流出的电流为 20μA 加上与正平均$V_{OUT}$电流成比例的电流。</td><td></td></tr><tr><td>ICN</td><td>反向$V_{OUT}$电流监测引脚</td><td>从该引脚流出的电流为 20μA 加上与负平均$V_{OUT}$电流成比例的电流。</td><td></td></tr><tr><td>IMON_INP</td><td>正向$V_{IN}$ 电流监视器和限制引脚</td><td>从该引脚流出的电流为 20μA 加上与正平均 VIN 电流成比例的电流。 $IMON_INP$  还连接到误差放大器 EA5，可用于限制最大正$V_{IN}$电流。</td><td></td></tr><tr><td>IMON_INN</td><td>反向$V_{IN}$ 电流监视器和限制引脚</td><td>从该引脚流出的电流为 20μA 加上与负平均 VIN 电流成比例的电流。 $IMON_INN$ 还连接到误差放大器 EA1，可用于限制最大负$V_{IN}$电流。</td><td></td></tr><tr><td>IIMON_OP</td><td>正 VOUT 电流监视器和限制引脚。</td><td>从该引脚流出的电流为 20μA 加上与正平均 VOUT 电流成比例的电流。 IMON_OP 还连接到误差放大器 EA6，可用于限制最大正 VOUT 电流。</td><td></td></tr><tr><td>IMON_ON</td><td>负 VOUT 电流监视器和限制引脚</td><td>从该引脚流出的电流为 20μA 加上与负平均 VOUT 电流成比例的电流。 IMON_ON 还连接到误差放大器 EA2，可用于限制最大负 VOUT 电流。</td><td></td></tr></tbody></table><p>$ICP$和$ICN$是附加状态监测引脚</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><h4 id="Start-Up-Sequence"><a href="#Start-Up-Sequence" class="headerlink" title="Start-Up Sequence"></a>Start-Up Sequence</h4><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240924145904.png"></p><p>$\overline{SHDN}$是LT8708的主关断引脚，当此引脚上的电压低于0.35V时整个芯片会被强制关闭（$\textcolor{red}{CHIP \quad OFF}$），此时静态电流最小，只有当电压提升到1.221V以上后，$INTV_{CC}$和$LDO33$启用之后，芯片才会启动（$\textcolor{red}{SWITCHER \quad OFF \quad 1}$）<br><del>傻逼MathJax这latex语法都认不出来？蛤？</del><br>当$\overline{SHDN}$为高电平之后，$SWEN$用来控制启动芯片的开关稳压器（<del>芝士什么</del>），低于0.8V时无法启动，必须通过电阻拉高至1.208V以上才可启动，否则芯片电流检测电路将被禁用。 </p><p>$SWEN$也为高电平之后进入$\textcolor{red}{INITIALIZE}$状态，此时$SS$将被强制拉低，为软起动做准备。在此状态下，随着$SS$逐渐上升，软启动电路会在适当的方向上提供 $V_C$ 和电感器电流的逐渐斜坡。这可以防止电感电流突然浪涌，并有助于输出电压平稳地斜坡调节。 </p><p>$SS$内部有180K上拉电阻，和外部电容组成$RC$电路，当$SS$引脚电压到达1.8V时退出软起动状态开始进入正常操作状态。 </p><h4 id="Power-Switch-Control"><a href="#Power-Switch-Control" class="headerlink" title="Power Switch Control"></a>Power Switch Control</h4><h5 id="Error-Amplifiers"><a href="#Error-Amplifiers" class="headerlink" title="Error Amplifiers"></a>Error Amplifiers</h5><p>LT8708一共有六个误差放大器<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240924163550.png"><br>误差放大器优先级<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240924173611.png"><br>在某些情况下某些误差放大器不可用<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240924173837.png"></p><h5 id="Power-Switch-Contorl"><a href="#Power-Switch-Contorl" class="headerlink" title="Power Switch Contorl"></a>Power Switch Contorl</h5><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241011163748.png" alt="请注意，本图所述情况为反向传导环节.pdf"><br>LT8708比较有意思，由于IC内部自带了电荷泵升压，因此可以做到上管常开</p><h6 id="Switch-Control-Buck-Region-VIN-VOUT"><a href="#Switch-Control-Buck-Region-VIN-VOUT" class="headerlink" title="Switch Control: Buck Region (VIN &gt;&gt; VOUT)"></a>Switch Control: Buck Region (VIN &gt;&gt; VOUT)</h6><p>这部分很常规，上管常开之后就跟普通的Buck Controller差不多。<br>随着 $V_{IN}$ 和 $V_{OUT}$ 彼此接近，占空比减小，直到降压区域中转换器的最小占空比达到$DC_{(ABSMIN,M2,BUCK)}$。如果占空比低于 $DC_{(ABSMIN,M2,BUCK)}$，该区域转移至Buck-Boost区域。<br>$$<br>DC_{(ABSMIN,M2,BUCK)}&#x3D;t_{on(M2,MIN)}\cdot f \cdot 100 %<br>$$<br>其中，$t_{on(M2,MIN)}$是降压操作中同步开关的最短导通时间（典型值为 200ns，详见Electrical Characteristics）</p><h6 id="Switch-Control-Buck-Boost-VIN-≅-VOUT"><a href="#Switch-Control-Buck-Boost-VIN-≅-VOUT" class="headerlink" title="Switch Control: Buck-Boost (VIN ≅ VOUT)"></a>Switch Control: Buck-Boost (VIN ≅ VOUT)</h6><p>四开关交替导通，没啥好说的</p><h6 id="Switch-Control-Boost-Region-VIN-VOUT"><a href="#Switch-Control-Boost-Region-VIN-VOUT" class="headerlink" title="Switch Control: Boost Region (VIN &lt;&lt; VOUT)"></a>Switch Control: Boost Region (VIN &lt;&lt; VOUT)</h6><p>和Buck Reigon一样，就一个公式。<br>随着$V_{IN}$和$V_{OUT}$彼此接近，占空比减小，直到升压区域中转换器的最小占空比达到$DC_{(ABSMIN,M3,BOOST)}$。如果占空比低于 $DC_{(ABSMIN,M3,BOOST)}$，该区域转移至Buck-Boost区域。<br>$$<br>DC_{(ABSMIN,M3,BOOST)}&#x3D;t_{on(M3,MIN)} \cdot f \cdot 100 %<br>$$<br>其中，$DC_{(ABSMIN,M3,BOOST)}$是升压操作中同步开关的最短导通时间（典型值为 200ns，详见Electrical Characteristics）</p><h5 id="Uni-and-Bidirecional-Conduction"><a href="#Uni-and-Bidirecional-Conduction" class="headerlink" title="Uni and Bidirecional Conduction"></a>Uni and Bidirecional Conduction</h5><p>双向模式下是CCM，单向模式下是HCM（混合电流模式和突发模式操作）和DCM<br><del>（HCM？….没听过<br> 没事了，datasheet后面有）</del><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240924172325.png"></p><h6 id="CCM"><a href="#CCM" class="headerlink" title="CCM"></a>CCM</h6><p>伟大，无需多言</p><h6 id="DCM"><a href="#DCM" class="headerlink" title="DCM"></a>DCM</h6><h4 id="Current-Monitoring-and-Limiting"><a href="#Current-Monitoring-and-Limiting" class="headerlink" title="Current Monitoring and Limiting"></a>Current Monitoring and Limiting</h4><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241009180756.png" alt="输入电流检测与限制"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241009180808.png" alt="输出电流检测与限制"><br>输入和输出的电流检测是完全独立的，两边的结构都是相似的，检流电阻的压差差分信号经过一个跨导放大器连接到内部的误差放大器，并且输出到外部的检测引脚，由于引脚输出的是电流（内部会在跨导放大器的基础上加上一个$20\mu A$的电流），因此接上一个电阻就可以将其转换成电压信号，这样就可以用ADC采集到电流信息。电容仅仅是为了滤波和稳定环路（忘了在哪看到的了），几个$nF$就足够了</p><h5 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h5><p>检测引脚的电压由以下公式决定<br>$$<br>\begin{equation}\begin{split}<br>V_{IMON_INP}&#x3D;(1m\frac{A}{V} \cdot R_{Sense1}\cdot I_{IN}+20\mu A)<br>\cdot R_{IMON_INP} \<br>V_{IMON_INN}&#x3D;(-1m\frac{A}{V} \cdot R_{Sense1}\cdot I_{IN}+20\mu A)<br>\cdot R_{IMON_INN} \<br>\end{split}\end{equation}<br>$$</p><h5 id="Current-Limiting"><a href="#Current-Limiting" class="headerlink" title="Current Limiting"></a>Current Limiting</h5><p>电流限制的思路比较简单，注意到检流电阻的信号是加上一个偏置电流输出到外部引脚，引脚连接电阻就会有电压值，这个电压值和误差放大器的基准电压进行比较，当这个电压大于基准电压的时候误差放大器就会输出低电平到补偿环路，进而使得PWM占空比减小，也就达到了控制电流的目的。<br>我们以控制正向的输入电流为例（$IMON_INP$）,内部结构见$Figure 15$，其基准电压为$1.209V$,那么$R_{IMON_INP}$、$R_{SENSE1}$和正向输入电流$I_{IN,FWD,LIMIT}$有如下关系：<br>$$<br>R_{IMON_INP}&#x3D;\frac{1.209}{I_{IN,FWD,LIMIT}\cdot1m\frac{A}{V}\cdot R_{SENSE1}+20\mu A}<br>$$<br>并没有看到有关限制$R_{SENSE}$相关的字样，那看来是随便取，datasheet给出了一个例子。<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241010181501.png"></p><h3 id="Frequency"><a href="#Frequency" class="headerlink" title="Frequency"></a>Frequency</h3><p>经典$RT$引脚配置频率，btw，$SYNC$可用作温度监测<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240923105631.png"></p><h3 id="Inductor-Current-Sense-Pin-CSP-CSN"><a href="#Inductor-Current-Sense-Pin-CSP-CSN" class="headerlink" title="Inductor Current Sense(Pin: CSP&#x2F;CSN)"></a>Inductor Current Sense(Pin: CSP&#x2F;CSN)</h3><p>$LT8708$使用电感电流模式控制，其测量升压区域中电感器电流波形的峰值和降压区域中电感器电流波形的谷值，在任何给定周期内，电感电流的峰值（升压区域）或谷值（降压区域）由 VC 引脚电压控制。</p><blockquote><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240923110607.png"></p></blockquote><h4 id="Slope-Compensation"><a href="#Slope-Compensation" class="headerlink" title="Slope Compensation"></a>Slope Compensation</h4><p>datasheet上有，与硬件设计无关（大雾</p><h3 id="IC-Junction-Temperature-Measurement"><a href="#IC-Junction-Temperature-Measurement" class="headerlink" title="IC Junction Temperature Measurement"></a>IC Junction Temperature Measurement</h3><p>LT8708的芯片温度会对$CLKOUT$引脚输出信号的占空比产生影响<br>$$<br>T_J \approx \frac{DC_{CLKOUT}- 34.4%}{0.325%} \  ^\circ C<br>$$<br>计算出来的温度有大概±10℃的误差，<del>NTC算出来的误差大概多少？<br>感觉还是上个NTC吧，误差有点离谱了，不能芯片本身制动还要靠这个吧（）</del></p><h3 id="Component-Selection"><a href="#Component-Selection" class="headerlink" title="Component Selection"></a>Component Selection</h3><h4 id="R-SENSE-Selection"><a href="#R-SENSE-Selection" class="headerlink" title="$R_{SENSE}$  Selection"></a>$R_{SENSE}$  Selection</h4><p>这里的检流电阻特指电感电流的检流电阻，输入和输出的检流电阻不在本小节的讨论范围内，请右转Current Monitoring and Limiting。<br>需要计算四个区域的最大$R_{SENSE}$阻值，正向升压，反向升压，正向降压，反向降压，最后的结果小于四者的最小值，并建议流出建议留出$20%$至$30%$的余量。如果有一个区域没有用到时，此区域的$R_{SENSE}&#x3D;\infty$<br>还有一部分详见datasheet P31右侧。<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241011105512.png" alt="会有用的.jpg"></p><h5 id="Max-R-SENSE-in-the-Boost-Reigon"><a href="#Max-R-SENSE-in-the-Boost-Reigon" class="headerlink" title="Max $R_{SENSE}$ in the Boost Reigon"></a>Max $R_{SENSE}$ in the Boost Reigon</h5><h6 id="Forward-Conduction"><a href="#Forward-Conduction" class="headerlink" title="Forward Conduction"></a>Forward Conduction</h6><p>在升压区域，当$VIN$最低且$VOUT$最高时，最大正$VOUT$电流能力最低。<del>（说实话没看懂啥意思）</del><br>此时的M3占空比<br>$$<br>DC_{MAX,M3,BOOST}\approx(1-\frac{V_{IN(MIN,BOOST)}}{V_{OUT(MAX,BOOST)}})\cdot 100%<br>$$<br>计算出占空比后需要去看一下最大电感电流检测电压图，找到此时$R_{SENSE}$两侧的电压$V_{R_{SENSE}}$<br>下一级计算正向升压区域的电感纹波电流(Inductor ripple Current)，此时分两种情况<br>如果尚未确定此时的电感感值，取最大$V_{OUT}$负载电流的30%-50%，因此纹波电流为：<br>$$<br>\Delta I_{L(MAX,BOOST)}&#x3D;\frac{V_{OUT(MAX.BOOST)}\cdot I_{OUT(MAX,FWD)}}{V_{IN(MIN,BOOST)}\cdot (\frac{100 %}{ripple}-0.5)}A<br>$$<br>若此时电感感值已确定，那么有：</p><p>$$<br>\Delta I_{L(MAX,M3,BOOST)}&#x3D;\frac{(\frac{DC_{(MAX,M3,BOOST)}}{100%})\cdot V_{IN(MIN,BOOST)}}{f\cdot L}A<br>$$</p><p>在最大纹波电流确定后，本区域内的最大$R_{SENSE}$计算公式如下：</p><p>$$<br>R_{SENSE(MAX,BOOST,FWD)}&#x3D;\frac{2\cdot V_{R_{SENSE(MAX,BOOST,MAXDC)}}\cdot V_{IN(MIN,BOOST)}}{(2\cdot I_{OUT(MAX,FWD)}\cdot V_{OUT(MAX,BOOST)}+(\Delta I_{L(MAX,BOOST)}\cdot V_{IN(MIN,BOOST)}))}<br>$$</p><h6 id="Reverse-Conduction"><a href="#Reverse-Conduction" class="headerlink" title="Reverse Conduction"></a>Reverse Conduction</h6><p>在反向升压区域，当以最小占空比工作时，最大反向$VIN$电流最低<br>在计算此区域的$R_{SENSE}$大小时，首先需要确定电感纹波电流，还是两种情况。<br>如果电感尚未确定，则可以通过选择$\Delta I_{L(MIN,BOOST)}$ 为升压区域中最小峰值电感电流的 10% 来估计纹波电流 $\Delta I_{L(MIN,BOOST)}$，如下所示:</p><p>$$<br>\Delta I_{L(MIN,BOOST)}&#x3D;\frac{I_{IN(MAX,RVS)}}{\frac{100%}{10%}-0.5}A<br>$$<br>其中,$I_{IN(MAX,RVS)}$ 是反向升压区域所需的最大$VIN$负载电流.<br>如果电感已选型，那么可根据如下公式计算：<br>$$<br>\Delta I_{L(MIN,BOOST)}&#x3D;\frac{\frac{DC_{(ADBSMIN,M3,BOOST)}}{100%}\cdot V_{IN(MIN,BOOST)}}{f \cdot L}<br>$$<br>其中，$DC_{(ADBSMIN,M3,BOOST)}$是升压区域的最小占空比。<br>在得到电感纹波电流之后，本区域的$R_{SENSE}$可根据如下公式计算：<br>$$<br>R_{SENSE(MAX.BOOST,RVS)}&#x3D;\frac{2\cdot |V_{RSENSE(MIN,BOOST,MINDC)}|}{(2\cdot I_{IN(MAX,RVS)})-\Delta I_{L(MIN,BOOST)}}<br>$$<br>其中，$V_{RSENSE(MIN,BOOST,MINDC)}$是在升压区域下最小占空比时的$R_{SENSE}$两侧电压（最小电感电流检测电压），典型值为$-93mV$。<br>若上式的计算结果为负，则说明任何阻值都可满足要求，将本区域内的阻值视为$\infty$并进入下一部分计算</p><h5 id="Max-R-SENSE-in-the-Buck-Reigon"><a href="#Max-R-SENSE-in-the-Buck-Reigon" class="headerlink" title="Max $R_{SENSE}$ in the Buck Reigon"></a>Max $R_{SENSE}$ in the Buck Reigon</h5><h6 id="Forward-Conduction-1"><a href="#Forward-Conduction-1" class="headerlink" title="Forward Conduction"></a>Forward Conduction</h6><p>在降压区域中，当以最小占空比运行时，最大$VOUT$电流能力最低。<br>和升压区域中的反向导通一样，仍然需要首先计算电感纹波电流$\Delta I_{L(MIN,BUCK)}$，两种情况：<br>如果电感感值未知，纹波电流$\Delta I_{L(MIN,BUCK)}$可以通过选择$\Delta I_{L(MIN,BUCK)}$为降压区域中最大峰值电感电流的 10% 来估算<del>(这句话真的好怪，翻译出来是这样但是你看公式又不是那味)</del>，如下所示<br>$$<br>\Delta I_{L(MIN,BUCK)}&#x3D;\frac{I_{OUT(MAX,FWD)}}{\frac{100%}{10%}-0.5}A<br>$$<br>其中，$I_{OUT(MAX,FWD)}$是正向降压区域所需的最大$VOUT$负载电流。<br>如果电感感值已知，那么可根据下式计算：<br>$$<br>\Delta I_{L(MIN,BUCK)}&#x3D;\frac{\frac{DC_{ABISMIN,M2,BUCK}}{100%}\cdot V_{OUT(MIN,BUCK)}}{f\cdot L}A<br>$$<br>其中，$DC_{ABISMIN,M2,BUCK}$是先前计算的降压区域的最小占空比。<br>在得到电感纹波电流之后，本区域的$R_{SENSE}$计算公式为：<br>$$<br>R_{SENSE(MAX,BUCK,FWD)}&#x3D;\frac{2\cdot V_{R_{SENSE(MAX,BUCK,MINDC)}}}{2\cdot I_{OUT(MAX,FWD)}-\Delta I_{L(MIN,BUCK)}} \ohm<br>$$<br>其中，$V_{R_{SENSE(MAX,BUCK,MINDC)}}$是在最小占空比时的最大电感电流检测电压，典型值为$82mV$。<br>若上式的计算结果为负，则说明任何阻值都可满足要求，将本区域内的阻值视为$\infty$并进入下一部分计算</p><h6 id="Reverse-Forward"><a href="#Reverse-Forward" class="headerlink" title="Reverse Forward"></a>Reverse Forward</h6><p>在降压区域，当$VIN$处于最大值并且$VOUT$处于降压操作的最小值时，最大反向$VIN$电流能力最小。<br>首先找到$VIN$最小且$VOUT$最大时的降压区域占空比<br>$$<br>DC_{(MAX,M2,BUCK)}&#x3D;(1-\frac{V_{OUT(MIN,BUCK)}}{V_{IN(MAX,BUCK)}})\cdot 100%<br>$$<br>然后计算电感纹波电流，如果电感未知，那么最大纹波电流 $\Delta I_{L(MAX,BUCK)}$ 可以通过选择$\Delta I_{L(MAX,BUCK)}$为降压区域最大峰值电感电流的$30%$至$50%$来估算，如下所示:<br>$$<br>\Delta I_{L(MAX,BUCK)}&#x3D; \frac{V_{IN(MAX,BUCK)}\cdot I_{IN(MAX,RVS)}}{V_{OUT(MIN,BUCK)}\cdot (\frac{100%}{Ripple}-0.5)}A<br>$$<br>如果电感已知，那么可根据下式计算的更精确一点：<br>$$<br>\Delta I_{L(MAX,BUCK)}&#x3D;\frac{\frac{DC_{(MAX,M2,BUCK)}}{100%}\cdot V_{OUT(MIN,BUCK)}}{f\cdot L}A<br>$$<br>其中，$DC_{(MAX,M2,BUCK)}$是先前计算的降压区域的最大占空比。<br>那么，最终本区域的$R_{SENSE}$据下式计算：<br>$$<br>R_{SENSE(MAX,BUCK,RVS)}&#x3D;\frac{2\cdot |V_{R_{SENSE()MIN,BUCK,MAXDC}}|\cdot V_{OUT(MIN,BUCK)}}{(2\cdot |I_{IN(MAX,RVS)}|\cdot V_{IN(MAX,BUCK)})+(\Delta I_{L(MAX,BUCK)}\cdot V_{OUT(MIN,BUCK)})} \ohm<br>$$<br>其中，$V_{R_{SENSE()MIN,BUCK,MAXDC}}$是最大占空比时的最小电感电流检测电压。该值的确定方式与之前在$R_{SENSE}$ Selction Boost  Reigon部分中的最大$R_{SENSE}$中讨论的$V_{R_{SENSE(MAX,BOOST,MAXDC)}}$ 类似</p><h5 id="R-SENSE-Filtering"><a href="#R-SENSE-Filtering" class="headerlink" title="$R_{SENSE}$ Filtering"></a>$R_{SENSE}$ Filtering</h5><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241011162638.png"><br>10(a)和10(b)都可以，但是10(b)的接法会在电流经过电容时引入接地走线噪声（？从何而来的结论）</p><h4 id="Mosfet-Selection"><a href="#Mosfet-Selection" class="headerlink" title="Mosfet Selection"></a>Mosfet Selection</h4><h5 id="Dissipation-Calculate"><a href="#Dissipation-Calculate" class="headerlink" title="Dissipation Calculate"></a>Dissipation Calculate</h5><p><del>## INA226<br>INA并不直接测量电流，它测量检流电阻两侧的差分电压得到电流值（</del>what can i say.jpg<del>）<br>貌似用不到了，直接用ADC加个OPAMP采一下监控引脚就能拿到电压电流值了，非常的nice。</del></p><h2 id="SuperCap"><a href="#SuperCap" class="headerlink" title="SuperCap"></a>SuperCap</h2><p>Viashy的<a href="https://www.vishay.com/zh/product/28421/">220 EDLC ENYCAP™ Energy Storage Capacitors | Vishay</a>,2.7V 50F<br>手册的最小放电电压为1.5V，最大充放电电流为4.4A<br>11串电容单体，电压为$$2.7\times11&#x3D;29.7V$$<br>此时能量<br>$$<br>E &#x3D; \frac{1}{2}CU^2&#x3D;2004.75J<br>$$<br>被动均衡，充电至2.65V,此时电压为：<br>$$<br>2.65\times 11&#x3D;29.15V<br>$$</p><h2 id="裁判系统要求"><a href="#裁判系统要求" class="headerlink" title="裁判系统要求"></a>裁判系统要求</h2><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240927164538.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240926024221.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240926024232.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240926024241.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20240926024247.png"></p><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="参考链接和不认识的玩应"><a href="#参考链接和不认识的玩应" class="headerlink" title="参考链接和不认识的玩应"></a>参考链接和不认识的玩应</h2><ol><li>as intended 按预期</li><li>methodical $adj.$ 有条理的</li><li>criteria $n.$ 标准</li><li>optimal $adj.$ 最合适的</li><li>Subharmonic $n.$ 次谐波</li><li>dissipate $v.$ 消失</li><li>Potentiometer $n.$ 电位计</li><li>illustrate $v.$ 说明，阐明</li><li>respective $adj.$ 分别</li><li>be proportional to 正比于</li><li>Amps. 安培</li><li>significantly $adj.$ 极大的，显著的</li><li>product $n.$ 乘积</li><li>trip $v.$ 跳闸（？我觉得说成跳变也许更好）<img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241011171250.png"></li><li><a href="https://www.analog.com/en/products/lt8708.html">LT8708 Datasheets and Production Info | Analog Devices</a></li><li><a href="https://zhuanlan.zhihu.com/p/472919794">Latex符号大全</a></li><li><a href="https://blog.csdn.net/luolang_103/article/details/81289529">LaTex中输入空格以及换行_ctex换行-CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_41520353/article/details/128675834">OB0207 obsidian 自动获取url链接：auto-link-title插件使用_auto link title-CSDN博客</a></li><li><a href="https://www.cnblogs.com/tsingke/p/7457236.html">Latex中如何设置字体颜色（3种方式） - Tsingke - 博客园</a></li><li><a href="https://blog.csdn.net/JM1307hhh/article/details/128448860?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522416F45B3-C90F-4F11-A77D-1A1E76672115%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=416F45B3-C90F-4F11-A77D-1A1E76672115&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128448860-null-null.142%5Ev100%5Epc_search_result_base3&utm_term=latex%20%E7%99%BE%E5%88%86%E5%8F%B7%E6%80%8E%E4%B9%88%E6%89%93&spm=1018.2226.3001.4187">latex 写作常见问题记录_overleaf正文有百分数后面的内容不显示了-CSDN博客</a></li><li><a href="https://blog.csdn.net/namishizi321/article/details/128028757">在LaTeX中如何输入摄氏度的符号_latex 摄氏度-CSDN博客</a></li><li><a href="https://www.analog.com/cn/resources/technical-articles/dynamically-adjust-the-right-output-voltage.html">工程师指南：如何动态调整合适的输出电压 | Analog Devices</a></li><li><a href="https://www.ti.com.cn/cn/lit/an/zhcadz3a/zhcadz3a.pdf?ts=1727229600659">具有电压输出智能 DAC 的电压裕量和调节电路 (Rev. A)</a></li><li><a href="https://www.analog.com/media/cn/training-seminars/tutorials/mt-015_cn.pdf">DAC基本架构II：二进制DAC</a></li><li><a href="https://www.ti.com.cn/cn/lit/an/zhcacg4/zhcacg4.pdf?ts=1727247745601&ref_url=https%253A%252F%252Fwww.ti.com.cn%252Fproduct%252Fcn%252FBQ25713">如何快速安全地为超级电容器充电</a></li><li><a href="https://www.chemi-con.co.jp/download/pdf/dl-technote-c.pdf">超级电容器的熟练使用方法</a></li><li><a href="https://www.vishay.com/docs/28495/enycapinstrmanual.pdf">ENYCAPTM Instruction Manual</a></li></ol><h2 id="电压裕度"><a href="#电压裕度" class="headerlink" title="电压裕度"></a>电压裕度</h2><p>没事了，自己百度吧，是我多虑了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电子元件原神 </tag>
            
            <tag> 电子电力技术 </tag>
            
            <tag> 硬件组 </tag>
            
            <tag> RoboMaster </tag>
            
            <tag> 超级电容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/08/28/csapp/ji-suan-ji-ti-xi-jie-gou-ji-chu/"/>
      <url>/2024/08/28/csapp/ji-suan-ji-ti-xi-jie-gou-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>使用教材：<a href="https://foxsen.github.io/archbase/">计算机体系结构基础</a><br>参考教材：<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408290759841.png"></p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h1 id="章节习题"><a href="#章节习题" class="headerlink" title="章节习题"></a>章节习题</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol><li>计算机系统可划分为哪几个层次，各层次之间的界面是什么？你认为这样划分层次的意义何在？<br>四大层次：应用程序，操作系统，硬件系统，晶体管<br>层次界面：API（应用程序的高级语言编程接口） ISA（指令系统）工艺模型（介于硬件系统与晶体管之间）<br><strong>层次划分的意义</strong></li><li><strong>抽象与封装</strong>：每一层次封装了下层的复杂性，提供给上层一个简化的抽象接口。例如，操作系统屏蔽了硬件的复杂性，提供了更易于使用的系统调用接口。</li><li><strong>模块化设计</strong>：层次化设计促进了系统的模块化，使得开发、维护和扩展更加容易。每一层次可以独立开发和优化，而不需要过多考虑其他层次的内部实现细节。</li><li><strong>提高系统的灵活性和可移植性</strong>：通过层次化，系统可以适应不同的硬件环境和用户需求。例如，同一套应用程序可以在不同的操作系统上运行，只要系统库和操作系统接口保持一致。</li><li><strong>增强安全性和稳定性</strong>：不同层次之间的界面明确限定了访问权限和操作范围，减少了错误传播的风险。例如，应用程序不能直接访问硬件，而是通过操作系统，这样可以防止程序错误导致系统崩溃。</li></ol><p>通过这种层次划分，计算机系统得以更清晰地组织和管理，便于开发者理解和控制各个组成部分的功能和关系。</p><ol start="2"><li>在三台不同指令系统的计算机上运行同一程序P时，A机器需要执行$1.0×10^9$ 条指令，B机器需要执行$2.0×10^9$条指令，C机器需要执行$3.0×10^9$条指令，但三台机器的实际执行时间都是100秒。请分别计算出这三台机器的$MIPS$，并指出运行程序P时哪台机器的性能最高。</li></ol><p>MIPS定义：（Million Instructions Per Second）,即每秒执行多少百万条指令<br>A的MIPS : $1.0\times10^7$<br>B的MIPS：$2.0\times10^7$<br>C没必要算了</p><p>1. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/08/27/qian-ru-shi-ruan-jian/nei-he/arm-cortex-m3-he-m4-wei-chu-li-qi-quan-wei-zhi-nan/"/>
      <url>/2024/08/27/qian-ru-shi-ruan-jian/nei-he/arm-cortex-m3-he-m4-wei-chu-li-qi-quan-wei-zhi-nan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/08/26/dian-zi-dian-li/zynq/ad-layout-bga/"/>
      <url>/2024/08/26/dian-zi-dian-li/zynq/ad-layout-bga/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>电机与拖动</title>
      <link href="/2024/08/26/dian-zi-dian-li/dian-ji-yu-tuo-dong/dian-ji-yu-tuo-dong/"/>
      <url>/2024/08/26/dian-zi-dian-li/dian-ji-yu-tuo-dong/dian-ji-yu-tuo-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 电机 </tag>
            
            <tag> 电子电力技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/08/20/qian-ru-shi-ruan-jian/nxp/lpc4322jet100e/"/>
      <url>/2024/08/20/qian-ru-shi-ruan-jian/nxp/lpc4322jet100e/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在openocd下使用Jlink并调用其GDB</title>
      <link href="/2024/08/20/qian-ru-shi-ruan-jian/debugger/zai-openocd-xia-shi-yong-jlink-bing-diao-yong-qi-gdb/"/>
      <url>/2024/08/20/qian-ru-shi-ruan-jian/debugger/zai-openocd-xia-shi-yong-jlink-bing-diao-yong-qi-gdb/</url>
      
        <content type="html"><![CDATA[<h1 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h1><p>STM32H750VGH6<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408201459610.png"><br>J-Link OB-RA4M2-Full<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408201507575.png"></p><h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><p>interface里面有jlink.cfg，直接调<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408201500673.png"></p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">  source [find interface&#x2F;jlink.cfg]    transport select swd    source [find target&#x2F;stm32h7x.cfg]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一次报错<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408201501581.png"><br>设备管理器里看不到，但是<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408201532269.png"><br>哈？<del>（Rikki乱入）</del><br><a href="https://blog.csdn.net/weixin_45467056/article/details/119886361">解决openocd无法识别jlink的问题LIBUSB_ERROR_NOT_SUPPORTED_no emulators connected via usb-CSDN博客</a><br>傻逼openocd，不过CLion可以调Jlink的下载器吗？</p><h1 id="CLion编译完成后使用脚本下载"><a href="#CLion编译完成后使用脚本下载" class="headerlink" title="CLion编译完成后使用脚本下载"></a>CLion编译完成后使用脚本下载</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Jlink </tag>
            
            <tag> Jlink-OB </tag>
            
            <tag> OpenOCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个小目标</title>
      <link href="/2024/08/20/za-ji/ji-ge-xiao-mu-biao/"/>
      <url>/2024/08/20/za-ji/ji-ge-xiao-mu-biao/</url>
      
        <content type="html"><![CDATA[<ul><li><input disabled="" type="checkbox"> 买个Roland Jupiter-80</li><li><input disabled="" type="checkbox"> 搞一套自己的架子鼓</li><li><input disabled="" type="checkbox"> 熟练扒谱</li><li><input disabled="" type="checkbox"> Jlink！！！！！（被傻逼瑞萨气死）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移远EC801E调试记录</title>
      <link href="/2024/08/19/qian-ru-shi-ruan-jian/yi-yuan-ec801e-diao-shi-ji-lu/yi-yuan-ec801e-diao-shi-ji-lu/"/>
      <url>/2024/08/19/qian-ru-shi-ruan-jian/yi-yuan-ec801e-diao-shi-ji-lu/yi-yuan-ec801e-diao-shi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>EC600E-CN&amp;EC800E-CN<br>AT 命令手册<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408190913781.png"><br>EC801E兼容EC800E</p><h1 id="测试与配置"><a href="#测试与配置" class="headerlink" title="测试与配置"></a>测试与配置</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408190914163.png"></p><h2 id="ID请求"><a href="#ID请求" class="headerlink" title="ID请求"></a>ID请求</h2><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408190915615.png"></p><h2 id="IMEI和SN请求"><a href="#IMEI和SN请求" class="headerlink" title="IMEI和SN请求"></a>IMEI和SN请求</h2><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408190918401.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">» ATI+GSN&#x3D;?« ATI+GSN&#x3D;?QuectelEC801ERevision: EC801ECNCGR03A03M02+GSN: (0,1)OK» ATI+GSN&#x3D;0« ATI+GSN&#x3D;0QuectelEC801ERevision: EC801ECNCGR03A03M02+GSN: &quot;P1Y24AF290027370P&quot;OK» ATI+GSN&#x3D;1« ATI+GSN&#x3D;1QuectelEC801ERevision: EC801ECNCGR03A03M02+GSN: &quot;864145070094386&quot;OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="串口控制命令"><a href="#串口控制命令" class="headerlink" title="串口控制命令"></a>串口控制命令</h1><h3 id="AT-C-设置DCD-信号模式"><a href="#AT-C-设置DCD-信号模式" class="headerlink" title="AT&amp;C 设置DCD 信号模式"></a>AT&amp;C 设置DCD 信号模式</h3><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408190933034.png"><br>啥叫DCD信号模式？<br> 来看看chatgpt怎么说</p><p> 4G模块的DCD信号（Data Carrier Detect，数据载波检测）通常用于表示设备是否已与网络建立了有效的连接。DCD信号是一种传统的串口通信信号，用于告诉接收设备通信线路上是否存在有效的载波信号。在4G模块中，DCD信号模式的作用取决于具体的模块设计和应用需求。</p><h4 id="DCD信号模式的几种典型用法："><a href="#DCD信号模式的几种典型用法：" class="headerlink" title="DCD信号模式的几种典型用法："></a>DCD信号模式的几种典型用法：</h4><ol><li><p><strong>网络连接状态指示：</strong><br> 在一些4G模块中，DCD信号可以用于指示模块是否已经成功注册到网络并建立了数据连接。如果DCD信号处于激活状态（通常是低电平），则表示已经成功连接到网络；反之，则表示未连接。</p></li><li><p><strong>数据传输状态指示：</strong><br> 在数据通信中，DCD信号也可能被用来指示当前是否有正在进行的数据传输。例如，当有数据在通过4G链路传输时，DCD信号可能会被拉低或拉高，表示链路上有活动的数据流。</p></li><li><p><strong>休眠和唤醒控制：</strong><br> 在某些设计中，DCD信号也可能用于控制模块的休眠和唤醒状态。当设备不需要数据通信时，可以通过检测DCD信号来判断是否可以进入低功耗模式，节省能源。</p></li><li><p><strong>诊断和调试用途：</strong><br> 在开发和调试过程中，DCD信号模式可以用作一个诊断工具，用于监控模块的网络连接状态或数据通信状态。</p></li></ol><h3 id="串口配置相关"><a href="#串口配置相关" class="headerlink" title="串口配置相关"></a>串口配置相关</h3><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408190937943.png"><br>实际测试结果<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408190937676.png"><br>设置成921600并保存配置<br>md，寄了<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408190942172.png"></p><h1 id="救砖"><a href="#救砖" class="headerlink" title="救砖"></a>救砖</h1><p>官方Todesk救砖</p>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式软件原神 </tag>
            
            <tag> 4G通信 </tag>
            
            <tag> ATCommand </tag>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器对比</title>
      <link href="/2024/08/15/qian-ru-shi-ruan-jian/hpm/bian-yi-qi-dui-bi/"/>
      <url>/2024/08/15/qian-ru-shi-ruan-jian/hpm/bian-yi-qi-dui-bi/</url>
      
        <content type="html"><![CDATA[<p>gcc编译<img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408152257254.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408152256258.png"><br>Andes没折腾明白，留坑</p>]]></content>
      
      
      
        <tags>
            
            <tag> HPM </tag>
            
            <tag> RISCV </tag>
            
            <tag> 编译器 </tag>
            
            <tag> GCC </tag>
            
            <tag> Andes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-8-15</title>
      <link href="/2024/08/15/za-ji/2024-08-15/"/>
      <url>/2024/08/15/za-ji/2024-08-15/</url>
      
        <content type="html"><![CDATA[<p>一点碎碎念</p><p>没有做出选择也是一种选择，尽管你不想要，你又不是碇真嗣，橙汁了还有一个凌波一个搞基的能给你圆回来。</p><p>大抵之前在语境上太较真了吧，每个人说话都是这样，下意识的以自己的处境作为当时说话的语境，而每个人的处境又不尽相同，意识到了也不太敢去说这个问题，由此造成了误解。也没有必要对每个人说的每句话去较真，没用，最后只是给自己徒增烦恼罢了</p><p>博客还想搞点好看的壁纸捏，目前的还行，但是数量还是太少hhhh，也许好东西就是难找而且数量少吧。</p><p>Mygo算是成功勾起了自己对于编曲的一点执念吧？每次听歌的时候都会忍不住去扒谱，结果只能扒个人声主旋律，和弦直接寄掉<br><del>当时怎么不好好学乐理，这下回旋镖了</del></p><p>我只是在苦苦寻找之前拥有过的东西，像一只没有头的苍蝇，想要知晓后面的航向。</p><pre><code>理解他人，以及为他人做点什么， 那只不过是傲慢罢了</code></pre><p>为什么呢？<br>你觉得你理解了别人，为他做了点什么是为他好，又亦是觉得能够弥补什么，都是处于自身出发的啊。</p><p>别人需要吗？不见得，你理解了他反倒会被倒打一把。你觉得这么做会很好，自己很高兴，但是事情不见得就是这个样子，这是对事实的傲慢。</p><p>犯下的错误真的可以弥补吗？为什么总是要在事情发生了之后才去做点什么呢？当你打算去弥补的时候，是不是暗地在想这样就行了？这确实是对事实的傲慢。</p><p>但是我们通常意识不到，总在想为什么没有人来理解我呢?</p><p>又闲又🗡</p><p>所谓物极必反，不对，不是这句话</p>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPM5301EVKLite 点灯</title>
      <link href="/2024/08/15/qian-ru-shi-ruan-jian/hpm/hpm5301evklite-dian-deng/"/>
      <url>/2024/08/15/qian-ru-shi-ruan-jian/hpm/hpm5301evklite-dian-deng/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> HPM </tag>
            
            <tag> 嵌入式软件原神 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子元器件</title>
      <link href="/2024/08/15/dian-zi-dian-li/dian-zi-yuan-qi-jian/"/>
      <url>/2024/08/15/dian-zi-dian-li/dian-zi-yuan-qi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="保险丝"><a href="#保险丝" class="headerlink" title="保险丝"></a>保险丝</h1><h2 id="跳闸电流"><a href="#跳闸电流" class="headerlink" title="跳闸电流"></a>跳闸电流</h2><p>保险丝的跳闸电流，也称为熔断电流，是指当通过保险丝的电流超过其额定值时，保险丝会熔断，从而中断电路以防止电流过大造成设备或线路损坏的那个电流值。</p><p>保险丝的设计是基于一定的电流和时间特性，通常在电流超过额定值的情况下，保险丝会在一定的时间内熔断。保险丝的额定电流（即保险丝能长期承受而不熔断的电流）和跳闸电流之间通常有一个关系，跳闸电流可能是额定电流的1.1倍到数倍，具体取决于保险丝的类型和应用。</p><p>简单来说，保险丝的跳闸电流就是那个会让保险丝熔断的电流值，超过这个值，保险丝就会动作，切断电路。</p><h2 id="保持电流"><a href="#保持电流" class="headerlink" title="保持电流"></a>保持电流</h2><p>保持电流（Holding Current）是指保险丝或其他类似保护器件在不熔断的情况下能够长期承受的最大电流。它是设备正常工作时通过保护器件的最大电流值，在这个电流值下，保险丝或保护器件能够稳定工作，不会因为过热或其他原因而熔断或断开电路。</p><p>保持电流通常比跳闸电流小，因为跳闸电流是导致保险丝熔断的阈值，而保持电流是设备在正常工作状态下持续流过保险丝的电流，不会引发保险丝熔断。保持电流通常与保险丝的额定电流相近或相等。</p><h1 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h1><h1 id="A和K"><a href="#A和K" class="headerlink" title="A和K"></a>A和K</h1><p>在二极管中，<strong>A</strong>和<strong>K</strong>分别代表二极管的两个引脚，具体如下：</p><ul><li><strong>A（Anode，阳极）</strong>：二极管的阳极，是电流流入二极管的端子。</li><li><strong>K（Cathode，阴极）</strong>：二极管的阴极，是电流流出二极管的端子。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 电子元件原神 </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZYNQ-Core 硬件设计</title>
      <link href="/2024/08/15/dian-zi-dian-li/zynq/zynq-core-ying-jian-she-ji/"/>
      <url>/2024/08/15/dian-zi-dian-li/zynq/zynq-core-ying-jian-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><h1 id="原理图设计"><a href="#原理图设计" class="headerlink" title="原理图设计"></a>原理图设计</h1><h2 id="PS部分"><a href="#PS部分" class="headerlink" title="PS部分"></a>PS部分</h2><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150009030.png"><br>看了下PYNQ，用的50Mhz，不过频率30到六十都行麻<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150011818.png"><br>这两个复位比较有意思<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150009670.png">PYNQ上，PS_POR_B最后给到了PG_ALL，而PS_SRST_B给到了真正的外部复位上。<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150014382.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150028828.png"></p><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150022476.png"></p><blockquote><p>不过这个AR_RST没看懂啊，NC7WZ07P6X是个缓冲器，AR_RST一端给到了排针的外部接口上，但他又接回PS上去了，他的RESET用的是1.8V电压，因为bank501是1.8电压域，但是为啥又接到3.3的电压域的PS引脚上去了?不懂</p></blockquote><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150021628.png"></p><p>需要注意的是，两个RESET分属不同的电压域，PYNQ上，PS_POR_B的电压域是3.3V，而PS_SRST_B的电压域是1.8V<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150018297.png"><br>最后一个PS_MIO_VREF，看图<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150034907.png"><br>接下来是Vivado分配引脚<br><del>Vivado的PS引脚分配不知道咋导出来，直接抄PYNQ</del></p><h2 id="PL部分"><a href="#PL部分" class="headerlink" title="PL部分"></a>PL部分</h2><h3 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h3><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150912323.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408150913193.png"></p><h2 id="上电时序"><a href="#上电时序" class="headerlink" title="上电时序"></a>上电时序</h2><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408251929061.png"><br>PS和PL的电源是完全分离的，不必考虑相互耦合。<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408251929721.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ZYNQ </tag>
            
            <tag> DDR3L </tag>
            
            <tag> 电源上电时序 </tag>
            
            <tag> 高速电路设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAN</title>
      <link href="/2024/08/12/qian-ru-shi-ruan-jian/stm32/can/"/>
      <url>/2024/08/12/qian-ru-shi-ruan-jian/stm32/can/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.st.com.cn/resource/en/reference_manual/rm0090-stm32f405415-stm32f407417-stm32f427437-and-stm32f429439-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">rm0090-stm32f405415-stm32f407417-stm32f427437-and-stm32f429439-advanced-armbased-32bit-mcus-stmicroelectronics.pdf</a><br>DS9405，其实是STM32F429的datasheet<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408191714629.png"></p><h1 id="bxCAN"><a href="#bxCAN" class="headerlink" title="bxCAN"></a>bxCAN</h1><p>以STM32F429IGT6为例</p><h2 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h2><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408121004416.png"><br>CAN1是主CAN，CAN2是从CAN，两者共享64字节的SRAM。</p><h3 id="波特率计算"><a href="#波特率计算" class="headerlink" title="波特率计算"></a>波特率计算</h3><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408121018865.png"><br><del>这时钟树真是tm又臭又长又大</del> 明显俩CAN用APB1的时钟，默认配满45Mhz<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408121009550.png"><br>明显可以得到波特率计算公式，该公式适用于直接填写CubeMX的参数<br>$$<br>BaudRate&#x3D;\frac{f_{APB1}}{Prescaler\cdot(1+t_{BS1}+t_{BS2})}<br>$$<br>以使用SAE J1939标准为例，该标准使用250kbps的波特率，STM32cubeMX配置界面如下所示<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408121046807.png"></p><h1 id="FDCAN"><a href="#FDCAN" class="headerlink" title="FDCAN"></a>FDCAN</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h2 id="波特率配置"><a href="#波特率配置" class="headerlink" title="波特率配置"></a>波特率配置</h2><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408191723590.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408191724188.png"><br>对比了一下跟bxcan的公式计算是相同的</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="中断函数解析"><a href="#中断函数解析" class="headerlink" title="中断函数解析"></a>中断函数解析</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> CAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clion HPM5301lite开发</title>
      <link href="/2024/08/11/qian-ru-shi-ruan-jian/hpm/clion-hpm5301lite-kai-fa/"/>
      <url>/2024/08/11/qian-ru-shi-ruan-jian/hpm/clion-hpm5301lite-kai-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://zhuanlan.zhihu.com/p/564229673">在 CLion 中开发 HPM6000 系列单片机</a></p><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>HPM5301evklite，调试器选用了daplink，但是需要支持jtag调试的，<del>强烈推荐南航无线dap和淘宝无线dap，能调arm和ch32的哪家，我没收他俩广告费</del><br>hpm官方sdk与sdk_env<br><a href="https://github.com/hpmicro">HPMicro Semiconductor Ltd · GitHub</a><br>env自带了toolchain，但是也可以用andes的 ,据说是只有andes的才能发挥RV的全部实力<br><a href="https://github.com/andestech/nds-gnu-toolchain">GitHub - andestech&#x2F;nds-gnu-toolchain: GNU toolchain for AndesCore</a></p><h1 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h1><p>添加环境变量，请忽略下图的GNNRISCV_ToolChain的环境变量，那个已经删掉了<br><img src="https://pic1.zhimg.com/80/v2-33cb49bc41d69bb46a6185715e36f7aa_1440w.png"><br>PS:toolchain的环境变量指向的目录不要带bin，否则编译会有问题<br><img src="https://picx.zhimg.com/80/v2-d3c98237ab6e44aa1d81a638fc7b48ff_1440w.png"><br>工具链在ENV里面带了，填进去就行，最新的13.2<br><img src="https://pica.zhimg.com/80/v2-e0d2738df23660f51b8e4f2401effd94_1440w.png"></p><h1 id="CLion开发"><a href="#CLion开发" class="headerlink" title="CLion开发"></a>CLion开发</h1><p>hpm sdk生成工具在Clion中打开<br>工具链如图<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811120732.png" alt="Pasted image 20240811120732.png"><br>报错<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811120757.png" alt="Pasted image 20240811120757.png"></p><p>加上这个试试<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811120911.png" alt="Pasted image 20240811120911.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811204720.png"><br>成功<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811121056.png" alt="Pasted image 20240811121056.png"></p><p>不过这个目录有点怪啊，我原本以为是直接复制出来一份例程，没成想还是改原来的？<br>这个问题跳转到SDK本地化开发解决。</p><blockquote><p>有个问题，上图的这个编译实际上是不对的，应该在这里设置一下<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811205240.png" alt="Pasted image 20240811205240.png"><br>可执行文件这个把elf文件选上，正常编译结果下图所示，别的型号的片子也差不多<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811205400.png" alt="Pasted image 20240811205400.png"></p></blockquote><h2 id="本地化开发"><a href="#本地化开发" class="headerlink" title="本地化开发"></a>本地化开发</h2><p>本地化开发是依托答辩，建议把sample里面的例程直接复制过来，加上Cmake的参数就行了，跟上面步骤是一样的</p><h1 id="OpenOCD-下载与调试"><a href="#OpenOCD-下载与调试" class="headerlink" title="OpenOCD 下载与调试"></a>OpenOCD 下载与调试</h1><p>openocd必须用HPM的env里面提供的openocd，CLion开发实测不需要将其添加到环境变量中，只需指定即可</p><blockquote><p>一个bug<br>我的实际目录是这样的<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811205939.png" alt="Pasted image 20240811205939.png"></p></blockquote><blockquote><p>但是呢，来看看CLion，<del>没有图了</del>，用人话说就是CLion的这个目录里面看不到这个openocd<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811210041.png" alt="Pasted image 20240811210041.png"> </p></blockquote><p>另外还需要对env_sdk的openocd目录做一点手脚，熟悉openocd的同学们应该能发现实际上env里面这个openocd是不完整的，CLion也会提示找不到scripts&#x2F;board，这个东西实际上在sdk里面<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811210252.png" alt="Pasted image 20240811210252.png"></p><p>所以，要把这些东西复制到env的openocd&#x2F;scripts目录里面<img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811210946.png" alt="Pasted image 20240811210946.png"><br>这个时候CLion应该不会报错了，接下来是编写面板配置文件（.cfg）</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">bindto 0.0.0.0    adapter speed 8000    adapter srst delay 500    adapter driver cmsis-dap    transport select jtag    source [find soc&#x2F;hpm5300.cfg]    flash bank xpi0 hpm_xpi 0x80000000 0x2000000 1 1 $_TARGET0 0xF3000000 0x6 0x1000    proc init_clock &#123;&#125; &#123;      $::_TARGET0 riscv dmi_write 0x39 0xF4002000      $::_TARGET0 riscv dmi_write 0x3C 0x1        $::_TARGET0 riscv dmi_write 0x39 0xF4002000      $::_TARGET0 riscv dmi_write 0x3C 0x2        $::_TARGET0 riscv dmi_write 0x39 0xF4000800      $::_TARGET0 riscv dmi_write 0x3C 0xFFFFFFFF        $::_TARGET0 riscv dmi_write 0x39 0xF4000810      $::_TARGET0 riscv dmi_write 0x3C 0xFFFFFFFF        $::_TARGET0 riscv dmi_write 0x39 0xF4000820      $::_TARGET0 riscv dmi_write 0x3C 0xFFFFFFFF        $::_TARGET0 riscv dmi_write 0x39 0xF4000830      $::_TARGET0 riscv dmi_write 0x3C 0xFFFFFFFF      echo &quot;clocks has been enabled!&quot;  &#125;    $_TARGET0 configure -event reset-init &#123;      init_clock  &#125;    $_TARGET0 configure -event gdb-attach &#123;      reset halt  &#125;    reset_config srst_only<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个实际上是hpm5301evklite.cfg和probe&#x2F;cmsis-dap.cfg的缝合体，<del>以及又加上了一点我自己的屎</del><br>如果你要是用6200evk去开发，就把find soc那句改成hpm6280.cfg，这些文件都在openocd&#x2F;scripts&#x2F;soc里面<br>再把下面的flash相关的东西从board的cfg偷过来就行了。<br>调试起来挺舒服的，不过速度相比较stm32g474-nucelo来说略有一点点卡，<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240811212504.png" alt="Pasted image 20240811212504.png"></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">bindto 0.0.0.0    adapter speed 8000    adapter srst delay 500    adapter driver cmsis-dap    transport select jtag    source [find soc&#x2F;hpm5300.cfg]    source [find board&#x2F;hpm5301evklite.cfg]    reset_config srst_only<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>舒服了，直接调就行了，跟stm32的cfg差不多一个写法</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenOCD </tag>
            
            <tag> Clion </tag>
            
            <tag> HPM </tag>
            
            <tag> DAPLink </tag>
            
            <tag> JTAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XMC7200EEVK-SPI</title>
      <link href="/2024/08/09/qian-ru-shi-ruan-jian/rt-thread/xmc7200evk-spi/"/>
      <url>/2024/08/09/qian-ru-shi-ruan-jian/rt-thread/xmc7200evk-spi/</url>
      
        <content type="html"><![CDATA[<h1 id="BSP修改与SPI配置"><a href="#BSP修改与SPI配置" class="headerlink" title="BSP修改与SPI配置"></a>BSP修改与SPI配置</h1><p>首先在board&#x2F;Kconfig里面加入SPI配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menuconfig BSP_USING_SPI      bool &quot;Enable SPI BUS&quot;      select RT_USING_SPI      default n      if BSP_USING_SPI          menuconfig BSP_USING_SPI0              bool &quot;Enable SPI0 BUS&quot;              default n          menuconfig BSP_USING_SPI3              bool &quot;Enable SPI3 BUS&quot;              default n              if BSP_USING_SPI3                  config BSP_USING_SPI3_SAMPLE                      bool &quot;Enable SPI3 BUS Sample&quot;                      default n              endif          menuconfig BSP_USING_SPI6              bool &quot;Enable SPI6 BUS&quot;              default n      endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408141359940.png"></p><p>然后在menuconfig开启即可，但是需要修改一下drv_spi.c的引脚<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408130926156.png"><br>引脚修改成EVK上对应的引脚即可，我这里用的是Arduino接口上的SPI，也是官方例程使用的SPI。<br>配置与应用代码如下所示。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*   * Copyright (c) 2006-2023, RT-Thread Development Team * * SPDX-License-Identifier: Apache-2.0 * * Change Logs: * Date           Author       Notes * 2024-05-22     LZero        first version *&#x2F;  #include &lt;rtthread.h&gt;  #include &lt;rtdevice.h&gt;  #include &quot;ADIS16467-2.h&quot;    #include &quot;drv_gpio.h&quot;  #include &quot;drv_spi.h&quot;  #include &quot;rtdbg.h&quot;    #define DBG_LVL DBG_    #define LED_PIN     GET_PIN(16, 1)  #define LED2_PIN    GET_PIN(16,2)  rt_thread_t IMU_thread; ADIS16467_T adi_imu &#x3D; &#123;0&#125;;    void SPIRTTEST() &#123;      rt_pin_mode(GET_PIN(10, 3), PIN_MODE_OUTPUT);      rt_kprintf(&quot;IMU Thread Start！\n&quot;);      struct rt_spi_configuration imu_config &#x3D; &#123;              .data_width&#x3D;16,              .mode&#x3D;RT_SPI_MASTER | RT_SPI_MODE_3 | RT_SPI_MSB,              .max_hz&#x3D;1000000      &#125;;  struct rt_spi_device* imu_device &#x3D; (struct rt_spi_device*)rt_malloc(sizeof(struct rt_spi_device));    rt_spi_bus_attach_device_cspin(imu,&quot;spi61&quot;,&quot;spi6&quot;,GET_PIN(10,3),RT_NULL);      struct rt_spi_device *imu &#x3D; (struct rt_spi_device *) rt_device_find(&quot;spi61&quot;);        if (!imu) &#123;          rt_kprintf(&quot;imu not found\n&quot;);      &#125; else &#123;          rt_kprintf(&quot;imu found\n&quot;);      &#125;        rt_spi_configure(imu, &amp;imu_config);      adi_imu.spi_device &#x3D; imu;        ADIS16467_Init(&amp;adi_imu);      ADIS16467_Check(&amp;adi_imu);      ADIS16467_imuInfo(&amp;adi_imu);      rt_kprintf(&quot;IMU ProdID : %X&quot;, adi_imu.ProdId);      rt_pin_mode(LED2_PIN, PIN_MODE_OUTPUT);      while (1) &#123;          rt_pin_write(LED2_PIN, PIN_HIGH);          rt_thread_mdelay(500);          rt_pin_write(LED2_PIN, PIN_LOW);          rt_thread_mdelay(500);      &#125;  &#125;    int main(void) &#123;      spitest &#x3D; rt_thread_create(&quot;spitest&quot;, SPIRTTEST, RT_NULL,                                 RT_MAIN_THREAD_STACK_SIZE, 20, 20);      rt_thread_startup(spitest);      rt_pin_mode(LED_PIN, PIN_MODE_OUTPUT);      rt_kprintf(&quot;Hello World!\n&quot;);      for (;;) &#123;          rt_pin_write(LED_PIN, PIN_HIGH);          rt_thread_mdelay(500);          rt_pin_write(LED_PIN, PIN_LOW);          rt_thread_mdelay(500);      &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><p>原计划使用SPI驱动ADIS16467-2，这是一个ADI的精密陀螺仪，在STM32上已经有完整实现，计划在本次实践中使用XMC7200嵌入RTT官方BSP，但是始终无法驱动起来。sendandsend函数逻分显示是正确的，但是<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810164228.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810164228.png"></p><p>RTT BSP传输波形，不知道为什么会在后面有BA0，发送的是E880。</p><h1 id="波形分析"><a href="#波形分析" class="headerlink" title="波形分析"></a>波形分析</h1><p>使用ST官方HAL库，ADIS16467可正常运行，驱动链接：<a href="https://github.com/WwWangGuan/ADIS16467-2">GitHub - WwWangGuan&#x2F;ADIS16467-2: ADIS16467-2的STM32驱动程序</a><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810191157.png"></p><p>该函数使用的寄存器如图所示<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810191240.png"></p><p>正确的读取数据如下图所示<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810191439.png"></p><p>下图为逻分捕捉波形（rangeModel读取）<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810191415.png"></p><p>即正常波形为：Master发送5E00，从机回答07<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810191607.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810191628.png"></p><p> 接下来是写寄存器<br> <img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810191728.png"></p><p> 此函数的目的是为了在开机时重启陀螺仪（写值0x1000 0000&#x2F;0x80h）<br> <img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810191844.png"></p><p> 那么如何写一个寄存器呢？datasheet这么说<br> <img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810192129.png"><br> <img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810192203.png"></p><p> <img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810200227.png"></p><p> 也就是说 对于每一个16位的数据，写寄存器之前先将最高位置1，然后加上寄存器地址到高八位，低八位是你要写的数据<br> 来看看逻辑分析仪的波形<br> <img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810192726.png"></p><p> 函数实现是这个样子<br> <img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810192502.png"></p><p> 也明显，分成三步：</p><ol><li>地址先或一个0x80h(0x1000 0000)，因为要写寄存器。</li><li>地址左移8位，”或“上你的数据</li><li>开始通信。</li></ol><h2 id="RTThread-SPI设备驱动框架测试"><a href="#RTThread-SPI设备驱动框架测试" class="headerlink" title="RTThread SPI设备驱动框架测试"></a>RTThread SPI设备驱动框架测试</h2><p>上来就没绷住<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810204754.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810204758.png"><br>换用rt_spi_transfer，能发出去了，但是收不到<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810205832.png"><br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810205857.png"><br>跟ST的HAL相比，设备驱动框架无论是transfer，send还是send_and_receive都比HAL慢的多<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408121513515.png"><br>上面有四帧数据，<del>能看出来吗</del><br>感觉是API调的不对，再换。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void ADIS16467_Init(ADIS16467_T *imu) &#123;  &#x2F;&#x2F;    ADI_Write_Reg(imu, GLOB_CMD_REG, 0x80); &#x2F;&#x2F;software reset  &#x2F;&#x2F;    ADI_Write_Reg(imu, GLOB_CMD_REG + 1, 0x80);      uint16_t send[2] &#x3D; &#123;((GLOB_CMD_REG | 0x80) &lt;&lt; 8) | 0x80, (((GLOB_CMD_REG + 1) | 0x80) &lt;&lt; 8) | 0x80&#125;;      uint16_t receive[2] &#x3D; &#123;0&#125;;      rt_spi_send_then_recv(imu-&gt;spi_device, send, 2, receive, 2);      imu-&gt;K_G &#x3D; 40;      imu-&gt;KG_Reciprocal &#x3D; (float) (1 &#x2F; imu-&gt;K_G);      rt_thread_mdelay(2000); &#x2F;&#x2F; wait for reboot  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么写之后的波形是这样的，孩子怪可怜的<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408121533643.png"><br>对比HAL的波形</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void ADIS16467_Init(ADIS16467_T *imu) &#123;      uint16_t send[2] &#x3D; &#123;((GLOB_CMD_REG | 0x80) &lt;&lt; 8) | 0x80, (((GLOB_CMD_REG + 1) | 0x80) &lt;&lt; 8) | 0x80&#125;;      uint16_t receive[2] &#x3D; &#123;0&#125;;      HAL_SPI_TransmitReceive(imu-&gt;hspi, (uint8_t *) send, (uint8_t *) receive, 2, 0xFFFF);     imu-&gt;K_G &#x3D; 40;      imu-&gt;KG_Reciprocal &#x3D; (float) (1 &#x2F; imu-&gt;K_G);      HAL_Delay(4000); &#x2F;&#x2F; wait for reboot  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>波形这个样子<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408121544664.png"><br>能看出来RTT跟HAL的处理方式截然不同，RTT是，我先把TX的东西发完，再收两个<br>但是只有这么写，波形才对，读出来的数据也是正确的</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void ADIS16467_Init(ADIS16467_T *imu) &#123;      ADI_Write_Reg(imu, GLOB_CMD_REG, 0x80); &#x2F;&#x2F;software reset      ADI_Write_Reg(imu, GLOB_CMD_REG + 1, 0x80);      imu-&gt;K_G &#x3D; 40;      imu-&gt;KG_Reciprocal &#x3D; (float) (1 &#x2F; imu-&gt;K_G);      HAL_Delay(4000); &#x2F;&#x2F; wait for reboot  &#125;int8_t ADI_Write_Reg(ADIS16467_T *imu, uint8_t addr, uint8_t value) &#123;      addr |&#x3D; 0x80; &#x2F;&#x2F;写数据的掩码      uint16_t Tx_tmp &#x3D; (addr &lt;&lt; 8) | value;      ADI_flame_TandR(imu, Tx_tmp);      return 0;  &#125;uint16_t ADI_flame_TandR(ADIS16467_T *imu, uint16_t trans) &#123;      HAL_GPIO_WritePin(imu-&gt;GPIOx, imu-&gt;GPIO_PIN, 0);      uint16_t result &#x3D; 0;      static HAL_StatusTypeDef state;      state &#x3D; HAL_SPI_TransmitReceive(imu-&gt;hspi, (uint8_t *) &amp;trans, (uint8_t *) &amp;result, 1, 0xFFFF);      if (state !&#x3D; HAL_OK) &#123;          while (1);      &#125;    HAL_GPIO_WritePin(imu-&gt;GPIOx, imu-&gt;GPIO_PIN, 1);      sb_delay(500);      return result;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就是发一次，停一下再发一次。<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408121543264.png"><br>使用rt_transfer<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408130856658.png"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">uint16_t ADI_flame_TandR(ADIS16467_T *imu, uint16_t trans) &#123;  &#x2F;&#x2F;    HAL_GPIO_WritePin(imu-&gt;GPIOx, imu-&gt;GPIO_PIN, 0);      uint16_t result &#x3D; 0;  &#x2F;&#x2F;    static HAL_StatusTypeDef state;  &#x2F;&#x2F;    state &#x3D; HAL_SPI_TransmitReceive(imu-&gt;hspi, (uint8_t *) &amp;trans, (uint8_t *) &amp;result, 1, 0xFFFF);  &#x2F;&#x2F;    if (state !&#x3D; HAL_OK) &#123;  &#x2F;&#x2F;        while (1);  &#x2F;&#x2F;    &#125;  &#x2F;&#x2F;    HAL_GPIO_WritePin(imu-&gt;GPIOx, imu-&gt;GPIO_PIN, 1);  &#x2F;&#x2F;    rt_spi_send_then_recv(imu-&gt;spi_device, &amp;trans, 1, &amp;result, 1);      rt_spi_transfer(imu-&gt;spi_device, &amp;trans, &amp;result, 1);      return result;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是慢，两次transfer时间相差15ms<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408130858604.png"><br>HAL对比，函数使用HAL_SPI_TransmitReceive，两次传输时间相差39$\mu s$，怪离谱的。<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408130904775.png"><br>尝试提升线程优先级？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main(void) &#123;      spitest &#x3D; rt_thread_create(&quot;spitest&quot;, SPIRTTEST, RT_NULL,                                 4096, 20, 20);      rt_thread_startup(spitest);      &#x2F;* set LED2 pin mode to output *&#x2F;      rt_pin_mode(LED2_PIN, PIN_MODE_OUTPUT);        while (1) &#123;          rt_pin_write(LED2_PIN, PIN_HIGH);          rt_thread_mdelay(500);          rt_pin_write(LED2_PIN, PIN_LOW);          rt_thread_mdelay(500);      &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>priority改成10？试了，没用，这真的慢。<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/202408130914709.png"><br>换用rt_spi_transfer_message，有效</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">uint16_t ADI_flame_TandR(ADIS16467_T *imu, uint16_t trans) &#123;      &#x2F;&#x2F; HAL_GPIO_WritePin(imu-&gt;GPIOx, imu-&gt;GPIO_PIN, 0);      uint16_t result;      struct rt_spi_message msg1,msg2;        msg1.send_buf    &#x3D; &amp;trans;      msg1.recv_buf    &#x3D; &amp;result;      msg1.length      &#x3D; 1;      msg1.cs_take     &#x3D; 1;      msg1.cs_release  &#x3D; 1;      msg1.next        &#x3D; RT_NULL;        rt_spi_transfer_message(imu-&gt;spi_device,&amp;msg1);      &#x2F;&#x2F; rt_spi_transfer(imu-&gt;spi_device,&amp;trans,&amp;result,2);      &#x2F;&#x2F; sb_delay(200);    return result;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取成功<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241011210657.png"><br>接下来console输出加速度和角速度值（rt_krpintf输出浮点数需要安装全功能软件包），但是debug下是好使的<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241011211502.png"><br>串口输出结果<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/20241011211935.png"></p><h1 id="EVK板载QSPI-Flash"><a href="#EVK板载QSPI-Flash" class="headerlink" title="EVK板载QSPI Flash"></a>EVK板载QSPI Flash</h1><p>换用QSPI，更换逻分之后再尝试<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810170117.png"></p><p>原理图如图所示，型号为S25FL512SAGMFMR10，英飞凌自己家的，参数挺好<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810170337.png"></p><p>引脚映射在下图<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810170201.png"></p><p>使用SPI0&#x2F;SPI3模式<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810170802.png"></p><p>支持SFDP，这下好办了，可以直接使用RTT的SFUD<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810171424.png"></p><h2 id="Kconfig文件修改"><a href="#Kconfig文件修改" class="headerlink" title="Kconfig文件修改"></a>Kconfig文件修改</h2><p>添加以下内容<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810171833.png"></p><p>scons重新生成cmakelist之后提示<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810172000.png"></p><p>尝试 pkgs -Update，发现无效<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810172154.png"><br>尝试在menucongfig中启用对应软件包，该软件包对此报错无效，且在HAL中无法找到此文件<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/Pasted%20image%2020240810180618.png"></p><p>问题：有对应的头文件，但是其实现却在drv_flash.c中，疑似官方错误，英飞凌的官方包也没有这个东西，在cmakelist中删除文件后能通过编译，但是AC6编译未能通过。</p>]]></content>
      
      
      
        <tags>
            
            <tag> XMC7200C </tag>
            
            <tag> SPI </tag>
            
            <tag> ADIS16467-2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/08/06/za-ji/gao-qing/"/>
      <url>/2024/08/06/za-ji/gao-qing/</url>
      
        <content type="html"><![CDATA[<p> 超级电容 </p><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p>双向四开关，隔离电源上管常开。</p><h2 id="改进设计"><a href="#改进设计" class="headerlink" title="改进设计"></a>改进设计</h2><p>27211良品率过于抽象<br>栅极驱动器更换 2edkf7275k 隔离栅驱 4&#x2F;8A。<br>ADC 低通滤波 走线太长寄生电容太大只保留了R。<br>缩小体积。<br>HRTIM 中心对齐PWM触发电流采样。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>空载功耗大（更换栅驱之后死区时间调整<br>结构对齐<br>MPS的电源芯片占地太大。<br>REF3033输出电压小于3.3<br>PWM周期与计算周期不一致（晶振 </p><h1 id="FOC"><a href="#FOC" class="headerlink" title="FOC"></a>FOC</h1><h1 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h1><p>开环运动相电压波形不对，周期开始是马鞍波然后三相同时下降，</p><p>TC387-引脚分配，电源复杂，软件难用</p><h1 id="buck-boost"><a href="#buck-boost" class="headerlink" title="buck boost"></a>buck boost</h1><h2 id="损耗来源"><a href="#损耗来源" class="headerlink" title="损耗来源"></a>损耗来源</h2><h3 id="导通损耗"><a href="#导通损耗" class="headerlink" title="导通损耗"></a>导通损耗</h3><h3 id="开关损耗"><a href="#开关损耗" class="headerlink" title="开关损耗"></a>开关损耗</h3><h3 id="死区时间损耗"><a href="#死区时间损耗" class="headerlink" title="死区时间损耗"></a>死区时间损耗</h3><h3 id="芯片电流损耗"><a href="#芯片电流损耗" class="headerlink" title="芯片电流损耗"></a>芯片电流损耗</h3><h3 id="栅极充电损耗"><a href="#栅极充电损耗" class="headerlink" title="栅极充电损耗"></a>栅极充电损耗</h3><h3 id="DCR-ESR损耗"><a href="#DCR-ESR损耗" class="headerlink" title="DCR&#x2F;ESR损耗"></a>DCR&#x2F;ESR损耗</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/13/dian-zi-dian-li/chao-ji-dian-rong/chao-ji-dian-rong/"/>
      <url>/2024/07/13/dian-zi-dian-li/chao-ji-dian-rong/chao-ji-dian-rong/</url>
      
        <content type="html"><![CDATA[<h1 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h1><h2 id="频率和预计不符"><a href="#频率和预计不符" class="headerlink" title="频率和预计不符"></a>频率和预计不符</h2><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/7f4f55e22870bc0a5f81f1f17b560bbe%201.jpg"></p><p><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/fa53768050b12fe9a8910dccfba04658.jpg"></p><p>下图为Tb<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/7f4f55e22870bc0a5f81f1f17b560bbe.jpg"></p><p>结论：傻逼玩应焊个晶振都能焊错。<br>12V 1A 1：1开环 输入12V 0.98A 输出10.58V 0.881A 损耗2.439W。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CheeryDAP源码分析</title>
      <link href="/2024/07/07/qian-ru-shi-ruan-jian/stm32/cheerydap-yuan-ma-fen-xi/"/>
      <url>/2024/07/07/qian-ru-shi-ruan-jian/stm32/cheerydap-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>以STM32 的工程为例，能看出来没有启用RTOS，裸机处理的。<br>首先是DAP的init，主要干了这几件事</p><ol><li>UART_TX&#x2F;RX的Ringbuffer初始化</li><li>DAPdata的默认值初始化</li><li>dapstate的初始化，看了下都是USB的状态机定义？</li><li>CheeryUSB相关初始化（interface和point）</li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> DAPlink </tag>
            
            <tag> CherryDAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高速电路设计进阶</title>
      <link href="/2024/07/06/dian-zi-dian-li/gao-su-dian-lu-she-ji-jin-jie/"/>
      <url>/2024/07/06/dian-zi-dian-li/gao-su-dian-lu-she-ji-jin-jie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>硬件组2023-2024-2 最终考核</title>
      <link href="/2024/06/23/dian-zi-dian-li/ying-jian-zu-kao-he/ying-jian-zu-2023-2024-2-zui-zhong-kao-he/"/>
      <url>/2024/06/23/dian-zi-dian-li/ying-jian-zu-kao-he/ying-jian-zu-2023-2024-2-zui-zhong-kao-he/</url>
      
        <content type="html"><![CDATA[<h2 id="考核须知"><a href="#考核须知" class="headerlink" title="考核须知"></a>考核须知</h2><ol><li>不要直接把喂给<strong>Chatgpt</strong>或者CSDN的答案直接<em><strong>复制粘贴</strong></em>，请让人至少看上去你消化过Chatgpt的答案，用自己的话或者理解去叙述会加分。</li><li>答案配图是个好习惯，交md&#x2F;pdf会更好。</li><li>开卷就是让大家去网上寻找解决问题的方法，即使最终你没有解决出来这个问题，请体现出来你为了解决这个问题做出了什么程度的努力？（看过并总结<del>（吐槽）</del>文章，不限方法）</li><li>祝大家答题<del>（期末）</del>愉快<del>（喜</del></li></ol><h1 id="考核内容"><a href="#考核内容" class="headerlink" title="考核内容"></a>考核内容</h1><p>现给出一个48V-&gt;24V 10A 的需求，使用MP9929搭建Buck电路<br>自行阅读MP9929 DataSheet， 回答下列问题：</p><ol><li>开关频率靠什么调节？当开关频率是1000Khz时应该如何修改电路？开关频率的高低对电路元件有什么要求或影响？</li><li>栅极驱动电源来自MP9929本身吗？如果不来自于本身，如何利用分立元件搭出符合要求的外部电路？</li><li>电流限制有几个挡位？</li><li>如何调节输出电压？应该如何搭配电阻使得MP9929能够输出24V或19V？（必须使用立创商城有货的电阻）</li><li>Typical Application Ciruits中，$C5$的作用是什么？</li><li>MP9929能够控制的最大输出电压是多少？</li><li>假设目前的开关频率是1KHz，计算电感的感值并挑选合适的电感。（给出公式来源，有推导过程加分）</li><li>如果实际的感值比计算值偏大或偏小，会对电路造成什么影响？</li><li>为什么航模电池上电会打火？如何避免打火？有几种方法？</li><li>假设输出电容的容值组成为：100nF+10uF * 3+470uF ，按照上面计算的感值，计算输出纹波。</li><li>MLCC的实际容值会受到哪些因素的影响？</li><li>如何计算$R_{SENSE}$的大小？为什么用到这个电阻？如何选型？需要注意什么？</li><li>如何挑选一个合适的MOS？MOS的什么参数会影响本身的开关速度？</li><li>在BST上串接电阻的意义是什么？除去串接电阻外有没有其他方式能够达到和串接电阻一样的效果？</li><li>为什么在$Figure 9$的电路中，$R_{SENSE}$被放在了低侧（靠近GND）而非像12V输出时，放在电感和输出电容之间？</li><li>写出Layout 要求，并尝试绘制原理图和PCB。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件组 </tag>
            
            <tag> 原神 </tag>
            
            <tag> RoboMaster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>芯原杯IDE替换测试</title>
      <link href="/2024/06/08/qian-ru-shi-ruan-jian/xin-yuan-bei/xin-yuan-bei-ide-ti-huan-ce-shi/"/>
      <url>/2024/06/08/qian-ru-shi-ruan-jian/xin-yuan-bei/xin-yuan-bei-ide-ti-huan-ce-shi/</url>
      
        <content type="html"><![CDATA[<p>省流：能代码补全，编译结果有问题，CLion的远程调试能接上qemu，但是程序都似了有没有什么用，建议ntr开发，Clion写代码Esclipse编译Debug。</p><h1 id="为什么要做IDE替换"><a href="#为什么要做IDE替换" class="headerlink" title="为什么要做IDE替换"></a>为什么要做IDE替换</h1><p>众所周知，基于Eclipse开发的嵌入式IDE，像Ti的CCS，英飞凌的ADS，瑞萨(<del>史中史</del>) ，以及ST的STM32CubeIDE，虽然厂商做了一定程度上的支持，但是用起来非常的一眼难尽。<br><img src="https://picx.zhimg.com/80/v2-9d8193126d77f9575c62e1a8440fd370_1440w.png"><br>而STM32早已支持Cmake与Clion搭配进行项目配置与开发，开发体验有了质的提升，因此，<em><strong>我想探索一种通用性的解决办法，即Eclipse在编译时生成的Makefile文件进行逆推导得到Cmakelist，进而能够搭配代码开发体验较好的IDE进行开发编译与调试。</strong></em><br>需要提醒的是，在撰写本文时，虽然能够得到编译成功的结果，但是与Eclipse编译结果不同，仍然在解决中，但是可以将Clion作为代码编辑器进行代码编写，在Eclipse进行编译运行与调试。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>Nuclei Studio IDE for C&#x2F;C++ Developers<br>Version: 2024-02.DEV<br>ToolChain来自Nuclei IDE自带的编译器，路径如图所示，就是在芯原官方提供的压缩包的toolchain文件夹内。<br><img src="https://pic1.zhimg.com/80/v2-c0bd065f7dc4ec399a60089a9d7b5f00_1440w.png"></p><p>使用工程如图所示，实际上就是官方提供的sdk工程,我把doc文件夹删除了。<br><img src="https://picx.zhimg.com/80/v2-b7c0585a82e5e68ff61bcde37ca98eb8_1440w.png"><br><img src="https://pica.zhimg.com/80/v2-02050e38c71f0557d74709fa86c9b3d0_1440w.png"></p><h1 id="替换开发步骤"><a href="#替换开发步骤" class="headerlink" title="替换开发步骤"></a>替换开发步骤</h1><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p><img src="https://pic1.zhimg.com/80/v2-c0bd065f7dc4ec399a60089a9d7b5f00_1440w.png"><br>IDE解压完成后，将NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin添加到系统环境变量PATH中，别管gcc13，那是个空文件夹。<br><img src="https://picx.zhimg.com/80/v2-7e2bee2fddca204771876edb3b0b8cee_1440w.png"><br>我这里把qemu加进去的原因是，原来是在qemu上运行程序的，我想着一起移植到CLion上（<del>但是似了</del>）<br>在终端中确认环境变量是否添加成功，运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">riscv64-unknown-elf-gcc -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果成功添加了应该会出现下图这样<br><img src="https://pica.zhimg.com/80/v2-1d30dc50f6f5d8c09fd9d035c10ad504_1440w.png"></p><h2 id="Clion项目配置"><a href="#Clion项目配置" class="headerlink" title="Clion项目配置"></a>Clion项目配置</h2><p>具体的工程我已经上传到github，仓库地址<a href="https://github.com/WwWangGuan/VeriTest">GitHub - WwWangGuan&#x2F;VeriTest: 芯原杯对原有基于Esclipe IDE用CMake替换的测试工程</a><br><img src="https://picx.zhimg.com/80/v2-e49322cff1eca8876b7acab2a014b769_1440w.png"></p><h3 id="工具链配置"><a href="#工具链配置" class="headerlink" title="工具链配置"></a>工具链配置</h3><p><img src="https://pic1.zhimg.com/80/v2-2e41cf8b0f99f35857344c1b33a5f835_1440w.png"></p><p>直接新建一个工具链就好，C&#x2F;C++编译器指定到原来Eclipse的编译器，gdb是我自认为应该加上去的，准确性未知。<br>但是，需要在Cmake的选项卡中指定一下工具链，这样CLion才会用新添加的工具链<br><img src="https://picx.zhimg.com/80/v2-fa47f635b53309b1c9c54a0230dbfd2d_1440w.png"><br>Q：为啥用Release？<br>A：他原来就用的Release。<br>PS：勾上图里的那个选项开发体验有巨大提升。</p><h3 id="Cmakelist-txt"><a href="#Cmakelist-txt" class="headerlink" title="Cmakelist.txt"></a>Cmakelist.txt</h3><p>重头戏来了（太折磨了）</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">cmake_minimum_required(VERSION 3.25)    # 指定交叉编译工具链  set(CMAKE_SYSTEM_NAME Generic)  set(CMAKE_SYSTEM_VERSION 1)  # 项目信息  project(qemu C CXX ASM)  set(CMAKE_CXX_STANDARD 17)  set(CMAKE_C_STANDARD 11)    set(CMAKE_C_COMPILER riscv64-unknown-elf-gcc)  set(CMAKE_CXX_COMPILER riscv64-unknown-elf-g++)  set(CMAKE_ASM_COMPILER riscv64-unknown-elf-gcc)  set(CMAKE_AR riscv64-unknown-elf-ar)  set(CMAKE_OBJCOPY riscv64-unknown-elf-objcopy)  set(CMAKE_OBJDUMP riscv64-unknown-elf-objdump)  set(SIZE riscv64-unknown-elf-size)  set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)    # 包含目录  include_directories(          galaxy_sdk&#x2F;bsp&#x2F;include          galaxy_sdk&#x2F;bsp&#x2F;include&#x2F;arch&#x2F;riscv&#x2F;n309        galaxy_sdk&#x2F;config&#x2F;include        galaxy_sdk&#x2F;drivers&#x2F;include        galaxy_sdk&#x2F;modules&#x2F;include        galaxy_sdk&#x2F;modules&#x2F;external&#x2F;riscv_dsp&#x2F;include        galaxy_sdk&#x2F;os&#x2F;include        galaxy_sdk&#x2F;osal&#x2F;include        galaxy_sdk&#x2F;prebuilts&#x2F;bluetooth&#x2F;health&#x2F;include        galaxy_sdk)    # 添加所有源文件  file(GLOB_RECURSE SOURCES &quot;galaxy_sdk&#x2F;bsp&#x2F;src&#x2F;*.*&quot;          &quot;galaxy_sdk&#x2F;drivers&#x2F;src&#x2F;*.*&quot;        &quot;galaxy_sdk&#x2F;src&#x2F;*.*&quot;        &quot;galaxy_sdk&#x2F;*.*&quot;)    # 链接器脚本  set(LINKER_SCRIPT $&#123;CMAKE_SOURCE_DIR&#125;&#x2F;galaxy_sdk&#x2F;n309_iot_qemu.ld)    # 通用编译选项  set(COMMON_FLAGS &quot;-march&#x3D;rv32imafc_xxldsp -mabi&#x3D;ilp32f -mtune&#x3D;nuclei-300-series -mcmodel&#x3D;medlow -mno-save-restore -O2 -ffunction-sections -fdata-sections -fno-common -Wall -Werror -g&quot;)  set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; $&#123;COMMON_FLAGS&#125;&quot;)  set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;COMMON_FLAGS&#125;&quot;)  set(CMAKE_ASM_FLAGS &quot;$&#123;CMAKE_ASM_FLAGS&#125; $&#123;COMMON_FLAGS&#125; -x assembler-with-cpp&quot;)    # 链接选项  add_link_options(          -T $&#123;LINKER_SCRIPT&#125;          -nostartfiles          -Xlinker --gc-sections        -Wl,-Map&#x3D;$&#123;CMAKE_BINARY_DIR&#125;&#x2F;qemu.map          -Wl,--no-warn-rwx-segments)    # 设置库目录  link_directories(          galaxy_sdk&#x2F;bsp&#x2F;lib          galaxy_sdk&#x2F;drivers&#x2F;lib        galaxy_sdk&#x2F;modules&#x2F;lib        galaxy_sdk&#x2F;modules&#x2F;external&#x2F;riscv_dsp        galaxy_sdk&#x2F;os&#x2F;lib        galaxy_sdk&#x2F;osal&#x2F;lib        galaxy_sdk&#x2F;prebuilts&#x2F;bluetooth&#x2F;health)    # 添加可执行文件  add_executable($&#123;PROJECT_NAME&#125;.out $&#123;SOURCES&#125;)    # 特定文件类型的编译选项  foreach(source IN LISTS SOURCES)      if (source MATCHES &quot;\\.S$&quot;)          set_source_files_properties($&#123;source&#125; PROPERTIES COMPILE_FLAGS &quot;$&#123;CMAKE_ASM_FLAGS&#125;&quot;)      endif()  endforeach()    # 链接库  target_link_libraries($&#123;PROJECT_NAME&#125;.out          -Wl,--start-group        c_nano               gcc        stdc++        semihost        osal_riscv        os_riscv        bsp_riscv        driver_riscv        common_riscv        ble        nmsis_dsp_rv32imafc_xxldsp        -Wl,--end-group)    # 生成HEX文件  add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.out POST_BUILD          COMMAND $&#123;CMAKE_OBJCOPY&#125; -O ihex $&#123;PROJECT_NAME&#125;.out $&#123;PROJECT_NAME&#125;.hex          COMMENT &quot;Building $&#123;PROJECT_NAME&#125;.hex&quot;  )    # 生成列表文件  add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.out POST_BUILD          COMMAND $&#123;CMAKE_OBJDUMP&#125; --source --all-headers --demangle --line-numbers --wide $&#123;PROJECT_NAME&#125;.out &gt; $&#123;PROJECT_NAME&#125;.lst          COMMENT &quot;Building $&#123;PROJECT_NAME&#125;.lst&quot;  )    # 打印尺寸  add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.out POST_BUILD          COMMAND $&#123;SIZE&#125; --format&#x3D;berkeley $&#123;PROJECT_NAME&#125;.out &gt; $&#123;PROJECT_NAME&#125;.siz          COMMENT &quot;Building $&#123;PROJECT_NAME&#125;.siz&quot;  )  # 打印内存使用情况  add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.out POST_BUILD          COMMAND $&#123;SIZE&#125; $&#123;PROJECT_NAME&#125;.out          COMMENT &quot;Memory usage:&quot;  )    # 清理命令  add_custom_target(clean_all          COMMAND $&#123;CMAKE_COMMAND&#125; -E rm -rf $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.o $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.d $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.out $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.hex $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.lst $&#123;CMAKE_BINARY_DIR&#125;&#x2F;*.siz          COMMENT &quot;Cleaning up generated files&quot;  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="几个需要强调的地方"><a href="#几个需要强调的地方" class="headerlink" title="几个需要强调的地方"></a>几个需要强调的地方</h4><p><del>1. 我这里是手动指定了编译器的位置，因为我测试的时候发现即使我添加了环境变量Cmake仍然识别不到</del><br>byd，又好使了</p><ol><li>项目信息看个人，要不要改随意，在第7行改就可以。</li><li>官方给的都是.a，链接的时候有顺序问题，我这里抄了一下原来的makefile，加上了-Wl,–start-group 和-Wl,–end-group ，让编译器自己找链接顺序。</li><li>如果需要添加新文件夹，添加方式和STM32的方式相同。</li></ol><h3 id="配置效果"><a href="#配置效果" class="headerlink" title="配置效果"></a>配置效果</h3><p>如果准确无误，应该会有如下信息（Cmake）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">C:\Users\34789\AppData\Local\Programs\CLion\bin\cmake\win\x64\bin\cmake.exe -DCMAKE_BUILD_TYPE&#x3D;Release -DCMAKE_C_COMPILER&#x3D;C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-gcc.exe -DCMAKE_CXX_COMPILER&#x3D;C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-c++.exe -G &quot;MinGW Makefiles&quot; -S G:\VeriSilicon\VeriHealthi_QEMU_SDK.202405_preliminary\VeriHealthi_QEMU_SDK.202405_preliminary\VeriTest -B G:\VeriSilicon\VeriHealthi_QEMU_SDK.202405_preliminary\VeriHealthi_QEMU_SDK.202405_preliminary\VeriTest\cmake-build-release-verisilicon-- The C compiler identification is GNU 13.1.1-- The CXX compiler identification is GNU 13.1.1-- The ASM compiler identification is GNU-- Found assembler: C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-gcc.exe-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-gcc.exe - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: C:&#x2F;Embedded_tools&#x2F;NucleiStudio&#x2F;toolchain&#x2F;gcc&#x2F;bin&#x2F;riscv64-unknown-elf-c++.exe - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Configuring done (1.3s)-- Generating done (0.0s)-- Build files have been written to: G:&#x2F;VeriSilicon&#x2F;VeriHealthi_QEMU_SDK.202405_preliminary&#x2F;VeriHealthi_QEMU_SDK.202405_preliminary&#x2F;VeriTest&#x2F;cmake-build-release-verisilicon[已完成]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://picx.zhimg.com/80/v2-ce4e264a02aaf26dac9eeab5b5ad606f_1440w.png"></p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://picx.zhimg.com/80/v2-ebca35fb7dd940600576cc6480127534_1440w.png"></p><p>愉 快 的 代 码 书 写 体 验（<del>双手指天</del>）</p><h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><p><img src="https://pic1.zhimg.com/80/v2-f0233efd30cc57f321198df0f2433521_1440w.png"></p><p>上图是CLion的编译结果，但是呢，让我们看看原来IDE是啥结果</p><p><img src="https://picx.zhimg.com/80/v2-098c6110c4509d8b4f65e0841992b496_1440w.png"></p><p>不是，哥们，怎么最终程序大小都不一样啊。<br>我试图把CLion编译的qemu.out搬到Esclipe里用，结果直接告诉我QEMU运行不了。<br>这是我写这个文章时候感到最大的挫败点，折腾了半天CLion变成了代码编辑器<del>早知道还不如Vscode来的实在。</del><br>来个大佬教教我咋解决吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cmake </tag>
            
            <tag> Clion </tag>
            
            <tag> RISCV </tag>
            
            <tag> VeriSilicon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA期末复习</title>
      <link href="/2024/05/14/fpga/fpga-qi-mo-fu-xi/"/>
      <url>/2024/05/14/fpga/fpga-qi-mo-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><ol><li>RTL  Register Transfer level</li><li>时序仿真是最接近真实器件运行特性的仿真。</li><li>综合器总是能综合出唯一的电路网表文件。然而，在实际的数字电路设计中，这种说法是不准确的。综合器在将高级设计描述（如HDL代码）转换为门级网表时，可以基于不同的优化目标（如速度、面积、功耗等）和综合策略产生不同的网表结果。同一个功能的电路描述，根据不同的综合约束和目标，可能会被综合成不同的电路网表。因此，综合出的网表文件并不唯一。</li></ol><h1 id="HDL设计风格"><a href="#HDL设计风格" class="headerlink" title="HDL设计风格"></a>HDL设计风格</h1><h2 id="行为级描述"><a href="#行为级描述" class="headerlink" title="行为级描述"></a>行为级描述</h2><h2 id="数据流描述"><a href="#数据流描述" class="headerlink" title="数据流描述"></a>数据流描述</h2><h2 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h2><h3 id="顺序描述语句（Sequential-Statements）"><a href="#顺序描述语句（Sequential-Statements）" class="headerlink" title="顺序描述语句（Sequential Statements）"></a>顺序描述语句（Sequential Statements）</h3><p>顺序描述语句是在进程（process）、函数（function）和过程（procedure）中使用的。这些语句按照书写的顺序执行，类似于软件编程中的顺序执行。<br><em><strong>构造体中的语句是并行执行的</strong>，与书写顺序无关</em></p><h1 id="端口的方向"><a href="#端口的方向" class="headerlink" title="端口的方向"></a>端口的方向</h1><p>in out inout BUFFER</p><p>variable是局部量，只能在process和子程序里面用？<br>子程序是什么？</p><p>&#x2F;&#x3D;是不等于，斜杠向左偏</p><p>基于FPGA&#x2F;CPLD的数字系统设计流程包括：<br>设计输入、综合、适配、仿真、编程下载。<br>设计输入 综合 适配 仿真 下载</p><h1 id="数据建立时间"><a href="#数据建立时间" class="headerlink" title="数据建立时间"></a>数据建立时间</h1><p>在时钟跳变之前数据必须保持稳定无跳边的时间</p><h1 id="数据保持时间"><a href="#数据保持时间" class="headerlink" title="数据保持时间"></a>数据保持时间</h1><p>在时钟跳变之后数据必须保持稳定的时间</p><h1 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h1><p>类书参数说明</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>门控时钟？</li><li>状态机重新复习</li><li>variable singal constant区别与联系</li><li></li></ol><h1 id="基于VHDL的电路设计"><a href="#基于VHDL的电路设计" class="headerlink" title="基于VHDL的电路设计"></a>基于VHDL的电路设计</h1><h2 id="组合逻辑电路：基本门电路、多路选择器、编码器、译码器"><a href="#组合逻辑电路：基本门电路、多路选择器、编码器、译码器" class="headerlink" title="组合逻辑电路：基本门电路、多路选择器、编码器、译码器"></a>组合逻辑电路：基本门电路、多路选择器、编码器、译码器</h2><h2 id="时序逻辑电路：时钟信号的边沿检测、同步复位信号和异步复位信号的描述、计数器、状态机（枚举数据类型、多进程）"><a href="#时序逻辑电路：时钟信号的边沿检测、同步复位信号和异步复位信号的描述、计数器、状态机（枚举数据类型、多进程）" class="headerlink" title="时序逻辑电路：时钟信号的边沿检测、同步复位信号和异步复位信号的描述、计数器、状态机（枚举数据类型、多进程）"></a>时序逻辑电路：时钟信号的边沿检测、同步复位信号和异步复位信号的描述、计数器、状态机（枚举数据类型、多进程）</h2><h2 id="系统设计：任务分析、功能模块划分、分析各个模块之间的联系、利用上述基本模块来实现各个功能模块。"><a href="#系统设计：任务分析、功能模块划分、分析各个模块之间的联系、利用上述基本模块来实现各个功能模块。" class="headerlink" title="系统设计：任务分析、功能模块划分、分析各个模块之间的联系、利用上述基本模块来实现各个功能模块。"></a>系统设计：任务分析、功能模块划分、分析各个模块之间的联系、利用上述基本模块来实现各个功能模块。</h2><h1 id="设计时的其他问题和技巧"><a href="#设计时的其他问题和技巧" class="headerlink" title="设计时的其他问题和技巧"></a>设计时的其他问题和技巧</h1><h2 id="HDL语句的可综合性"><a href="#HDL语句的可综合性" class="headerlink" title="HDL语句的可综合性"></a>HDL语句的可综合性</h2><p>符合HDL语法规范的代码不一定能够综合成对应电路的设计信息<br>除法 变字长的循环语句 无线循环语句</p><h2 id="FPGA的配置问题"><a href="#FPGA的配置问题" class="headerlink" title="FPGA的配置问题"></a>FPGA的配置问题</h2><p>主模式（FPGA主动串行方式） 从模式（FPGA被动方式） JTAG配置方式（ISP）</p><h2 id="设计优化方法（面积优化和速度优化）；"><a href="#设计优化方法（面积优化和速度优化）；" class="headerlink" title="设计优化方法（面积优化和速度优化）；"></a>设计优化方法（面积优化和速度优化）；</h2><h3 id="面积优化"><a href="#面积优化" class="headerlink" title="面积优化"></a>面积优化</h3><ol><li>可以使用更小规模的FPGA器件，节省成本</li><li>为日后升级留下更多资源</li><li>FPGA资源使用过多会导致功耗上升</li><li>FPGA布线资源有限，占用资源过多会影响电路性能</li></ol><h3 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h3><ol><li>流水线设计，时钟周期不得小于数据从输入到输出经过的时间，系统最高频率取决于延时最小的组合逻辑块</li><li>寄存器配平。</li><li>关键路径法（优先使用）</li><li>乒乓操作法</li><li>加法数法</li></ol><h2 id="数据建立和保持时间的要求；"><a href="#数据建立和保持时间的要求；" class="headerlink" title="数据建立和保持时间的要求；"></a>数据建立和保持时间的要求；</h2><h3 id="数据建立时间-1"><a href="#数据建立时间-1" class="headerlink" title="数据建立时间"></a>数据建立时间</h3><p>在时钟跳变之前，数据必须保持稳定的时间</p><h3 id="数据保持时间-1"><a href="#数据保持时间-1" class="headerlink" title="数据保持时间"></a>数据保持时间</h3><p>在时钟跳变之后数据保持稳定的时间</p><p>数据的稳定传输必须同时满足数据建立时间和数据保持时间，应当避开在数据建立时间或在其附近读取数据。</p><h2 id="冒险现象和毛刺消除技术；"><a href="#冒险现象和毛刺消除技术；" class="headerlink" title="冒险现象和毛刺消除技术；"></a>冒险现象和毛刺消除技术；</h2><h3 id="毛刺消除"><a href="#毛刺消除" class="headerlink" title="毛刺消除"></a>毛刺消除</h3><ol><li>延时方式</li><li>逻辑方式</li><li>定时方式<br>分别用两个独立的Timer对输入信号的高低电平的持续时间进行技术，大于某个阈值再输出对应高低电平</li></ol><h2 id="FPGA设计中时钟的种类和不同时钟的特点及优化方法。"><a href="#FPGA设计中时钟的种类和不同时钟的特点及优化方法。" class="headerlink" title="FPGA设计中时钟的种类和不同时钟的特点及优化方法。"></a>FPGA设计中时钟的种类和不同时钟的特点及优化方法。</h2><h3 id="时钟种类"><a href="#时钟种类" class="headerlink" title="时钟种类"></a>时钟种类</h3><ol><li>全局时钟</li><li>门控时钟<br>驱动时钟的逻辑必须只包含一个与门或者一个或门<br>逻辑门的一个输入作为实际的时钟，逻辑门的所有其他输入必须当成地址或者控制线。</li><li>多级逻辑时钟</li><li>行波时钟<br>一个触发器的输出用作另一个触发器的时钟输入</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FOC原理</title>
      <link href="/2024/04/25/dian-zi-dian-li/foc/foc-yuan-li/"/>
      <url>/2024/04/25/dian-zi-dian-li/foc/foc-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在机器人控制领域中，电机是一个重要的组成部分，无论是三轴云台、机械臂还是AGV，电机都在其中起到了动力输出的作用，常规的有刷电机结构简单，在实际工程中有着广泛的应用，但在机器人的运动控制中，有刷电机体现出了其控制精度不高和寿命短的缺陷，因此并未在机器人控制领域中广泛应用，而无刷电机虽然制造成本更高，但是其控制精度、可靠性和寿命会比有刷电机更加优越，被广泛应用在了机器人领域中。</p><p>通常无刷电机分成两个使用场景，第一种的典型应用场景是在无人机上，其转速非常高，对位置或力矩的控制基本没有要求，而另一种则在机器人上，转速通常最大在几百rpm，但是对位置和力矩的控制精度要求非常大，因而在驱动和控制方法上分成了几种不同的派系：</p><ol><li>在高速运动场景下，可以使用无感开环控制，因其对力矩没有要求，可以使用方波进行驱动，这种设计硬件结构十分简单，只需要控制栅极驱动器的通断，换向时只需要判断电机反电动势是否过零点，过零点即可进行换向操作。但这种方法的缺点是低速和启动性能比较差，而且噪声非常大，不适合用在精细控制领域中。</li><li>在低速高精度控制场景下，无刷电机更多采用FOC（Field-Oriented Control）进行控制，FOC被称为磁场导向控制，是一种利用变频器（VFD）控制三相交流电机的技术。这种技术通过调整变频器的输出频率、输出电压的大小及相位，来控制电机的输出。其特性是可以单独控制电机中每个绕组线圈的磁场方向和强度，类似他励式直流电机。由于在FOC算法的方程式中，三相交流电机的定子电流通过两个可视化的正交矢量分量来描述，因此这种控制方法又被称为矢量控制（Vector Control）。FOC方法可用于控制交流感应电机和直流无刷电机。最开始出现这种控制方法，就是为了提高电机的性能。在FOC控制下，电机不仅能在全速范围内平稳运行，以零速度产生额定扭矩，还具备良好的高速动态性能，如能够做到快速地加速或减速。</li></ol><p>因此，FOC的独特速度和力矩性能使得其成为了近些年来最常出现的电机控制算法，了解其对应的控制原理能够更好控制无刷电机，还可将其封装为伺服模块，大大增强了易用性。</p><h1 id="无刷电机原理"><a href="#无刷电机原理" class="headerlink" title="无刷电机原理"></a>无刷电机原理</h1><p>以三相二极内转子电机为例，定子的三相绕组有星形联结方式和三角联结方式，而三相星形联结的二二导通方式最为常用，这里使用该模型做简单讨论：<br><img src="https://pic1.zhimg.com/80/v2-7fb73dac333fecf884c3e8df356ab718_720w.webp"></p><p>如图所示，电机的三个线圈的一头均连接至中心点$O$（中心为转子，是永磁体，未画出），如果此时在AB相上通电，容易根据右手螺旋定则得出此时线圈产生的合磁场方向与$OB$成$30°$角，$N$极指向右下方，而此时，内转子受到磁场作用的力，会使得内转子的永磁铁的磁链和线圈的磁链相垂直。此时电机也就完成了一次$60°$转动，依次类推，分别在三相的两相上一次通电，也就“牵动”电机完成了一次完整旋转。<br><img src="https://pic1.zhimg.com/80/v2-bc0091ec15f7bd19094e890bf3e90418_720w.webp"><br>而我们需要对换向进行操作，则需要栅极驱动器和MOS管。<br><img src="https://pic4.zhimg.com/80/v2-de99d63cac7edac6868bd829ce92685f_720w.webp"><br>上图显示出了需要驱动无刷电机转动的三相逆变电路（图中的功率器件其实是IGBT），通过开关不同的MOS管，就能够实现对不同相和不同方向的通电和断开处理，进而也就实现了无刷电机的转向和换相。</p><p>栅极驱动器，顾名思义，是驱动栅极使得MOS管打开的芯片。<br><img src="https://pic1.zhimg.com/80/v2-56e62c22009e65d2591853bb881d3d63_720w.png"><br>上图是Ti的智能栅极驱动芯片，带上了许多保护功能，如过压保护和过流保护等，但最核心的还是框图中的Gate Driver（栅极驱动器），芯片接收来自控制器的PWM信号，高电平占周期的时长决定了MOS管的开通时长，两个MOS管相连的电路我们称之为半桥电路，如图所示，三相电机的线圈的引头连接至桥臂中央，这也是容易理解的。</p><h1 id="三相电机的旋转波形与驱动波形"><a href="#三相电机的旋转波形与驱动波形" class="headerlink" title="三相电机的旋转波形与驱动波形"></a>三相电机的旋转波形与驱动波形</h1><p>将示波器的探头连接至电机三相中的两相，如果是三通道的则更好，我们最后应该会得到三个正弦曲线，幅值相同而相邻波形相位差为$120°$。<br><img src="https://pic2.zhimg.com/80/v2-420583ae479dc60942af80ec30c0c175_720w.webp"><br>用手去旋转电机，是能够感受到强烈的阻尼感，我们上面的分析表明，转子在磁场中只有六个稳定的状态，因此在整个的旋转过程中是不平滑的，为了解决这个问题，也顺带衍生出了无刷电机中PMSM和BLDC的区别。</p><p>BLDC的解决方式比较直白，既然我转一圈要切换六次，那么就增加电机的极对数，增加的极对数越多，我一圈当中就会切换12次甚至更多，这样“颗粒感”就会变的更小，切换的时间和间距越短，电机的运行效果就越平滑。<br><img src="https://pic1.zhimg.com/80/v2-d77d7004abebc0d667fb9f5c3f862fe6_720w.png"><br>上图是一个极对数为9的无刷电机，但是电机仍然只有三根线在外面。</p><p>但是，即使我们增加了极对数，但是仍然没有解决根本上的问题，因为方波本身是不平滑的，而无刷电机的波形确实正弦波形，那就直接用正弦波去驱动不就行了？没错，这就是PMSM的解决方式，其反电动势被人为设计成正弦波的形状，我们再搭配一些软件和算法，把方波的驱动信号转换被SPWM正弦波或者SVPWM马鞍波，这样就从根本上解决了这个问题，这也就是FOC的实现原理。</p><h1 id="FOC控制原理"><a href="#FOC控制原理" class="headerlink" title="FOC控制原理"></a>FOC控制原理</h1><p>我们先在控制系统的顶层来了解一下控制流程<br><img src="https://pic1.zhimg.com/80/v2-b12a2650b001faa9cd31ecbb309eaca0_720w.webp"><br>上图中是电流闭环控制，也就是恒定力矩模式。整个控制流程是这样的：</p><ol><li>对电机三相电流进行采样得到 $𝐼_𝑎,𝐼_𝑏,𝐼_𝑐$ ​</li><li>将 $𝐼_𝑎,𝐼_𝑏,𝐼_𝑐$ ​​经过$Clark$变换得到​ $𝐼_𝛼,𝐼_𝛽$</li><li>将​ $𝐼_𝛼,𝐼_𝛽$经过$Park变换$得到​ $𝐼_𝑞,𝐼_𝑑$</li><li>计算$​𝐼<em>𝑞,𝐼_𝑑$和其设定值$𝐼</em>{𝑞_{𝑟𝑒𝑓}},𝐼_{d_{𝑟𝑒𝑓}}$,的误差</li><li>将上述误差输入两个PID控制器，得到输出的控制电压​ $𝑈_𝑞,𝑈_𝑑$</li><li>将​$𝑈_𝑞,𝑈_𝑑$进行反Park变换得到​ $𝑈_𝛼,𝑈_𝛽$</li><li>用$𝑈_𝛼,𝑈_𝛽$合成电压空间矢量，输入$SVPWM$模块进行调制，输出该时刻三个半桥的状态编码值（前文有提到）</li><li>按照前面输出的编码值控制三相逆变器的$MOS$管开关，驱动电机</li><li>循环上述步骤</li></ol><h2 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h2><p><img src="https://pic4.zhimg.com/80/v2-de99d63cac7edac6868bd829ce92685f_720w.webp"><br>对于三相电机而言，由KCL很容易得到</p><p>$$<br>I_a+I_b+I_C&#x3D;0<br>$$<br>定义三相坐标系如图所示<br><img src="https://picx.zhimg.com/80/v2-71dd5ef2bce9f8b3531913f2498bdf7d_720w.png"><br>这和我们之前转动电机得到的相位差结果基本一致，但是他有三个轴，分析起来太麻烦了，我们通过定义正交基向量来重新定义一个$\alpha-\beta$坐标系<br>$$<br>\left{\begin{array}{l}<br>I_{\alpha}&#x3D;I_{a}+\cos \left(\frac{2 \pi}{3}\right) I_{b}+\cos \left(\frac{2 \pi}{3}\right) I_{c} \<br>I_{\beta}&#x3D;\sin \left(\frac{2 \pi}{3}\right) I_{b}-\sin \left(\frac{2 \pi}{3}\right) I_{c}<br>\end{array}\right.<br>$$<br>相当于把原来的三个向量投影到坐标轴上，只需要控制两个变量了就能达到原来的效果，但是我们新坐标系下仍然是以正弦方式在做变化的，我们希望把它线性化，这样更容易控制和计算，也就引入了Park变换。</p><h2 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h2><p>为什么上面经过Clark变换的结果是正弦变化的呢？因为电机本身是在旋转的，我们需要消除“旋转”这一特征才能达到线性化的目的。<br>在Park变换中，我们将坐标系逆时针旋转$\theta$°，定义$\theta$为电机转子转过的角度，就像图片的这样。<br><img src="https://picx.zhimg.com/80/v2-000d05e82742dd15d575492dd00b2c07_720w.png"><br>坐标变换的结果仍然是简单的矢量投影，公式如下：<br>$$<br>\left{\begin{array}{l}<br>I_{d}&#x3D;I_{\alpha} \cos (\theta)+I_{\beta} \sin (\theta) \<br>I_{q}&#x3D;-I_{\alpha} \sin (\theta)+I_{\beta} \cos (\theta)<br>\end{array}\right.<br>$$<br>转子转多少度那么$d-q$坐标系就转多少度，因此，“旋转”的特征被消除，我们对电机的控制最后解耦为对$I_d,I_q$的控制，也就可以搭配PID这种线性控制器来控制了。</p><h2 id="PID控制"><a href="#PID控制" class="headerlink" title="PID控制"></a>PID控制</h2><p>FOC控制中主要会用到几个控制环路，分别是电流环，速度环，位置环<br><img src="https://picx.zhimg.com/80/v2-0e858178a22a7adbebbe213b54842a25_720w.png"><br>我们首先讨论电流环，在$d-q$坐标系中，我们讲到在这个坐标系下消除了”旋转“的特征，两个向量对于转子而言分别是径向向量和切向向量，很明显，推动转子旋转的向量就是切向向量，而径向向量是我们不需要的，如果它不为0就会影响效率和力矩，因此我们希望把它控制为0，因此电流环的作用就是使径向电流尽可能为0（0就是控制器的期望），而使切向电流达到期望值。<br><img src="https://pica.zhimg.com/80/v2-421da3a6bda3d28e57ba0169e4138fcb_720w.png"><br>电流环的控制作用到这里就结束了，它负责的东西就这么多。</p><h3 id="速度环和位置环"><a href="#速度环和位置环" class="headerlink" title="速度环和位置环"></a>速度环和位置环</h3><p><img src="https://pic4.zhimg.com/80/v2-3ec15f2e8ab0b97b7818e1d94d9dbd9b_720w.webp"><br>其实在了解电流环之后剩下的两个环不难理解，这里不再赘述。<br>至此整个控制环节基本结束，但是我们注意到电流环的输出线给到了RevPark变换先还原到$\alpha-\beta$坐标系下，但是却没有RevClark变换，而是转到了一个叫做SVPWM的东西，它的输出是三相每一相的电压。</p><h2 id="SVPWM"><a href="#SVPWM" class="headerlink" title="SVPWM"></a>SVPWM</h2><p>全称Space Vector PWM，也是PWM，但是加上了空间电压矢量的前缀，我们首先把SV搞明白。</p><h3 id="Space-Vector"><a href="#Space-Vector" class="headerlink" title="Space Vector"></a>Space Vector</h3><p>我们不妨先把线圈通电，就像图中这样<br><img src="https://pic4.zhimg.com/80/v2-28c5ce7876603e45d61668e290e371e3_720w.webp"><br>我们假设每个线圈的电阻都是相同的，我们可以得到这样一个电路<br><img src="https://pic2.zhimg.com/80/v2-f4cd3936b0c1599086576e4ba5f7f9bd_720w.webp"><br>这是非常简单的一个分压电路，容易计算得出各相的相电压<br>$$<br>\begin{array}{l}<br>U_{a}&#x3D;U_{A}-U_{N}&#x3D;\frac{2}{3} U_{d c} \<br>U_{b}&#x3D;U_{B}-U_{N}&#x3D;-\frac{1}{3} U_{d c} \<br>U_{c}&#x3D;U_{C}-U_{N}&#x3D;-\frac{1}{3} U_{d c}<br>\end{array}<br>$$<br>各相电压的方向是和电流方向相同的，我们规定正方向是指向中心的方向的话，就能得到这么一幅图<br><img src="https://pic2.zhimg.com/80/v2-33a33723f55b80d28efa4d59af68739d_720w.webp"><br>这个合成的向量是$AO$方向的，由右手螺旋定则能看出其$N$朝向下方，而根据我们前面的分析，转子会努力转到这个方向上来，也就是说，SpaceVector代表了转子的方向（或者电机角度），而改变电机转子的角度就需要去改变空间电压矢量的方向，而空间电压矢量本质上来说，是半桥的不同开关状态导致了各相电压的不同，进而影响了空间电压矢量的位置。</p><p>我们定义一个开关函数$S(x)$用来描述半桥开关时的状态<br>$$<br> S(x)&#x3D;\left{<br> \begin{aligned}<br> 1&amp;,上桥臂导通\<br> 0&amp;,下桥臂导通<br>  \end{aligned} \right.<br>$$<br>注意：在一个开关动作中，上下桥臂不能同时开启，同时开启则意味着短路，为此还需要引入死区时间控制来保证这一点。<br>对于三相电机而言，$(S_a,S_b.S_c)$的组合为八个，去掉两个零矢量（0,0,0）和（1,1,1）(去掉的原因是这两个状态线圈时没有电流的，不产生力矩)，剩下的六个空间电压矢量能明显的看出来和之前的六步换向很像。我们如果想让一个空间电压矢量去旋转的任意方向，就需要对六个空间电压矢量去进行合成，也就是SVPMM技术。</p><h2 id="SVPWM-1"><a href="#SVPWM-1" class="headerlink" title="SVPWM"></a>SVPWM</h2><p><img src="https://pic1.zhimg.com/80/v2-1d0392a19bc58c20f2c440d9c06edc8c_720w.webp"><br>为了简便处理，我们不会使用六个矢量去合成，能看到这六个矢量把整个空间分成了六个扇区，我们会首先判断矢量所在扇区的位置，然后用扇区的两个电压矢量去合成扇区内的任意电压矢量，即有<br>$$<br>U_{ref}\cdot\ T&#x3D;U_x \cdot T_x+U_y \cdot T_y+U^*<em>0 \cdot T_0^*<br>$$<br>公式中，$T$是一个PWM周期，$T_x,T_y,T_0^*$都是对应矢量的作用时间，插入零矢量会让空间电压矢量切换的更加顺滑。<br>比如说，我们要在扇区$I$内去合成一个指定角度的空间电压矢量$U</em>{ref}$<br><img src="https://img-blog.csdn.net/20180207132645570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGR1Y29sbGlucw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><p>由正弦定理有<br>$$<br>\frac{\frac{T_6}{T}U_6}{\sin \theta}&#x3D;\frac{\frac{T_4}{T}U_4}{\sin (\frac{\pi}{3}-\theta)}&#x3D;\frac{U_{ref}}{\sin \frac{2\pi}{3}}<br>$$<br>能计算出<br>$$<br>\begin{aligned}<br>T_4&amp;&#x3D;mT\sin(\frac{\pi}{3}-\theta)\<br>T_6&amp;&#x3D;mT\sin\theta<br>\end{aligned}<br>$$<br>剩余时间则分配给零矢量，至此，整个FOC的控制部分就全部结束了，但我们还有一个问题，虽然理论上来说，只要这个电压矢量的时间持续的够长，这六个开关怎么开关都行，但是开关对于MOS是有损耗的，我们希望尽可能减少开关的次数，因此有了下面的切换顺序<br><img src="https://pic1.zhimg.com/80/v2-c69c43d31f65da0ac541be7d03102d10_720w.webp"><br>我们在实际中会把PWM配置成中心对齐模式，在这种开关控制模式下，每一次都只会开关一次，而零矢量被分配在了起始和中间位置，有效降低了开关次数的同时也就降低了PWM的谐波分量。同理也可以列出其他扇区的切换顺序。<br><img src="https://pic1.zhimg.com/80/v2-f5aed28538a791f5e760a0bc66081a9c_720w.webp"><br>至此，整个FOC的九个步骤全部完成.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/14/kong-zhi-li-lun/dong-tai-xi-tong-de-jian-mo-yu-fen-xi/dong-tai-xi-tong-de-jian-mo-yu-fen-xi/"/>
      <url>/2024/04/14/kong-zhi-li-lun/dong-tai-xi-tong-de-jian-mo-yu-fen-xi/dong-tai-xi-tong-de-jian-mo-yu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="拉普拉斯变换"><a href="#拉普拉斯变换" class="headerlink" title="拉普拉斯变换"></a>拉普拉斯变换</h1><p>$$<br>\mathscr{L}[f(x)]&#x3D;F(s)&#x3D;\int_0^\infty f(t)e^{-st}dt&#x3D;\int_0^\infty f(t)e^{-(\sigma +jw)}<br>$$<br>$$<br>\mathscr{L}(e^{-at})&#x3D;\int_0^\infty e^{-(a+s)t}dt &#x3D;\frac{1}{a+s}<br>$$<br>$$<br>\mathscr{L}[af(t)+bg(t)]&#x3D;a\mathscr{L}[f(t)]+b\mathscr{L}[g(t)]<br>$$<br>$$<br>\mathscr{L}[sinat]&#x3D;\int_0^{\infty}\frac{e^{jat}-e^{-jat}}{2j}e^sdt&#x3D;\frac{1}{2j}(\mathscr{L}[e^{jat}]<br>+\mathscr{L}[e^{-jat}])&#x3D;\frac{a}{s^2+a^2}<br>$$<br>$$<br>\mathscr{L}[\frac{df(t)}{dt}]&#x3D;\int_0^{\infty}e^{-s}df(t)&#x3D;sF(s)-F(0)<br>$$<br>$$<br>\mathscr{L}[f(t)*g(t)]&#x3D;F(s)G(s)<br>$$<br>后续不再推导，有时间在补充，拉普拉斯逆变换就是个记公式的过程。</p><h1 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/08/qian-ru-shi-ruan-jian/stm32/rtthread/"/>
      <url>/2024/04/08/qian-ru-shi-ruan-jian/stm32/rtthread/</url>
      
        <content type="html"><![CDATA[<h1 id="线程启动与切换过程详解"><a href="#线程启动与切换过程详解" class="headerlink" title="线程启动与切换过程详解"></a>线程启动与切换过程详解</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/06/qian-ru-shi-ruan-jian/robomaster/2024rmul-fu-pan/"/>
      <url>/2024/04/06/qian-ru-shi-ruan-jian/robomaster/2024rmul-fu-pan/</url>
      
        <content type="html"><![CDATA[<h1 id="不能将就"><a href="#不能将就" class="headerlink" title="不能将就"></a>不能将就</h1><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li>自瞄稳定性不够熟悉，不稳定。</li><li>导航 </li><li>哨兵先不动 需要电控机械配合</li><li>机械臂交给电控</li></ol><h1 id="机械"><a href="#机械" class="headerlink" title="机械"></a>机械</h1><ol><li>人手不够。</li><li>走线设计问题。</li><li>大三同学去留问题。</li><li>文档。</li></ol><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2024/04/03/qian-ru-shi-ruan-jian/stm32/freertos/"/>
      <url>/2024/04/03/qian-ru-shi-ruan-jian/stm32/freertos/</url>
      
        <content type="html"><![CDATA[<h1 id="中断模式和中断事件模式"><a href="#中断模式和中断事件模式" class="headerlink" title="中断模式和中断事件模式"></a>中断模式和中断事件模式</h1><p>两者的区别在于中断的事件模式仅仅会将设备从低功耗条件下唤醒而不执行代码，也就是说，没有ISR。</p><p>byd,osDelay怎么不切换线程。。。</p><h1 id="Kernel-Settings"><a href="#Kernel-Settings" class="headerlink" title="Kernel Settings"></a>Kernel Settings</h1><h2 id="USE-PREEMPTION"><a href="#USE-PREEMPTION" class="headerlink" title="USE_PREEMPTION"></a>USE_PREEMPTION</h2><p>1：抢占式调度器（preemptive a. 抢占的）<br>0：时间片调度（cooperative a. 协作的）<br>USE_PREEMPTION 是 <strong>RTOS 的调度方式选择，为 1 时使用抢占式调度器，为 0 时使用协程</strong>，如果使用抢占式调度器的话内核会在每个时钟节拍中断中进行任务切换，当使用协程的话会在如下地方进行任务切换</p><ol><li>一个任务调用了函数 taskYIELD()。</li><li>一个任务调用了可以使任务进入阻塞态的 API 函数。</li><li>应用程序明确定义了在中断中执行上下文切换。</li></ol><h2 id="CPU-CLOCK-HZ"><a href="#CPU-CLOCK-HZ" class="headerlink" title="CPU_CLOCK_HZ"></a>CPU_CLOCK_HZ</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/29/za-ji/le-yu-zhu-ren-de-hu-gua-yu-lei-feng-you-shi-me-qu-bie/"/>
      <url>/2024/03/29/za-ji/le-yu-zhu-ren-de-hu-gua-yu-lei-feng-you-shi-me-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>胡适所谓乐于助人的行为，大多是资助他人完成学业或者资助好友，比较典型的例子是资助林语堂</p><blockquote><p>在当时，与胡适一同到美国留学的林语堂便是众多贫困子弟中的一个，并且由于家境贫困，即使林语堂在空闲时间全部用于打工赚钱，仍然无法凑齐学费，日常生活也经常是饿一顿饱一顿的。眼看学费自筹无望，担心学校给处分的林语堂求助胡适，希望能够借得资金以供自己读书所需。胡适得知此事，立马给林语堂汇去了一千元美金，为了让他安心，<strong>胡适说这是北京大学预支的薪水，需要毕业后打工还债。</strong><br>林语堂得到钱解了自己的燃眉之急，心中虽然对胡适越俎代庖的做法有所不满，但也无法倒打一耙。林语堂毕业后再次求学深造，学费无助，又向胡适求助，这一次，胡适还说是“北大预支”。到林语堂学有所成，收拾一切回国来到北京大学，准备还当年“欠下的债”，才知道这是胡适当年为了让自己安心而编的谎话。</p></blockquote><p>不管怎么说，尽管上课的时候认为他是一个公知，单单从这个来看，这个人的本性还是不错的，但是资助他人的理由真的是他<strong>愿意去不计后果和利益</strong>而资助吗？我们并不知道，胡适夫人江冬秀评价他：“一生装的像个慈善家”，不知道她在收拾他可怜的存款的时候的自言自语是真的觉得他的丈夫胸怀天下，还是处于别的原因呢？我们无从得知。</p><p>他无疑是一个十分复杂的人，但是我个人更倾向于他本身的善良，他愿意去帮助别人，是他自己的本性，尽管胡适在政治上表现得非常差劲，“非常天真”，政治上的问题和他的善良本性无关。</p><p>对于雷锋而言，这是从小到大听过来的，无疑从现有史实挑不出刺，是过去二十世纪四五十年代典型的忠厚老实的中国人，他真的是从本心出发，愿意去帮助别人。</p><p>所以，我认为，这俩人的乐于助人貌似没什么区别，硬要去分辨的话就只有请他们的好友和史实来判断了。</p><p>参考文献:<br><a href="https://zhuanlan.zhihu.com/p/427291393">胡适去世后江冬秀说他：“一生装得像个慈善家” - 知乎</a><br><a href="https://xingminghu.commons.gc.cuny.edu/etc/hushih/mao_on_hushi/">替胡适恢复名誉 | Xingming Hu | 胡星铭</a><br><a href="https://sd.ifeng.com/zbc/detail_2014_09/19/2930982_0.shtml">胡适最令毛泽东生气的话：他当时水平考不上北大_山东频道_凤凰网</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9B%B7%E9%94%8B">雷锋 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E8%83%A1%E9%81%A9">胡适 - 维基百科，自由的百科全书</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>问题</title>
      <link href="/2024/03/22/za-ji/wen-ti/"/>
      <url>/2024/03/22/za-ji/wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="TVS和ESD的区别，用来防止栅极过冲使用ESD是否可行"><a href="#TVS和ESD的区别，用来防止栅极过冲使用ESD是否可行" class="headerlink" title="TVS和ESD的区别，用来防止栅极过冲使用ESD是否可行"></a>TVS和ESD的区别，用来防止栅极过冲使用ESD是否可行</h1><p><a href="https://zhuanlan.zhihu.com/p/157498935">ESD和TVS管</a><br><strong>国际上习惯将用于静电防护的器材统称为ESD（即TVS管也属于ESD）</strong><br>还是用TVS吧，我害怕。<br>还是没搞明白。</p><h1 id="如何正确使用示波器"><a href="#如何正确使用示波器" class="headerlink" title="如何正确使用示波器"></a>如何正确使用示波器</h1><p>ADI an-1144</p><h1 id="TVS的各类封装及其大小"><a href="#TVS的各类封装及其大小" class="headerlink" title="TVS的各类封装及其大小"></a>TVS的各类封装及其大小</h1><h1 id="PowerGood的指示作用-LED？"><a href="#PowerGood的指示作用-LED？" class="headerlink" title="PowerGood的指示作用 LED？"></a>PowerGood的指示作用 LED？</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>工作记录</title>
      <link href="/2024/03/22/za-ji/gong-zuo-ji-lu/"/>
      <url>/2024/03/22/za-ji/gong-zuo-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="2024-3-22"><a href="#2024-3-22" class="headerlink" title="2024&#x2F;3&#x2F;22"></a>2024&#x2F;3&#x2F;22</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/01/dian-zi-dian-li/roboamaster-kai-fa-ban/ying-jian-fang-an/"/>
      <url>/2024/03/01/dian-zi-dian-li/roboamaster-kai-fa-ban/ying-jian-fang-an/</url>
      
        <content type="html"><![CDATA[<p>主控：STM32F103CBT6<br>锂电池充放电管理：IP5306，带有四颗LED灯指示电量。<br>充电口：MicroUSB<br>气体压力传感器：AGR10系列表压型传感器。<br>运算放大器：OPA376<br>选用3.7V电池或者18560锂电池。<br>ADC读取气压数据<br>IIC与OLED屏幕连接用以显示数据 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/02/18/dian-zi-dian-li/chao-ji-dian-rong/zhuan-li/"/>
      <url>/2024/02/18/dian-zi-dian-li/chao-ji-dian-rong/zhuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="一种基于Type3型补偿器的超级电容组及其控制器"><a href="#一种基于Type3型补偿器的超级电容组及其控制器" class="headerlink" title="一种基于Type3型补偿器的超级电容组及其控制器"></a>一种基于Type3型补偿器的超级电容组及其控制器</h1><h2 id="技术领域"><a href="#技术领域" class="headerlink" title="技术领域"></a>技术领域</h2><p>本发明涉及机器人电池技术领域，特别适用一种基于Type3型补偿器的超级电容组及其控制器</p><h2 id="背景技术"><a href="#背景技术" class="headerlink" title="背景技术"></a>背景技术</h2><h2 id="发明内容"><a href="#发明内容" class="headerlink" title="发明内容"></a>发明内容</h2><p>本专利正是基于现有技术的上述需求而提出的，本专利要解决的技术问题是，在电源输出功率受限制的情况下，给出一种超级电容组及其控制器，能够平滑补偿机器人需要远超出电源输出功率下的应用场景，如紧急功率补充和高峰功率需求等，并利用超级电容的储能能力，实现了多余动能回收利用，提高了电源的使用效率。<br>本专利还利用外置隔离电源的方法使得超级电容控制器的上侧功率管能够常开，降低了功率管的导通损耗，进一步提高了电源使用效率。<br>本专利提供的技术方案包括：超级电容组和超级电容控制器。<br>所述超级电容组包括11个超级电容单体和过压保护电路。<br>进一步地，所述超级电容单体为2.7V，50F，单体之间通过串联形成电容组，理论最大能量2004J，充电至2.65V，最终电压29.15V，理论能量1931.1875J；<br>所述过压保护电路由BW6101超级电容保护芯片及其外围电路组成。<br>所述超级电容控制器包括采集模块，MCU控制模块，通信模块，功率模块和辅助电源模块。<br>所述MCU控制模块对接收的数据进行处理，输出PWM信号控制功率模块调节输出并通过通信模块将必要数据传输至机器人控制系统。<br>所述功率模块为Buck-Boost双向DCDC变换器，包括八个MOSFET功率开关管，一个电感，两个栅极驱动器和一个隔离电源模块。<br>所述通信模块包括CAN通信和UART串口通信，所述MCU控制模块通过所述CAN接口接入机器人CAN总线，与机器人控制系统新型数据交换；所述UART串口通信将与上位机相连接，传输必要调试数据并显示波形帮助调试。<br>所述采集模块包括电压采集模块和电流采集模块，对所述功率模块和超级电容组进行电压和电流采样，并送至所述MCU控制模块的ADC输入通道。<br>所述辅助电源模块包括两个Buck降压DCDC电路，一个LDO降压电路，一个高精度电压基准源和一个隔离电源模块。<br>进一步地。所诉电压采集模块使用运算放大器搭建的采集电路，将采集的电压信号进行缩小。所述运算放大器选用ADI<br>公司的<br>进一步地，所述电流采集模块使用电流感应放大器，型号为德州仪器的INA240。<br>进一步地，所述MCU控制模块包括单片机及其外围电路。所述单片机为ST公司的STM32G474RET6。所述外围电路包括去耦电容，高速外部晶振和复位电路。<br>进一步地，所述CAN通信包括CAN收发器及其外围电路，所述CAN收发器选用TJA1044。所述外围电路包括去耦电容，信号线匹配电阻和CAN终端电阻。<br>进一步地，所述串口通信包括USB转UART芯片及其外围电路，所述USB转UART芯片选用CH340K。所述外围电路包括退耦电容和信号线匹配电阻。<br>进一步地，所述辅助电源模块的LDO降压电路主要为MCU控制模块和高精度电压基准源提供电力，所述Buck降压DCDC电路第一个为24V转12V，为功率模块中的栅极驱动器和辅助电源模块中的隔离电源模块提供电源；第二个Buck降压DCDC电路为24V转5V，为LDO和通信模块中的CAN收发器和USB转UART芯片提供电源。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2024/01/31/dian-zi-dian-li/roboamaster-kai-fa-ban/zhuan-li/"/>
      <url>/2024/01/31/dian-zi-dian-li/roboamaster-kai-fa-ban/zhuan-li/</url>
      
        <content type="html"><![CDATA[<ol><li>发明和实用新型专利申请应提交的文件基本相同，即：请求书、说明书、说明书附图、权利要求书、说明书摘要及摘要附图。但某些发明专利申请可以不提交说明书附图和摘要附图。</li></ol><h1 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h1><ol><li><p>导航路径规划。1</p></li><li><p>超电 1</p></li><li><p>平衡车打滑检测 1</p></li><li><p>平衡车占坑 （？）</p></li><li><p>rtt多线程信息机制（占坑）1</p></li><li><p>机械臂控制系统。1</p></li><li><p>自瞄+CDC？0</p></li><li><p>英雄占坑（RTT电控框架）1<br>18号中期考核 晚上八点</p></li><li><p>发票 预算</p></li><li><p>赞助 优信 3D打印耗材 Polymaker </p></li><li><p>英雄 机械大更新</p></li><li><p>全向轮 裁判系统 </p></li><li><p>完整裁判系统购买（delay）凑平步的</p></li><li><p>哨兵云台 </p></li><li><p>队服</p></li><li><p>开学测无人机电机</p></li><li><p>操作手训练</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CMake</title>
      <link href="/2024/01/30/qian-ru-shi-ruan-jian/cmake/cmake/"/>
      <url>/2024/01/30/qian-ru-shi-ruan-jian/cmake/cmake/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">set(CMAKE_SYSTEM_NAME Generic)  # 指定构建系统为通用系统set(CMAKE_SYSTEM_VERSION 1)  cmake_minimum_required(VERSION 3.26)  # 指定最低CMake版本要求# specify cross-compilers and tools  set(CMAKE_C_COMPILER arm-none-eabi-gcc)  set(CMAKE_CXX_COMPILER arm-none-eabi-g++)  set(CMAKE_ASM_COMPILER arm-none-eabi-gcc)  set(CMAKE_AR arm-none-eabi-ar)  set(CMAKE_OBJCOPY arm-none-eabi-objcopy)  set(CMAKE_OBJDUMP arm-none-eabi-objdump)  set(SIZE arm-none-eabi-size)  set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)    # project settings  project(Competitoin_version C CXX ASM)  set(CMAKE_CXX_STANDARD 17)  set(CMAKE_C_STANDARD 11)    #Uncomment for hardware floating point  add_compile_definitions(ARM_MATH_CM4;ARM_MATH_MATRIX_CHECK;ARM_MATH_ROUNDING)  add_compile_options(-mfloat-abi&#x3D;hard -mfpu&#x3D;fpv4-sp-d16)  add_link_options(-mfloat-abi&#x3D;hard -mfpu&#x3D;fpv4-sp-d16)    #Uncomment for software floating point  #add_compile_options(-mfloat-abi&#x3D;soft)    #add_compile_options(-mcpu&#x3D;cortex-m4 -mthumb -mthumb-interwork)  #add_compile_options(-ffunction-sections -fdata-sections -fno-common -fmessage-length&#x3D;0)    # uncomment to mitigate c++17 absolute addresses warnings  #set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wno-register&quot;)    # Enable assembler files preprocessing  add_compile_options($&lt;$&lt;COMPILE_LANGUAGE:ASM&gt;:-x$&lt;SEMICOLON&gt;assembler-with-cpp&gt;)    if (&quot;$&#123;CMAKE_BUILD_TYPE&#125;&quot; STREQUAL &quot;Release&quot;)      message(STATUS &quot;Maximum optimization for speed&quot;)      add_compile_options(-Ofast)  elseif (&quot;$&#123;CMAKE_BUILD_TYPE&#125;&quot; STREQUAL &quot;RelWithDebInfo&quot;)      message(STATUS &quot;Maximum optimization for speed, debug info included&quot;)      add_compile_options(-Ofast -g)  elseif (&quot;$&#123;CMAKE_BUILD_TYPE&#125;&quot; STREQUAL &quot;MinSizeRel&quot;)      message(STATUS &quot;Maximum optimization for size&quot;)      add_compile_options(-Os)  else ()      message(STATUS &quot;Minimal optimization, debug info included&quot;)      add_compile_options(-Og -g)  endif ()    include_directories(Core&#x2F;Inc      Drivers&#x2F;STM32F4xx_HAL_Driver&#x2F;Inc          Drivers&#x2F;STM32F4xx_HAL_Driver&#x2F;Inc&#x2F;Legacy           Drivers&#x2F;CMSIS&#x2F;Device&#x2F;ST&#x2F;STM32F4xx&#x2F;Include         Drivers&#x2F;CMSIS&#x2F;Include          bsp)    add_definitions(-DDEBUG -DUSE_HAL_DRIVER -DSTM32F411xE)    file(GLOB_RECURSE SOURCES &quot;Core&#x2F;*.*&quot; &quot;Drivers&#x2F;*.*&quot; &quot;bsp&#x2F;*.*&quot;)    set(LINKER_SCRIPT $&#123;CMAKE_SOURCE_DIR&#125;&#x2F;STM32F411CEUX_FLASH.ld)    add_link_options(-Wl,-gc-sections,--print-memory-usage,-Map&#x3D;$&#123;PROJECT_BINAY_DIR&#125;&#x2F;$&#123;PROJECT_NAME&#125;.map)  add_link_options(-mcpu&#x3D;cortex-m4 -mthumb -mthumb-interwork)  add_link_options(-T $&#123;LINKER_SCRIPT&#125;)    add_executable($&#123;PROJECT_NAME&#125;.elf $&#123;SOURCES&#125; $&#123;LINKER_SCRIPT&#125;)    set(HEX_FILE $&#123;PROJECT_BINARY_DIR&#125;&#x2F;$&#123;PROJECT_NAME&#125;.hex)  set(BIN_FILE $&#123;PROJECT_BINARY_DIR&#125;&#x2F;$&#123;PROJECT_NAME&#125;.bin)    add_custom_command(TARGET $&#123;PROJECT_NAME&#125;.elf POST_BUILD          COMMAND $&#123;CMAKE_OBJCOPY&#125; -Oihex $&lt;TARGET_FILE:$&#123;PROJECT_NAME&#125;.elf&gt; $&#123;HEX_FILE&#125;          COMMAND $&#123;CMAKE_OBJCOPY&#125; -Obinary $&lt;TARGET_FILE:$&#123;PROJECT_NAME&#125;.elf&gt; $&#123;BIN_FILE&#125;          COMMENT &quot;Building $&#123;HEX_FILE&#125;  Building $&#123;BIN_FILE&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="语法杂记"><a href="#语法杂记" class="headerlink" title="语法杂记"></a>语法杂记</h1><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p>在CMake中，<code>set()</code> 函数用于定义变量及其值。这是CMake脚本中非常基本和重要的一个功能，用于配置项目构建过程中需要的各种参数。这个函数的基本语法是：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set(VARIABLE_NAME value1 value2 ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，<code>VARIABLE_NAME</code> 是你想要设置的变量的名称，而后面跟着的是一个或多个值，这些值将被赋给这个变量。变量的值可以是字符串、文件路径、布尔值等。</p><p>例如:</p><ul><li><p>设置一个简单的字符串变量：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set(MY_VARIABLE &quot;Hello World&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后可以使用<code>$&#123;MY_VARIABLE&#125;</code>来引用这个值。</p></li><li><p>设置文件或目录路径：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set(SOURCE_FILES main.cpp utils.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里<code>SOURCE_FILES</code> 变量包含了两个源文件的名称。</p></li><li><p>设置一个列表：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set(FILES file1.txt file2.txt file3.txt)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，<code>FILES</code> 变量现在包含了三个文件名的列表。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Cmake </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号与系统</title>
      <link href="/2024/01/25/xin-hao-yu-xi-tong/xin-hao-yu-xi-tong/"/>
      <url>/2024/01/25/xin-hao-yu-xi-tong/xin-hao-yu-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="信号与系统"><a href="#信号与系统" class="headerlink" title="信号与系统"></a>信号与系统</h1><h2 id="1-1-连续时间和离散时间信号"><a href="#1-1-连续时间和离散时间信号" class="headerlink" title="1.1 连续时间和离散时间信号"></a>1.1 连续时间和离散时间信号</h2><p>我们只考虑两种类型的信号，如上所示，前者在自变量的连续值上有定义，而后者只在离散时间点上有定义，为了区分这两类信号，我们用$t$表示连续时间变量，用$n$表示离散时间变量，譬如，$x(t)$是一个连续时间信号，而$x[n]$代表离散时间信号（或者离散时间序列）</p><h3 id="1-1-2-信号能量与功率"><a href="#1-1-2-信号能量与功率" class="headerlink" title="1.1.2 信号能量与功率"></a>1.1.2 信号能量与功率</h3><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><ol><li>周期信号相加最后为周期信号的条件是两周期之比为有理数</li></ol><h1 id="冲激函数性质"><a href="#冲激函数性质" class="headerlink" title="冲激函数性质"></a>冲激函数性质</h1><ol><li>$$<br>f(t)\delta^{\prime}(t)&#x3D;f(0)\delta^{\prime}(t)-f^{\prime}(t)\delta(t)<br> $$<br>$$<br>\epsilon(t)*\epsilon(t)&#x3D;t\epsilon(t  )<br>$$</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>硬件组考核</title>
      <link href="/2023/12/09/dian-zi-dian-li/ying-jian-zu-kao-he/ying-jian-zu-kao-he/"/>
      <url>/2023/12/09/dian-zi-dian-li/ying-jian-zu-kao-he/ying-jian-zu-kao-he/</url>
      
        <content type="html"><![CDATA[<p>自行阅读学习有关Buck电路的相关知识，并阅读MP2315S的DataSheet，对其典型应用电路进行分析，并回答下列问题：</p><ol><li>$R3$的作用是什么？它是怎么影响电源的？</li><li>如何控制开启和关闭芯片？</li><li>什么是前馈电容？</li><li>电感应该如何选型？</li><li>如果有一24V电源输入，我该如何更改电路使其能够输出12V电压？</li><li>如何计算所需电感感值？假设电源输入24V，输出5V3A（选做）</li><li>如果输出电容总计50uF左右，应该选取5个10uF电容还是使用100nF+10uF+22uF+22uF？为什么？</li><li>该电路的Layout要求。</li><li>试给出一使用该芯片的降压电路，电源输入24V，输出5V3A，给出原理图和PCB文件<br>（以上所有问题均可自由在互联网上查找答案，但需指明在何处看到了什么文章，看到了哪句话使你觉得是这个问题的答案。）<br>于周一中午12：00前给出收集问卷，请将答案以pdf文件上传。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栅极驱动器</title>
      <link href="/2023/12/08/dian-zi-dian-li/dc-dc/zha-ji-qu-dong-qi/"/>
      <url>/2023/12/08/dian-zi-dian-li/dc-dc/zha-ji-qu-dong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="栅极电阻作用"><a href="#栅极电阻作用" class="headerlink" title="栅极电阻作用"></a>栅极电阻作用</h1><ol><li>抑制LC震荡，防止$V_{GS}$过大烧坏MOS。</li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> DC-DC </tag>
            
            <tag> 栅极驱动器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/10/16/dian-zi-dian-li/lm5122/lm5122-xue-xi-bi-ji/"/>
      <url>/2023/10/16/dian-zi-dian-li/lm5122/lm5122-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://wv9y1mjo8hb.feishu.cn/space/api/box/stream/download/asynccode/?code=NDdhNzMxNmFlOGZiZTViMmY3YTMxMDFhM2U0MDU4MWRfSGZlOHdocHhLMHNtYmYxS1pvMlkwOXNaMEkxV1ZJTGVfVG9rZW46Vzc4ZWJyWUFab2Z0S254eTBEaGNpUVljbnJkXzE2OTc0NTU0MTI6MTY5NzQ1OTAxMl9WNA"></p><h1 id="引脚解析"><a href="#引脚解析" class="headerlink" title="引脚解析"></a>引脚解析</h1><h2 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h2><p>BST是用来驱动高侧MOS的栅极驱动器电源，连接至外部自举二极管与一个电容，芯片内部有一电荷泵为电容充电用以驱动MOS。</p><h2 id="CSN-CSP"><a href="#CSN-CSP" class="headerlink" title="CSN&#x2F;CSP"></a>CSN&#x2F;CSP</h2><p>本质上是一个运算放大器的同相输入端与反相输入端，其与一个采样电阻相连接用以对输入电流进行采样。</p><h2 id="RES"><a href="#RES" class="headerlink" title="RES"></a>RES</h2><p>打嗝工作模式的选择<br><a href="https://www.eet-china.com/mp/a146201.html">峰值电流模式的过流保护：Hiccup打嗝工作模式</a></p><h2 id="SLOPE"><a href="#SLOPE" class="headerlink" title="SLOPE"></a>SLOPE</h2><p>斜坡补偿调整<br><a href="https://bbs.21dianyuan.com/thread-47567-1-1.html">https://bbs.21dianyuan.com/thread-47567-1-1.html</a></p><h2 id="SYNCIN-RT"><a href="#SYNCIN-RT" class="headerlink" title="SYNCIN&#x2F;RT"></a>SYNCIN&#x2F;RT</h2><p>外部连接一下拉电阻用以调整内部晶振的频率，其频率会影响内部开关频率。</p><h2 id="UVLO"><a href="#UVLO" class="headerlink" title="UVLO"></a>UVLO</h2><p>欠压保护编程引脚</p><p>如果 UVLO 引脚电压低于 0.4V，则调节器处于关闭模式，所有功能被禁用。如果 UVLO 引脚电压高于 0.4V 且低于 1.2V，则调节器处于待机模式，VCC 稳压器工作，HO 和LO 输出端无开关。如果 UVLO 引脚电压高于 1.2V，则启动顺序开始。当 UVLO 超过 1.2V 时，UVLO 引脚上的 A10- μA 电流源启动，并流过外部 UVLO 电阻，以提供迟滞。UVLO 引脚不应悬空。 —DataSheet</p><h2 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h2><p>控制器的工作模式选择，主要是强制PWM模式和二极管仿真模式的切换</p><p><a href="https://e2echina.ti.com/blogs_/b/power_house/posts/buck">https://e2echina.ti.com/blogs_/b/power_house/posts/buck</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/09/21/dian-zi-dian-li/pcb/usb-hub/"/>
      <url>/2023/09/21/dian-zi-dian-li/pcb/usb-hub/</url>
      
        <content type="html"><![CDATA[<p>每一个USB3.1接口有六个数据线，阻抗均为90</p><h1 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h1><p>选用GL3510<br>引脚注意如下</p><ol><li>Pin32 下拉禁用下游端口充电，上拉启用充电</li><li>Pin16 串接一20k电阻下拉</li><li>FN_A、FN_B和FN_C，看上去应该上拉</li><li>3.3V和1.2V供电部分，每一个VP12，AVDD和DVDD连接一个100nF MLCC</li><li>数字供电和模拟供电需要隔离</li><li>VCC供给IC的5V记得滤波</li><li>SSTX需要100nF耦合电容，对称放置，靠近连接器,建议封装0402但必须小于0603</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/09/20/qian-ru-shi-ruan-jian/stm32/an-jian-fifo/"/>
      <url>/2023/09/20/qian-ru-shi-ruan-jian/stm32/an-jian-fifo/</url>
      
        <content type="html"><![CDATA[<p>FIFO是 First Input First Output的缩写，先入先出队列</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记</title>
      <link href="/2023/09/07/dian-zi-dian-li/dc-dc/za-ji/"/>
      <url>/2023/09/07/dian-zi-dian-li/dc-dc/za-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="线性电源"><a href="#线性电源" class="headerlink" title="线性电源"></a>线性电源</h1><p>压降（Dropout Voltage）</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol><li>$V_I$</li><li>$V_O$</li><li>压差</li><li>噪声</li><li>静态电流<br>DCDC和LDO之间需要插入一个磁珠和电容以形成低通滤波器滤除DCDC输出端的高频信号，使得LDO的输入端更纯净<br>设计注意事项<br>输入电容和输出电容要放在紧靠VIN，VOUT和GND的地方<br>IC的电源端口都必须经过电容<br>反馈信号要经过输出电容以后再引出到负载<br>输出侧和输入测的地要在IC处合在一起成为公共点<br>尽量加大焊盘面积<br>反馈组件应该放在靠近IC的地方<br>传统LDO不能并联而电流源型LDO可以</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> DC-DC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Armfly课程笔记</title>
      <link href="/2023/08/14/qian-ru-shi-ruan-jian/stm32/armfly-ke-cheng-bi-ji/"/>
      <url>/2023/08/14/qian-ru-shi-ruan-jian/stm32/armfly-ke-cheng-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="启动文件解析"><a href="#启动文件解析" class="headerlink" title="启动文件解析"></a>启动文件解析</h1><p>堆栈大小</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用通信阻抗要求</title>
      <link href="/2023/08/10/dian-zi-dian-li/layout-yao-qiu/chang-yong-tong-xin-zu-kang-yao-qiu/"/>
      <url>/2023/08/10/dian-zi-dian-li/layout-yao-qiu/chang-yong-tong-xin-zu-kang-yao-qiu/</url>
      
        <content type="html"><![CDATA[<h2 id="USB接口"><a href="#USB接口" class="headerlink" title="USB接口"></a>USB接口</h2><p>是Universal Serial Bus的缩写，即通用串行总线，是一个外部总线标准，用于规范电脑与外部设备的连接和通讯。是应用在PC领域的接口技术。<br>PCB-layout规则：<br>a. 总长度尽量控制在1800mil；<br>b. USB特性阻抗为90Ω,USB3.0的SSTX&#x2F;SSRX极性可交换，长度误差5mil，USB2.0不可交换<br>c. 电源管脚走线宽度≥30mil;<br>d. O_USB_OC[0:3]&#x2F; 阻抗为60 Ω ± 15%。<br>e. ESD器件尽量靠近接口放置。<br>f. 信号长度，要求主板信号长度与底板信号长度之和不超过18inch”。</p><h2 id="VGA接口"><a href="#VGA接口" class="headerlink" title="VGA接口"></a>VGA接口</h2><p>是Video Graphics Array的缩写，即视频图形阵列，具有分辨率高、显示速率快、颜色丰富等优点。VGA接口不但是CRT显示设备的标准接口，同样也是LCD液晶显示设备的标准接口，具有广泛的应用范围。目前台式机的视频接口多是VGA接口。<br>PCB-layout规则：<br>a. 布局：一字形或L形；<br>b. R、G 、B、Hsync和Vsync需要加粗 15mil，做包地处理，隔离层走线。阻抗为75Ω。<br>c. TVS管在布局时，要尽量靠近连接器侧。<br>d. 其余信号阻抗为50Ω。<br>e. VGA_RED、VGA_GRN、VGA_BLU、VGA_HSYNC、VGA_VSYNC为模拟信号，这些模拟信号的地为VGAGND，在地层上要分割出这种地。数字信号和模拟信号要各自布在自己的‘地’的上。布线时把这模拟信号布在TOP层最好，每条信号线用两条各自相应的地线平行夹裹跟随。在这模拟地的上下各信号层不允许布数字信号线。当然上述模拟信号线也不要在数字地上各信号层走线。</p><h2 id="SATA接口"><a href="#SATA接口" class="headerlink" title="SATA接口"></a>SATA接口</h2><p>是Serial ATA的缩写，即串行ATA。它是一种电脑总线，主要功能是用作主板和大量存储设备（如硬盘及光盘驱动器）之间的数据传输。这是一种完全不同于并行PATA的新型硬盘接口类型，由于采用串行方式传输数据而得名。串行接口还具有结构简单、支持热插拔的优点。<br>PCB-layout规则：<br>a. 走线时尽量不打过孔； 最大过孔数为2个，换参考层处150mil内增加连接不同参考层过孔，每个信号对要求一个过孔。<br>b. 注意差分线控制特性阻抗：90Ω；<br>c. 走线时注意邻近地平面走线，不许跨切割，除测点外尽量不要有via,且不可有stub，同时注意立体包地处理。<br>d. Differential pair信号上的耦合电容需放置到SATA conector端且对称放置。<br>e. ESD防护器件紧挨接口放置，后端放置差分线匹配电容。<br>f. 信号长度，要求主板信号长度与底板信号长度之和不超过4inch。</p><h2 id="AUDIO接口"><a href="#AUDIO接口" class="headerlink" title="AUDIO接口"></a>AUDIO接口</h2><p>音频接口,可将计算机、录像机等的音频信号输入进来，通过自带扬声器播放。还可以通过音频输出接口，连接功放、外接喇叭。<br>PCB-layout规则：<br>1.信号线阻抗：65Ω；<br>2.左、右声道（HPL HPR）走线长度≥12mil；<br>3.模拟信号要进行包地处理；<br>4.AGND需铺到插座，同时电源拉最小30mil宽；<br>5.TVS管要尽量靠近端口放置，磁珠要放在TVS管后端。</p><h2 id="RS232接口"><a href="#RS232接口" class="headerlink" title="RS232接口"></a>RS232接口</h2><p>RS232接口简称串口，也称串行通信接口或串行通讯接口（通常指COM接口），是采用串行通信方式的扩展接口。串行接口 （Serial Interface）是指数据一位一位地顺序传送。其特点是通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，但传送速度较慢，且传输距离有限。<br>PCB-layout规则：<br>a. TXD、RXD尽量不要同层平行走线，如果一定要同层，要求间距至少5W以上;<br>b. 输入输出之间不要交叉在一起，用地隔开;<br>c. TVS管紧挨接口放置，之后紧接着放置电容位置，最后面放磁珠，用于滤波。</p><h2 id="HDMI接口"><a href="#HDMI接口" class="headerlink" title="HDMI接口"></a>HDMI接口</h2><p>是High Definition Multimedia Interface的简称，即高清多媒体接口。是一种全数字化视频和声音发送接口，可以发送未压缩的音频及视频信号。HDMI可用于机顶盒、DVD播放机、个人计算机、电视、游戏主机、综合扩大机、数字音响与电视机等设备。HDMI可以同时发送音频和视频信号，由于音频和视频信号采用同一条线材，大大简化系统线路的安装难度。<br>PCB-layout规则：<br>a.差分线阻抗是100Ω；<br>b.ESD器件一定要靠近HDMI端子放置；<br>c.信号线的TVS管要并排放置，不可以一前一后。<br>d.四对差分线之间的间距要保证在15mil以上；<br>e.临近GND层走线。</p><h2 id="DVI接口"><a href="#DVI接口" class="headerlink" title="DVI接口"></a>DVI接口</h2><p>是Digital Visual Interface的简称，即数字视频接口。DVI是基于TMDS(Transition Minimized Differential Signaling，转换最小差分信号)技术来传输数字信号。TMDS运用先进的编码算法把8bit数据(R、G、B中的每路基色信号)通过最小转换编码为10bit数据(包含行场同步信息、时钟信息、数据DE、纠错等)，经过DC平衡后，采用差分信号传输数据，它和LVDS、TTL相比有较好的电磁兼容性能，可以用低成本的专用电缆实现长距离、高质量的数字信号传输。数字视频接口（DVI）是一种国际开放的接口标准，在PC、DVD、高清晰电视（HDTV）、高清晰投影仪等设备上有广泛的应用。<br>PCB-layout规则：<br>1.信号换层时请在距离过孔50mil内增加回流地过孔；<br>2.信号长度最长不超过8000mil；<br>3.每个信号走线不能超过两个过孔；<br>4.信号必须要参考GND层，差分对之间的间距要≥15mil。</p><h2 id="LVDS接口"><a href="#LVDS接口" class="headerlink" title="LVDS接口"></a>LVDS接口</h2><p>是Low Voltage Differential Signaling的简称，即低电压差分信号，又称RS-644总线接口，是20世纪90年代才提出的一种数据传输和接口技术。是一种低摆幅的差分信号技术，它使得信号能在差分PCB线对或平衡电缆上以几百Mbps的速率传输，其低压幅和低电流驱动输出实现了低噪声和低功耗。<br>PCB-layout规则：<br>a. LVDS 输出差分信号走线阻抗 100Ω，走线尽可能等长；<br>b. 100Ω终端电阻尽量靠近LVDS接收器放置，差分信号走线时尽量少用通孔；<br>c. LVDS各输出差分信号通道间隔至少大于2倍S1（一对差分信号正负通道间隔为S1）。</p><h2 id="CAN接口"><a href="#CAN接口" class="headerlink" title="CAN接口"></a>CAN接口</h2><p>是Controller Area Network的简称，即控制器局域网络。CAN 的高性能和可靠性已被认同，并被广泛地应用于工业自动化、船舶、医疗设备、工业设备等方面。现场总线是当今自动化领域技术发展的热点之一，被誉为自动化领域的计算机局域网。它的出现为分布式控制系统实现各节点之间实时、可靠的数据通信提供了强有力的技术支持。<br>PCB-layout规则：<br>1.差分信号线走线等长；<br>2.信号特性阻抗为100Ω；<br>3.CAN总线一般采用“手牵手”式连接、“T”型连接、星型拓扑结构。</p><h2 id="IDE接口"><a href="#IDE接口" class="headerlink" title="IDE接口"></a>IDE接口</h2><p>是Integrated Drive Electronics的缩写，即电子集成驱动器，是把“硬盘控制器”与“盘体”集成在一起的硬盘驱动器。把盘体与控制器集成在一起减少硬盘接口的电缆数目与长度，数据传输的可靠性得到增强，硬盘制造起来变得更容易的技术。但是由于其数据传输速度慢、线缆长度过短、连接设备少以及传输总线数量多等缺点，使得IDE接口已逐渐被淘汰，目前渐渐已被SATA接口代替。<br>PCB-layout规则：<br>a.信号线阻抗特性为50Ω；<br>b. 信号线保持等长走线；<br>c.信号线线宽4mil，间距8mil，同时VIA控制在两个以内，不能跨切割面；<br>d.防护器件TVS管紧贴接口放置。</p><h2 id="网口"><a href="#网口" class="headerlink" title="网口"></a>网口</h2><p>网口可作为两种功能，分为管理网口和以太网网口。对于管理网口而来，可对板卡设备进行在线加载软件大包；对于以太网网口，在其MAC层LINK UP后也可进行在线加载软件大包，同时也可进行数据的传输与交换，速率更快，稳定性好。<br>PCB-layout规则：<br>a. 外壳地与DGND之间的桥接电容要靠近外壳地管脚放置。<br>b. TX+、TX-和RX+、RX-两组差分对之间的间距要≥4W。<br>c. 网络差分特性阻抗为100欧姆。<br>d. 尽量做到差分对之间等长。<br>e. 变压器底部的内层电源&#x2F;地平面需要挖空，且尽量不要走信号线；<br>f. 换参考层处150mil内增加连接不同参考层过孔，每个信号对要求一个过孔。</p><h2 id="PS-2接口"><a href="#PS-2接口" class="headerlink" title="PS&#x2F;2接口"></a>PS&#x2F;2接口</h2><p>PS&#x2F;2是一种鼠标和键盘的专用接口，是一种6针的圆型接口，但键盘只使用其中的4针传输数据和供电，其余2个为空脚。PS&#x2F;2接口的传输速率比COM接口稍快一些，而且是ATX主板的标准接口，是应用最为广泛的键盘接口之一。鼠标是浅绿色接口，键盘是紫色接口，这两个接口不能混插，否则会使其不工作。<br>PCB-layout规则：<br>a.因为速率一般为15KHZ，没有太严苛的走线要求；<br>b.需注意MS_CLK&#x2F;DATA和KB_CLK&#x2F;DATA两组线各自平行走线。</p><p><del>6can2 1can1 裁判系统串口</del></p><p>通常走100hm阻抗<br>隔层参考不需要包地<br>实在不行3W<br>走线尽量远离差分线<br>差分线下的平面尽量完整，否则阻抗不连续会形成干扰。</p><p>同层参考的是同一层的GND，且信号需要包地，线宽要比信号线宽，要打地过孔，成对打。（回流路径最小）<br>必须靠近焊盘<br>过孔和地线一样宽<br>eg：6mil信号线，包地的地线至少7mil<br>阻抗表示方式<br>G&#x2F;5&#x2F;6.1&#x2F;5&#x2F;6.1&#x2F;5&#x2F;G<br>G 地线<br>5  线距<br>6.1 线宽<br>过孔<br>0.4mm<em>0.6mm 走600mA<br>0.3</em>0.5 走300mA</p><p>BGA 0.2*0.4 只能在BGA用，之后全部换成大的<br>最多只能出现两种过孔，最好都用一种</p><p>PCB设计规范 查板单<br>40mil走1A<br>上下拉电阻不能低于8mil</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32H74x(75x)硬件设计规则</title>
      <link href="/2023/07/25/dian-zi-dian-li/stm32h74x-75x-ying-jian-she-ji-gui-ze/"/>
      <url>/2023/07/25/dian-zi-dian-li/stm32h74x-75x-ying-jian-she-ji-gui-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="供电部分"><a href="#供电部分" class="headerlink" title="供电部分"></a>供电部分</h1><p>MCU需要1.71<del>3.6V的工作电压，主$V_{DD}$断电时，由$V_{BAT}$电压（1.2</del>3.6V）供电<br>$V_{BAT}$：1.2~3.6 V：当$V_{DD}$不存在时，为 RTC、外部 32 kHz 振荡器和备份寄存器（通过电源开关）供电。<br>$V_{DD}$:I&#x2F;O引脚和系统模拟部分供电，比如复位、电源管理、振荡器等<br>$V_{DDA}$:用于ADC、DAC、运放、比较器和电压基准供电，这部分供电是独立的。<br>$V_{REF}$:用于模拟外设（ADC&#x2F;DAC）的外部基准电压。<br>$V_{REF}$可连接至$V_{DDA}$。 如果有单独的外部<br>参考电压施加到$V_{REF}$，必须连接一个100nF和一个1uF的电容。<br>在所有情况下，$V_{REF}$ 必须保持低于$V_{DDA}$。<br>当$V_{DDA}$ 高于 2 V 并且使用 ADC 时，$V_{REF}$下限为 2 V，否则为 1.62 V。<br>$V_{DD33USB}$和$V_{DD50USB}$:USB收发器的外部电源。<br>当使用$V_{DD50USB}$供电时，该引脚必须连接到 USB的VBUS 上并外加一个4.7 μF 去耦电容(CIN)。<br>此外、$V_{DD33USB}$ 必须连接到一个 1 μF 的电容，其最大 ESR 应为 600 mΩ。<br>当 $V_{DD33USB}$ 用于为 USB 收发器供电（3.0 至 3.6 V）时，如果$V_{DD50USB}$引脚可用，则必须将$V_{DD33USB}$连接到 $V_{DD50USB}$引脚。<br>如果$V_{DD50USB}$引脚可用，则必须连接到$V_{DD33USB}$，而$V_{DD33USB}$必须连接两个外部去耦电容。必须连接到两个外部去耦电容（一个 100 nF 陶瓷电容和一个1 μF 钽或陶瓷电容）。<br>$V_{DDLDO}$:1.62 至 3.6 V,稳压器的外部电源</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟电子技术</title>
      <link href="/2023/07/13/dian-zi-dian-li/mo-ni-dian-lu/mo-ni-dian-zi-ji-zhu/"/>
      <url>/2023/07/13/dian-zi-dian-li/mo-ni-dian-lu/mo-ni-dian-zi-ji-zhu/</url>
      
        <content type="html"><![CDATA[<p>参考书籍：</p><ol><li>模拟电子技术 第2版：电子工业出版社 (美)Robert L.Boylestad,(美)Louis Nashelsky著</li><li>模拟电子技术基础（第四版）</li><li>新概念模拟电路 杨建国著</li></ol><h1 id="半导体二极管"><a href="#半导体二极管" class="headerlink" title="半导体二极管"></a>半导体二极管</h1><h2 id="半导体基本知识"><a href="#半导体基本知识" class="headerlink" title="半导体基本知识"></a>半导体基本知识</h2><h3 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h3><p>纯净的，具有晶体结构的半导体成为本征半导体。</p><h3 id="本征载流子"><a href="#本征载流子" class="headerlink" title="本征载流子"></a>本征载流子</h3><p>仅由于外部原因引起材料中的自由电子称为本征载流子</p><h3 id="掺杂半导体"><a href="#掺杂半导体" class="headerlink" title="掺杂半导体"></a>掺杂半导体</h3><p>半导体材料可以通过在相对纯净的半导体材料中添加特定的杂质原子来改变其特性，即使只添加千万分之一的杂质。</p><h4 id="N型半导体（电子型半导体）"><a href="#N型半导体（电子型半导体）" class="headerlink" title="N型半导体（电子型半导体）"></a>N型半导体（电子型半导体）</h4><p>N型半导体是向硅（锗）晶体内掺入五价元素杂质（P&#x2F;Sb）而形成的。<br>以磷原子为例，其有五个价电子，与硅原子形成四个共价键后还会多出一个电子，这个剩余的电子与其所属原子间的联系相对松散，只需要外界给予较少的能量就能成为自由电子从而在新构成的N型材料内自由运动。<br>由于磷原子与硅原子在形成4个共价键后还能给出一个电子，故称磷原子为施主原子，磷成为施主杂质或N型杂质，<del>其中N的意义为Negative。</del><br>明显自由电子为多数载流子，空穴为少数载流子。</p><h4 id="P型半导体（空穴型半导体）"><a href="#P型半导体（空穴型半导体）" class="headerlink" title="P型半导体（空穴型半导体）"></a>P型半导体（空穴型半导体）</h4><p>也是向硅晶体内掺杂，但是掺入三价元素（B&#x2F;Ga）。<br>以镓原子为例，其与硅原子形成三个共价键，但是硅原子还剩余一个未成键的自由电子，因此在晶体中形成了空穴，当其相邻共价键上的电子吸收外来能量激发时，就有可能填补上这个空穴，从而在外加电场的作用下形成空穴电流。<br>由于镓原子和硅原子形成三个共价键后，硅原子并没有形成8电子稳定构型，而是形成了空穴，需要从杂质原子的空位中吸收电子，故称镓原子为受主原子。<br>明显空穴为多数载流子，自由电子为少数载流子。</p><h2 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h2><h3 id="偏置电压"><a href="#偏置电压" class="headerlink" title="偏置电压"></a>偏置电压</h3><blockquote><p>偏置是指为得到一定的响应而在设备两端所加的电压，对于二极管而言，偏置电压的正负与其极性相同。</p></blockquote><h3 id="无偏置"><a href="#无偏置" class="headerlink" title="无偏置"></a>无偏置</h3><p>在<strong>无外加电场的情况下</strong>，当N型半导体和P型半导体结合在一起时，由于两种材料的载流子分布数量恰好相反，因此空穴与自由电子会向对方的区域扩散并结合，使得原来P区和N区的电中性被破坏，在交界面附近形成了一个很薄的空间电荷区，或者说形成了一个<strong>内部电场</strong>（并非由外加电压形成的），也叫内联电场。虽然这些离子也带电，但是由于物质结构的原因，它们并不能自由移动，因此他们不导电，因此空间电荷区的电阻率很高<br>在这个区域内，由于多数载流子已经扩散到对方的区域并复合掉，因此此区域也成为<strong>耗尽层</strong>，其实也就形成了一个二极管<br>对于内联电场，P区内电子被夺走显正电性，N区内空穴被中和显负电性，明显它对多数载流子的扩散有阻止作用，阻止作用是两方面的，对于N区域来说，首先要克服耗尽层正离子层的引力，其次还要克服负离子层的阻力，才能够到达P区，因此，此时耗尽层也可看为是一个阻挡层，但是其对少数载流子有加强作用，少数载流子会向对方所在的区域漂移，与扩散作用的运动方向恰好相反。并且参与扩散的多子数目等于参与漂移的少子的数目，从而达到动态平衡，空间电荷区不再发生变化，于是形成了稳定的PN结，对于P区与N区杂质浓度相同时，正负离子区的宽度也相同，称为<strong>对称结</strong>，<br>当两侧杂质浓度不同时，浓度高一侧的离子区宽度低于浓度低的离子区宽度，此时称为<strong>不对称PN结</strong>；但是两种结的外部特性都是相同的，即在<em><strong>半导体二极管两端不施加偏置电压时，在单一方向上的电流为零</strong></em></p><h3 id="反向偏置"><a href="#反向偏置" class="headerlink" title="反向偏置"></a>反向偏置</h3><p><img src="https://pica.zhimg.com/80/v2-b269a241d8f30d69e3799e4c7dd2d53a_1440w.png"><br>当将电压反向加在PN结上（正极接N，负极接P）时，P型半导体中的空穴和N型半导体中的电子被外加电压吸引，使得P型半导体中的负离子和N型半导体中的正离子急剧增多，导致耗尽层加宽，加宽到了多子无法通过耗尽层，如上图所示。<br>但是，外加电场并未影响到少子，少子进入耗尽层的数量仍然不变，与无偏置情况下的数量相同。<br>反向饱和电流用$I_{S}$表示。</p><h3 id="正向偏置"><a href="#正向偏置" class="headerlink" title="正向偏置"></a>正向偏置</h3><p>当讲电压正向加在PN结(正极接P，负极接N)上时，外加电压将会吸引P型半导体的阴离子和N型半导体的阳离子，使得耗尽层变窄。随着外加电压的变大，耗尽层变得更窄，更多的多子可以通过PN结，这将导致电流呈指数级增长。</p><p><del>对于少子而言，耗尽层宽度的下降使得P型半导体中的电子和N型半导体中的空穴流进对方的区域</del></p><h2 id="二极管的一般特性"><a href="#二极管的一般特性" class="headerlink" title="二极管的一般特性"></a>二极管的一般特性</h2><p><img src="https://pic1.zhimg.com/80/v2-609b053bed915f3b0805b2dd6c26ab94_1440w.png"></p><h3 id="一般特性"><a href="#一般特性" class="headerlink" title="一般特性"></a>一般特性</h3><p>我们使用<strong>肖克利方程</strong>来描述半导体二极管的一般特性<br>$$<br>I_{D}&#x3D;I_{S}(e^{\frac{U_D}{nU_T}}-1)<br>$$</p><p>其中，$I_D$是通过二极管的电流,$I_{S}$是反向饱和电流，$U_{D}$是加在二极管上的正偏电压，$n$是影响因子，范围在1~2之间，但除非特殊说明，否则都按1处理。<br>我们定义$U_{T}$是热电压，由下式决定<br>$$<br>U_{T}&#x3D;\frac{kT}{q}<br>$$<br>其中，$k$是玻尔兹曼常数，为$1.38 \times 10^{-23}J&#x2F;K$，T是热力学温度，q是电子的电荷量，为$1.6\times 10^{-19}C$。<br>整理得$$<br>I_D&#x3D;I_S,e^{\frac{qU_D}{kT}}-I_S<br>$$<br>对其分析，明显得：</p><ol><li>$U_D&lt;0$时,当$U_D$趋于负无穷时，$e^{\frac{qU_D}{kT}}$趋于零，此时$I_D$几乎等于$-I_S$，在图中对应反向偏置区域。</li><li>$U_D&gt;0$时，式中的指数部分将快速增长并超过第二部分，图中曲线随者电压的增大而趋向于垂直。<br>但是，在实际的元件中，<strong>反向饱和电流通常会比肖克利方程中的$I_S$大得多</strong>，这是因为一些没有包含在肖克利方程中的因素引起的，譬如耗尽区载流子的产生以及表面漏电流。<br>此外，pn结的接触面积与反向饱和电流的大小有着直接的对应关系。</li></ol><h3 id="齐纳区域"><a href="#齐纳区域" class="headerlink" title="齐纳区域"></a>齐纳区域</h3><p><img src="https://picx.zhimg.com/80/v2-467233537e8ecd41e1923e463311c2e2_1440w.png"></p><h1 id="双极性晶体管（Bipolar-Junction-Transistor）"><a href="#双极性晶体管（Bipolar-Junction-Transistor）" class="headerlink" title="双极性晶体管（Bipolar Junction Transistor）"></a>双极性晶体管（Bipolar Junction Transistor）</h1><p><img src="https://picx.zhimg.com/80/v2-1a992cb541f3ea58c8c348f321e70058_1440w.png"><br>三极管其电路符号如图所示，一共有三个引脚，分别为基极（Base），集电极（Collector）和发射极（Emitter）。<br>注意，带箭头的引脚即为发射极，箭头向外的为NPN型，相反即为PNP型。</p><p>图示右侧给出了等效电路关系，其本质上是一个$CCCS$，对于NPN管，若发射极电流是流出的，则基极和集电极电流是流入的，PNP则相反<br>对于NPN管，我们定义<em><strong>发射结电压</strong></em>为其基极电压与发射级电压之差，即<br>$$<br>u_{BE}&#x3D;u_B-u_E<br>$$<br>此值为正时才能使基极与发射级时导通关系。<br>根据图中给出的等效电路关系，由基尔霍夫定律与受控源规律，我们有：</p><p>$$<br>\begin{equation}\begin{split}<br>i_B+i_C&#x3D;&amp;i_E   \<br>i_C&#x3D;&amp; \beta i_B<br>\end{split}\end{equation}<br>$$<br>其中，$\beta$是电流放大倍数。</p><h2 id="伏安特性曲线"><a href="#伏安特性曲线" class="headerlink" title="伏安特性曲线"></a>伏安特性曲线</h2><h3 id="输入伏安特性"><a href="#输入伏安特性" class="headerlink" title="输入伏安特性"></a>输入伏安特性</h3><p>BJT的输入伏安特性是指其基极电流$i_B$与发射结电压$u_{BE}$的关系，其可能受到$u_{CE}$的影响<br><img src="https://pica.zhimg.com/80/v2-724d9c1d99a20894a799bc19797f0b42_1440w.png"></p><p><img src="https://pica.zhimg.com/80/v2-ae48e0a58305fa6987defe57d5f99148_1440w.png"><br>如图所示，除$u_{CE}&#x3D;$比较特殊外，其余曲线基本重合——称为一簇线，即为晶体管的输入伏安特性，可使用如下表达式近似表述：<br>$$<br>i_B&#x3D;I_S(e^{\frac{u_{BE}}{U_T}}-1)<br>$$<br>其中，$u_T$是热电压，是一个与绝对温度成比值的值，27℃时约为26$mV$,$I_S$是反向饱和电流，虽然每个晶体管的值都不同，但很小，当$u_{BE} \rightarrow +\infty$时，明显$i_B \rightarrow -I_S$。<br>一般的，当$u_{BE}&gt;0.7V$时，基极开始出现较为明显的电流。</p><h3 id="输出伏安特性"><a href="#输出伏安特性" class="headerlink" title="输出伏安特性"></a>输出伏安特性</h3><p>输出伏安特性是指在一个确定的基极电流下，集电极电流$i_C$与$u_{CE}$的关系。<br><img src="https://pic1.zhimg.com/80/v2-858061a0b491dd926f14912dbeb8c9c6_1440w.png"></p><p>在理想情况下，集电极电流应该只与基极电流成正比，但是现实情况是：<br><img src="https://pic1.zhimg.com/80/v2-734d2112d269eb29211b29e5a1aa3958_1440w.png"></p><h4 id="输出区域划分"><a href="#输出区域划分" class="headerlink" title="输出区域划分"></a>输出区域划分</h4><ol><li>放大区<br>在放大区中，图中曲线为微微上翘的平直曲线，在此区域内，集电极电流几乎不受$u_{CE}$控制，近似满足下式：<br>$$<br>i_C&#x3D;\beta i_B<br>$$</li><li>饱和区<br>图中的左侧区域，在此区域内，集电极电流随着$u_{CE}$的增大而增大。<br>我们定义$U_{CES}$为晶体管的饱和压降，是饱和区和放大区的分界电压，一般认为约为0.3V，但显然，随着$i_B$的上升，饱和压降也会上升</li><li>截止区<br>当基极电流为零时，集电极电流并不为零，而是存在与$u_{CE}$相关的漏电流。我们定义$I_B&#x3D;0$时的区域为截止区，其含义为晶体管处于几乎没有电流进出的状态，就像完全关闭一样。</li></ol><h4 id="简化的输出伏安特性"><a href="#简化的输出伏安特性" class="headerlink" title="简化的输出伏安特性"></a>简化的输出伏安特性</h4><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IIC</title>
      <link href="/2023/07/11/qian-ru-shi-ruan-jian/stm32/iic/"/>
      <url>/2023/07/11/qian-ru-shi-ruan-jian/stm32/iic/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>IIC（Inter-Integrated Circuit ,内部集成电路)总线是一种由飞利浦Philip公司开发的串行总线。是两条串行的总线，它由一根数据线（SDA）和一根 时钟线（SDL）组成。I2C总线上可以接多个I2C设备，每个器件都有一个唯一的地址识别。同一时间只能有一个主设备，其他为从设备。通常MCU作为主设备控制，外设作为从设备。<br>IIC通信模式为半双工通信，同一时间只能单向通信。 </p><h1 id="电路组成"><a href="#电路组成" class="headerlink" title="电路组成"></a>电路组成</h1><p>I2C总线为漏极开路结构(OD)，因此它们必须接有上拉电阻,阻值常为4.7K或者10K。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/07/09/dian-zi-dian-li/pcb/pcb-she-ji-gui-ze/"/>
      <url>/2023/07/09/dian-zi-dian-li/pcb/pcb-she-ji-gui-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么信号线要串联电阻"><a href="#为什么信号线要串联电阻" class="headerlink" title="为什么信号线要串联电阻"></a>为什么信号线要串联电阻</h2><p>按键和CPU之间串联的电阻起保护作用。按键肯定是存在机械抖动的，开发板上面的硬件没有做硬件滤波处理，即使设计了硬件滤波电路，软件上还是需要进行滤波。</p><ol><li><p>保护GPIO，避免软件错误将IO设置为输出，如果设置为低电还好，如果设置输出的是高电平，按键按下会直接跟GND(低电平)连接，从而损坏MCU。</p></li><li><p>保护电阻也起到按键隔离作用，这些GPIO可以直接用于其它实验。</p></li><li><p>电源平铺 散热</p></li><li><p>电源走不下 顶层+底层总宽度满足奥求就可以</p></li><li><p>外框包地打过孔[[source&#x2F;_posts&#x2F;控制理论&#x2F;readme]]</p></li><li><p>ME 多线走线</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SuperCap</title>
      <link href="/2023/07/09/dian-zi-dian-li/chao-ji-dian-rong/supercap/"/>
      <url>/2023/07/09/dian-zi-dian-li/chao-ji-dian-rong/supercap/</url>
      
        <content type="html"><![CDATA[<h1 id="超级电容功率控制器"><a href="#超级电容功率控制器" class="headerlink" title="超级电容功率控制器"></a>超级电容功率控制器</h1><h2 id="双向BuckBoost原理"><a href="#双向BuckBoost原理" class="headerlink" title="双向BuckBoost原理"></a>双向BuckBoost原理</h2><p><img src="https://pic1.zhimg.com/80/v2-103cc0c450fc12c4723054bd0efafd4b_1440w.png"><br>其本质上也是Buck-Boost的基本拓补结构<br><img src="https://pic1.zhimg.com/80/v2-6687a142cd61eb44dc30ab01ffdd9e4c_1440w.png"><br>只需将图内续流二极管换成Mos管即可</p><h3 id="Buck模式"><a href="#Buck模式" class="headerlink" title="Buck模式"></a>Buck模式</h3><p>工作在Buck状态下时，Q4导通，Q3截止，Q1、Q2交替开关，也就是变成了经典Buck电路拓补结构<br><img src="https://pica.zhimg.com/80/v2-ca50fe2d1baa11937e1aa7c5e236e5e2_1440w.png"></p><h3 id="Boost模式"><a href="#Boost模式" class="headerlink" title="Boost模式"></a>Boost模式</h3><p><img src="https://picx.zhimg.com/80/v2-9b2c241093b59dcb1c6987d3ef1a4aee_1440w.png"><br>由经典Boost电路不难得出，如果想工作在Boost状态，Q1工作在满占空比状态，Q2常开，Q3、Q4交替开关</p><h3 id="BuckBoost"><a href="#BuckBoost" class="headerlink" title="BuckBoost"></a>BuckBoost</h3><p><del>四开关不就是干这个的吗</del></p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>使用超级电容与裁判系统供电并联的方案，当底盘功率小于限定功率时，电池的剩余功率走buck回路给电容组充电，当所需底盘功率高于限定功率时， 超级电容走Boost回路和裁判系统一起给底盘供电。<br>为了防止电流回灌到裁判系统中，在裁判系统电源输入端串接以理想二极管回路。</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ol><li>如何实现上管MOS工作在满占空比状态，自举升压可能不太行。</li><li>开关频率与电源效率的平衡。</li><li><del>环路带宽？</del></li><li>HRTIM和ADC采样+DMA重点学习。</li><li>元器件选型与电源效率的关系。</li><li>电机电流如果回灌回来能否进行有效利用？</li><li></li></ol><h2 id="超级电容均压板"><a href="#超级电容均压板" class="headerlink" title="超级电容均压板"></a>超级电容均压板</h2><p>计划使用主动均衡电路<br><img src="https://pic1.zhimg.com/80/v2-d973d70449df0612034c47e848c1cba2_1440w.png"><br>如图所示，SC为超级电容，其和一个小电容并联，充电电源和两列电容之间用4个MOS管隔开，充电时，左侧MOS等效为开关闭合，右侧MOS截止，先给小电容充电，随后左侧MOS截止，右侧MOS闭合，小电容给超级电容充电，如此循环往复达到超级电容的主动均压，只需给一个高频PWM即可。</p><h3 id="均压速率影响因素"><a href="#均压速率影响因素" class="headerlink" title="均压速率影响因素"></a>均压速率影响因素</h3><p>有人做过相关Matlab仿真,结果如图所示<br><img src="https://picx.zhimg.com/80/v2-10102bcb9e8165ef687dc9d29c76b7e7_1440w.png"></p><h2 id="BuckBoost-占空比更新逻辑"><a href="#BuckBoost-占空比更新逻辑" class="headerlink" title="BuckBoost 占空比更新逻辑"></a>BuckBoost 占空比更新逻辑</h2><p>参数输入是输出电压和输入电压的比值<br>首先对比值进行限幅处理，不得高于预设的最大值和最小值（1.2 &#x2F;0.1）</p><h1 id="ADC滤波"><a href="#ADC滤波" class="headerlink" title="ADC滤波"></a>ADC滤波</h1>]]></content>
      
      
      <categories>
          
          <category> 超级电容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2023/07/09/xian-xing-dai-shu/xian-xing-dai-shu/"/>
      <url>/2023/07/09/xian-xing-dai-shu/xian-xing-dai-shu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路分析</title>
      <link href="/2023/07/09/dian-zi-dian-li/lm3150mhx/dian-lu-fen-xi/"/>
      <url>/2023/07/09/dian-zi-dian-li/lm3150mhx/dian-lu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><img src="https://pica.zhimg.com/80/v2-31edd6ee23e2deb3d1fc7208c1ea0177_1440w.png"></p><h1 id="芯片引脚分析"><a href="#芯片引脚分析" class="headerlink" title="芯片引脚分析"></a>芯片引脚分析</h1><h2 id="VCC"><a href="#VCC" class="headerlink" title="VCC"></a>VCC</h2><blockquote><p>Nominally regulated to 5.95V. Connect a 1.0 µF to 2.2 µF decoupling capacitor from this pin to ground.</p></blockquote><p>Design Guide要求串联一个容值在1.0uF和2.2uF的电容，可以看到图中C5是一个2.2uF的电容串联接地。</p><h2 id="VIN"><a href="#VIN" class="headerlink" title="VIN"></a>VIN</h2><blockquote><p>Supply pin to the device. Nominal input range is 6V to 42V.</p></blockquote><p>明显此脚接电源输入，电压范围在6V到42V。</p><h2 id="EN"><a href="#EN" class="headerlink" title="EN"></a>EN</h2><blockquote><p>To enable the IC apply a logic high signal to this pin greater than 1.26V typical or leave floating. To disable the part, ground the EN pin.</p></blockquote><p>引脚需要给一个高于1.26V的输入电压来让芯片工作，或者电压保持浮动，原理图上选择串联一个10k电阻。Electrical Characteristic里给出的电压范围是1.14V~1.26V。<br>没找到应该怎么算这个电阻的阻值<del>（<em>还是说整个值仿真一下之后发现行就怼上去了</em>）</del>，Design Guide还要求其工作在开漏状态时应串联一个1000pF的电容（推荐值）。</p><h2 id="FB（FeedBack）"><a href="#FB（FeedBack）" class="headerlink" title="FB（FeedBack）"></a>FB（FeedBack）</h2><blockquote><p>Internally connected to the regulation, over-voltage, and short-circuit comparators. The regulation setting is 0.6V at this pin. Connect to feedback resistor divider between the output and ground to set the output voltage.</p></blockquote><p>似乎此脚的输入电压应该调到0.6V，并且连接到输出和接地之间的反馈电阻用以调整输出电压。</p><h2 id="SGND"><a href="#SGND" class="headerlink" title="SGND"></a>SGND</h2><blockquote><p>Ground for all internal bias and reference circuitry. Should be connected to PGND at a single point.</p></blockquote><p>信号地，应该和PGND连一起。</p><h2 id="SS（Soft-Start）"><a href="#SS（Soft-Start）" class="headerlink" title="SS（Soft Start）"></a>SS（Soft Start）</h2><blockquote><p>An internal 7.7 µA current source charges an external capacitor to provide the soft-start function.</p></blockquote><p>此处需外接一电容，充电后提供软起动功能<br>计算公式<br>$$<br>C_{SS}&#x3D;\frac{I_{SS}t_{SS}}{V_{ref}}<br>$$<br>其中$V_{ref}&#x3D;0.6V$，$I_{SS}&#x3D;7.7 \mu A$，$t_{SS}$需要在开始的几秒之内测出来？(我理解是这个意思)</p><h2 id="RON"><a href="#RON" class="headerlink" title="RON"></a>RON</h2><blockquote><p>Function:An external resistor from VIN to this pin sets the high-side switch on-time.</p></blockquote><p>从VIN到该引脚的外部电阻设置高压侧开关接通时间。<br>由datasheet有以下关系<br>$$<br>D&#x3D;\frac{t_{on}}{t_{on}t_{off}}&#x3D;t_{on}f_s \approx \frac{V_{OUT}}{V_{IN}}<br>$$<br>易得<br>$$<br>f_s&#x3D;\frac{V_{OUT}}{K R_{on}}<br>$$<br>其中K为常数，$K&#x3D;100pC$。</p><h2 id="PGND"><a href="#PGND" class="headerlink" title="PGND"></a>PGND</h2><p>SGND里写了</p><h2 id="ILIM（Current-Limit）"><a href="#ILIM（Current-Limit）" class="headerlink" title="ILIM（Current Limit）"></a>ILIM（Current Limit）</h2><blockquote><p>Monitors current through the low-side switch and triggers current limit operation if the inductor valley current exceeds a user defined value that is set by $R_{LIM}$ and the Sense current, $I_{LIM-TH}$, sourced out of this pin during operation.</p></blockquote><p>监控通过低压侧开关的电流，如果电感器谷电流（最小电流）超过用户定义的值（由$R_{LIM}$设置），则触发电流限制操作，并且在操作过程中检测电流$I_{LIN-TH}$来自此引脚。<br>由datasheet，$R_{LIM}$可以按下方算式进行估计<br>$$<br>\begin{equation}\begin{split}<br>&amp;I_{CL}&#x3D;I_{OCL}-\frac{\Delta I_L}{2} \<br>&amp;R_{ILM}&#x3D;\frac{I_{CL}R_{DS(on)<em>{max}}}{I</em>{LIM-TH}}<br>\end{split}\end{equation}<br>$$<br>其中$I_{OCL}$是自定义的最大输出电流，$R_{DS(on)<em>{max}}$是低位MOS管在预期最大MOS管温度下的电阻值，$I</em>{LIM-TH}$典型内部电流源为$85 \mu A$。<br>还有一个<br>$$<br>\Delta I_L&#x3D;\frac{(V_{IN}-V_{OUT})t_{on}}{L}<br>$$</p><h2 id="SW-Switch-Node"><a href="#SW-Switch-Node" class="headerlink" title="SW(Switch Node)"></a>SW(Switch Node)</h2><blockquote><p>Switch pin of controller and high-gate driver lower supply rail. A boost capacitor is also connected between this pin and BST pin</p></blockquote><p>SW和BST之间连接一个升压电容<br>Design Guide推荐值为0.47uF<br>此外SW向外连接了一个电感（续流？），直接输出VOUT<br><strong>这里不是很懂，但是Design Example上是这样的。</strong></p><h2 id="HG-High-Side-Gate-Drive"><a href="#HG-High-Side-Gate-Drive" class="headerlink" title="HG(High-Side Gate Drive)"></a>HG(High-Side Gate Drive)</h2><blockquote><p>Gate drive signal to the high-side NMOS switch. The high-side gate driver voltage is supplied by the differential voltage between the BST pin and SW pin.</p></blockquote><p>高位NMOS的Gate信号端，Design Example上面上下两个MOS管连在了一起，上位的D连接下位的S。（为啥..？）</p><h2 id="BST-Connection-for-Bootstrap-Capacitor"><a href="#BST-Connection-for-Bootstrap-Capacitor" class="headerlink" title="BST(Connection for Bootstrap Capacitor)"></a>BST(Connection for Bootstrap Capacitor)</h2><p>见SW</p><h2 id="LG"><a href="#LG" class="headerlink" title="LG"></a>LG</h2><blockquote><p>Gate drive signal to the low-side NMOS switch. The low-side gate driver voltage is supplied by VCC.</p></blockquote><p>低位NMOS的Gate信号端，VCC直接给低位NMOS供电。</p><h2 id="PGND-1"><a href="#PGND-1" class="headerlink" title="PGND"></a>PGND</h2><blockquote><p>Synchronous rectifier MOSFET source connection. Tie to power ground plane. Should be tied to SGND at a single point.</p></blockquote><p>和SGND连一起。</p><h1 id="电压输入与输出附近"><a href="#电压输入与输出附近" class="headerlink" title="电压输入与输出附近"></a>电压输入与输出附近</h1><p>注意到在$VIN$和$VOUT$的附近都有三四个电容，放电容的意义是起一定的缓冲作用，相当于微型UPS用以保护芯片。<br><del>我怎么觉得不止这一个作用</del><br>输出和输入端用了两个连接器（XT30PW-F和XT30UPB-F），用以连接供电线缆</p><h1 id="电压输出大小"><a href="#电压输出大小" class="headerlink" title="电压输出大小"></a>电压输出大小</h1><p>根据Design Guide有<br>$$<br>V_{OUT}&#x3D;V_{FB}\frac{R_{FB1}+R_{FB2}}{R_{FB1}}<br>$$<br>其中，$R_{FB1}$是下方的电阻，$R_{FB2}$是上方的电阻，<br>上方原理图中，$R_{FB1}$为10k，$R_{FB2}$为300k，$V_{FB}$为0.6V<br>经计算得<br>$$<br>V_{OUT}&#x3D;18.6V<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 电子电力 </category>
          
          <category> LM3150MHX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DC-DC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C</title>
      <link href="/2023/07/09/qian-ru-shi-ruan-jian/c/c/"/>
      <url>/2023/07/09/qian-ru-shi-ruan-jian/c/c/</url>
      
        <content type="html"><![CDATA[<h1 id="混合编译"><a href="#混合编译" class="headerlink" title="混合编译"></a>混合编译</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef __cplusplus  extern &quot;C&quot; &#123;  #endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这段代码是用于在C++代码中使用C语言的函数接口时进行编译器兼容性处理的。<br>实际上，#ifdef __cplusplus 表示如果当前编译器是C++编译器，则执行下面的语句块。extern “C” { 表示将下面的代码块用C语言的方式进行编译和链接。</p><p>这样就可以在C++代码中使用C语言的函数接口而不会出现编译错误。</p><h1 id="堆栈作用"><a href="#堆栈作用" class="headerlink" title="堆栈作用"></a>堆栈作用</h1><p>堆和栈是两种不同的内存分配方式，它们在单片机中具有不同的作用和特点：</p><ol><li><p>堆（Heap）：</p><ul><li>堆是一块动态分配的内存区域，用于存储程序运行时动态分配的数据。</li><li>堆的大小不固定，可以根据需要动态调整，通常比栈大得多。</li><li>堆的分配和释放由程序员手动控制，通常使用动态内存分配函数（如malloc()、free()）进行操作。</li><li>堆的数据可以在程序的任意位置访问，具有较长的生命周期。</li></ul></li><li><p>栈（Stack）：</p><ul><li>栈是一种自动分配和释放的内存区域，用于存储函数调用、局部变量，返回地址，函数的形参等临时数据。</li><li>栈的大小固定，由编译器或操作系统预先分配。通常比堆小，但速度更快。</li><li>栈的分配和释放由编译器自动管理，遵循“<strong>先进后出</strong>”的原则。</li><li>栈的数据只能在当前函数的作用域内访问，具有较短的生命周期。<br>对于STM32而言，堆栈在启动文件中设定</li></ul></li></ol><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>此修饰符用来控制变量与函数的存储方式和可见性</p><ol><li>对局部变量使用static声明则此变量只会在第一次调用时初始化，之后的调用会保留上一次调用的值，并且其生命周期会延长到整个程序的运行期间而非整个函数的运行期间。</li><li>在函数外部使用static关键字声明的变量称为静态全局变量。静态全局变量的作用域仅限于声明它的源文件，其他文件无法访问。</li><li>静态函数：使用static关键字声明的函数称为静态函数。静态函数只能在声明它的源文件中使用，不能被其他文件调用。</li></ol><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>C语言中的extern关键字用于声明一个全局变量或函数，该变量或函数在其他文件中定义。它的作用是告诉编译器该变量或函数是在其他文件中定义的，需要在当前文件中使用。</p><p>extern关键字可以放在变量或函数的声明前面，表示该变量或函数在其他文件中已经定义。例如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">extern int count; &#x2F;&#x2F; 声明一个全局变量count，在其他文件中定义extern void printMessage(); &#x2F;&#x2F; 声明一个函数printMessage()，在其他文件中定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过使用extern关键字，可以将全局变量或函数的定义分散在多个文件中，提高代码的模块化和可维护性。<br>需要注意的是，extern关键字只是告诉编译器该变量或函数在其他文件中定义，具体的定义仍需在其他文件中进行。如果没有在其他文件中定义，编译器将会报错。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define HSE_VALUE ((uint32_t)8000000) \\外部高速时钟频率<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>这段代码定义了一个宏常量HSE_VALUE，其值为8000000。在单片机中，HSE_VALUE通常用于定义外部高速时钟（HSE）的频率。通过定义HSE_VALUE，可以方便地在程序中使用该值进行时钟配置和计算等操作。<br>在这个例子中，HSE_VALUE的值被定义为8000000，即外部高速时钟的频率为8MHz。在实际应用中，可以根据实际的硬件配置和需要进行适当的修改。</li></ol><p>使用宏常量的好处是可以提高代码的可读性和可维护性。通过使用HSE_VALUE宏常量，可以避免在代码中多次写入具体的数值，而只需要引用宏常量即可。这样，在需要修改外部高速时钟频率时，只需要修改一处定义即可，不需要在代码中逐个修改相关的数值，提高了代码的可维护性。</p><ol start="2"><li>(uint32_t)8000000 是一个类型转换表达式，将常量8000000转换为32位无符号整数类型（uint32_t）。在单片机编程中，类型转换常常用于将不同的数据类型进行转换，以满足特定的需求。在这个例子中，将8000000转换为uint32_t类型，可能是为了确保在计算或操作中使用32位无符号整数的正确性。<br>类型转换的目的可以是为了避免数据溢出、提高计算精度、满足特定的数据格式要求等。在使用类型转换时，需要注意数据范围是否适合目标类型，以及可能引起的数据丢失或截断等问题。</li></ol><h1 id="递归包含"><a href="#递归包含" class="headerlink" title="递归包含"></a>递归包含</h1><p>递归包含是指在头文件中包含其他头文件时，可能会出现循环依赖的情况。例如，头文件A包含头文件B，而头文件B又包含头文件A，这样就形成了递归包含。<br>递归包含可能会导致以下问题：</p><ol><li>编译错误：当头文件A包含头文件B时，编译器会先处理头文件A的内容，然后再处理头文件B的内容。如果头文件B中又包含了头文件A，就会产生循环依赖，编译器无法解析这种情况，导致编译错误。</li><li>重复定义：如果递归包含导致某个符号在多个头文件中被定义多次，就会导致重复定义的错误。这会导致链接错误，使得程序无法正常编译和运行。<br>可以采取以下几种解决方法以避免递归包含：</li><li>使用前置声明：如果只需要使用某个类型的指针或引用，可以使用前置声明来替代头文件的包含。这样可以避免直接包含头文件，减少循环依赖的可能性。</li><li>使用头文件保护宏：在每个头文件的开头和结尾使用头文件保护宏，可以防止同一个头文件被重复包含。这样可以避免递归包含和重复定义的问题。</li></ol><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>C语言中的断言（assertion）是一种用于在程序中检查条件是否满足的机制。它可以帮助程序员在开发过程中发现和诊断错误，并提供一种简单的调试工具。</p><p>断言的基本用法是在代码中插入一个条件判断，如果条件为假（即false），则会触发断言失败，并输出相关的错误信息。断言的目的是在程序运行时快速定位错误，并提供有关错误信息的提示，以便于调试和修复问题。</p><p>在C语言中，可以使用 <code>&lt;assert.h&gt;</code> 头文件中的 <code>assert()</code> 宏来实现断言功能。<code>assert()</code> 宏接受一个条件表达式作为参数，如果条件为假，则会触发断言失败，打印出错信息，并终止程序的执行。</p><p>以下是一个简单的示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;assert.h&gt;int main() &#123;    int x &#x3D; 5;    assert(x &#x3D;&#x3D; 10);  &#x2F;&#x2F; 断言条件 x &#x3D;&#x3D; 10    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述示例中，断言条件 <code>x == 10</code> 显然是不满足的，因此运行程序时会触发断言失败，输出类似以下的错误信息：</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">Assertion failed: x &#x3D;&#x3D; 10, file example.c, line 6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过断言，我们可以在程序中插入一些条件检查，帮助我们在开发过程中发现和解决问题。但需要注意的是，断言通常用于调试阶段，而在生产环境中，可以通过定义 <code>NDEBUG</code> 宏来禁用断言，以提高程序的性能和效率。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>0x00000002U 是一个十六进制的无符号整数常量，表示十进制的2。</p><p>解析这个数据时，按照以下步骤进行：</p><ol><li>“0x” 表示这是一个十六进制数。</li><li>“00000002” 是十六进制数的具体数值部分。</li><li>“U” 表示这是一个无符号整数。(unsigned int)</li></ol><p>将十六进制数”00000002” 转换为十进制数，结果为2。由于数据类型被指定为无符号整数，因此该数值为正数。</p><h1 id="杂记-1"><a href="#杂记-1" class="headerlink" title="杂记"></a>杂记</h1><p>1. </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">volatile const init_fn_t *fn_ptr;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>volatile: 这个关键字用来告诉编译器，这个变量的值可能会在程序控制之外的情况下改变，比如由于硬件的变动或者并行执行的线程。这意味着编译器在优化代码时不能假设这个值在两次读取之间是不变的，它必须在每次使用时直接从内存中读取它的值。</p><p>const: 这个关键字表示指针指向的数据是常量，不可以被修改。注意，const 在 * 的左边，表明被指向的数据是常量，而指针本身可以修改，即可以指向不同的 init_fn_t 实例。</p><p>init_fn_t: 这通常是一个函数指针的类型定义。在C或C++中，init_fn_t 可能定义为特定类型的函数指针，用于初始化操作或其他目的。</p><p>fn_ptr: 这是变量名，指的是一个指向 init_fn_t 类型数据的指针。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定时器</title>
      <link href="/2023/07/09/qian-ru-shi-ruan-jian/stm32/ding-shi-qi/"/>
      <url>/2023/07/09/qian-ru-shi-ruan-jian/stm32/ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<p>对于STM32F4x，其有2 个高级控制定时器、10 个通用定时器和 2 个基本定时器。</p><p><img src="https://picx.zhimg.com/80/v2-4211c12913d9b34f3ba486b6409f30f1_1440w.png" title="STM32定时器汇总"></p><p><img src="https://picx.zhimg.com/80/v2-5f07297b26daffd8a1956a2bc9731a01_1440w.png" alt="STM32定时器特性"></p><p><img src="https://picx.zhimg.com/80/v2-f95d0963cfb4d534a8f6689cfbbd3a96_1440w.png" alt="STM32F1系统结构图"></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="CNT"><a href="#CNT" class="headerlink" title="CNT"></a>CNT</h3><p>计数器寄存器内的计数值</p><h3 id="ARR"><a href="#ARR" class="headerlink" title="ARR"></a>ARR</h3><p>重装载值</p><h3 id="Counter-Mode"><a href="#Counter-Mode" class="headerlink" title="Counter Mode"></a>Counter Mode</h3><p>计数模式<br>一共有五种计数模式</p><ol><li>Up</li><li>Down</li><li>Center Aligned Mode（1&#x2F;2&#x2F;3）<br>PSC 预分频系数<br>Auto-reload Preload 自动重装载<br>internal Clock Division(CKD) 内部时钟分频因子</li></ol><h1 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h1><p>对于计数器的计数频率，我们有<br>$$<br>f_{timer}&#x3D;\frac{T_{clk}}{PSC}<br>$$<br>因此实际我们所需的定时周期在计数频率确定之后，只需更改ARR即可</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HAL笔记</title>
      <link href="/2023/07/09/qian-ru-shi-ruan-jian/stm32/hal-bi-ji/"/>
      <url>/2023/07/09/qian-ru-shi-ruan-jian/stm32/hal-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>以下所有笔记均基于安富莱V6板</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>为防止递归包含使用如下宏定义进行头文件保护</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __STM32F4xx_HAL_CONF_H #define __STM32F4xx_HAL_CONF_H&#x2F;&#x2F; 在这里定义你的配置#endif &#x2F;* __STM32F4xx_HAL_CONF_H *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>递归包含是指在头文件中包含其他头文件时，可能会出现循环依赖的情况。例如，头文件A包含头文件B，而头文件B又包含头文件A，这样就形成了递归包含。<br>递归包含可能会导致以下问题：</p><ol><li>编译错误：当头文件A包含头文件B时，编译器会先处理头文件A的内容，然后再处理头文件B的内容。如果头文件B中又包含了头文件A，就会产生循环依赖，编译器无法解析这种情况，导致编译错误。</li><li>重复定义：如果递归包含导致某个符号在多个头文件中被定义多次，就会导致重复定义的错误。这会导致链接错误，使得程序无法正常编译和运行。</li></ol></blockquote><p>在配置文件中对于HAL库模块的启用使用了宏定义，如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* ########################## Module Selection ############################## *&#x2F;  &#x2F;**  * @brief This is the list of modules to be used in the HAL driver  *&#x2F;  #define HAL_MODULE_ENABLED    &#x2F;* #define HAL_CRYP_MODULE_ENABLED *&#x2F;  #define HAL_ADC_MODULE_ENABLED  #define HAL_CAN_MODULE_ENABLED  &#x2F;* #define HAL_CRC_MODULE_ENABLED *&#x2F;  &#x2F;* #define HAL_CAN_LEGACY_MODULE_ENABLED *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注释掉的即为未启用的模块，在配置文件的后面，如果你启用了该模块，那么会包含相对应的头文件</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef HAL_RCC_MODULE_ENABLED  #include &quot;stm32f4xx_hal_rcc.h&quot;  #endif &#x2F;* HAL_RCC_MODULE_ENABLED *&#x2F;    #ifdef HAL_GPIO_MODULE_ENABLED  #include &quot;stm32f4xx_hal_gpio.h&quot;  #endif &#x2F;* HAL_GPIO_MODULE_ENABLED *&#x2F;    #ifdef HAL_EXTI_MODULE_ENABLED  #include &quot;stm32f4xx_hal_exti.h&quot;  #endif &#x2F;* HAL_EXTI_MODULE_ENABLED *&#x2F;    #ifdef HAL_DMA_MODULE_ENABLED  #include &quot;stm32f4xx_hal_dma.h&quot;  #endif &#x2F;* HAL_DMA_MODULE_ENABLED *&#x2F;    #ifdef HAL_CORTEX_MODULE_ENABLED  #include &quot;stm32f4xx_hal_cortex.h&quot;  #endif &#x2F;* HAL_CORTEX_MODULE_ENABLED *&#x2F;    #ifdef HAL_ADC_MODULE_ENABLED  #include &quot;stm32f4xx_hal_adc.h&quot;  #endif &#x2F;* HAL_ADC_MODULE_ENABLED *&#x2F;    #ifdef HAL_CAN_MODULE_ENABLED  #include &quot;stm32f4xx_hal_can.h&quot;  #endif &#x2F;* HAL_CAN_MODULE_ENABLED *&#x2F;    #ifdef HAL_CAN_LEGACY_MODULE_ENABLED  #include &quot;stm32f4xx_hal_can_legacy.h&quot;  #endif &#x2F;* HAL_CAN_LEGACY_MODULE_ENABLED *&#x2F;    #ifdef HAL_CRC_MODULE_ENABLED  #include &quot;stm32f4xx_hal_crc.h&quot;  #endif &#x2F;* HAL_CRC_MODULE_ENABLED *&#x2F;    #ifdef HAL_CRYP_MODULE_ENABLED  #include &quot;stm32f4xx_hal_cryp.h&quot;  #endif &#x2F;* HAL_CRYP_MODULE_ENABLED *&#x2F;    #ifdef HAL_DMA2D_MODULE_ENABLED  #include &quot;stm32f4xx_hal_dma2d.h&quot;  #endif &#x2F;* HAL_DMA2D_MODULE_ENABLED *&#x2F;    #ifdef HAL_DAC_MODULE_ENABLED  #include &quot;stm32f4xx_hal_dac.h&quot;  #endif &#x2F;* HAL_DAC_MODULE_ENABLED *&#x2F;  ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在配置文件中包含了对晶振频率的设定，需和外界保持一致。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* ########################## HSE&#x2F;HSI Values adaptation ##################### *&#x2F;  &#x2F;**  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.  * This value is used by the RCC HAL module to compute the system frequency  * (when HSE is used as system clock source, directly or through the PLL).  *&#x2F;  #if !defined (HSE_VALUE)  #define HSE_VALUE 25000000U &#x2F;*!&lt; Value of the External oscillator in Hz *&#x2F;  #endif &#x2F;* HSE_VALUE *&#x2F;    #if !defined (HSE_STARTUP_TIMEOUT)  #define HSE_STARTUP_TIMEOUT 100U &#x2F;*!&lt; Time out for HSE start up, in ms *&#x2F;  #endif &#x2F;* HSE_STARTUP_TIMEOUT *&#x2F;    &#x2F;**  * @brief Internal High Speed oscillator (HSI) value.  * This value is used by the RCC HAL module to compute the system frequency  * (when HSI is used as system clock source, directly or through the PLL).  *&#x2F;  #if !defined (HSI_VALUE)  #define HSI_VALUE ((uint32_t)16000000U) &#x2F;*!&lt; Value of the Internal oscillator in Hz*&#x2F;  #endif &#x2F;* HSI_VALUE *&#x2F;    &#x2F;**  * @brief Internal Low Speed oscillator (LSI) value.  *&#x2F;  #if !defined (LSI_VALUE)  #define LSI_VALUE 32000U &#x2F;*!&lt; LSI Typical Value in Hz*&#x2F;  #endif &#x2F;* LSI_VALUE *&#x2F; &#x2F;*!&lt; Value of the Internal Low Speed oscillator in Hz  The real value may vary depending on the variations  in voltage and temperature.*&#x2F;  &#x2F;**  * @brief External Low Speed oscillator (LSE) value.  *&#x2F;  #if !defined (LSE_VALUE)  #define LSE_VALUE 32768U &#x2F;*!&lt; Value of the External Low Speed oscillator in Hz *&#x2F;  #endif &#x2F;* LSE_VALUE *&#x2F;    #if !defined (LSE_STARTUP_TIMEOUT)  #define LSE_STARTUP_TIMEOUT 5000U &#x2F;*!&lt; Time out for LSE start up, in ms *&#x2F;  #endif &#x2F;* LSE_STARTUP_TIMEOUT *&#x2F;    &#x2F;**  * @brief External clock source for I2S peripheral  * This value is used by the I2S HAL module to compute the I2S clock source  * frequency, this source is inserted directly through I2S_CKIN pad.  *&#x2F;  #if !defined (EXTERNAL_CLOCK_VALUE)  #define EXTERNAL_CLOCK_VALUE 12288000U &#x2F;*!&lt; Value of the External audio frequency in Hz*&#x2F;  #endif &#x2F;* EXTERNAL_CLOCK_VALUE *&#x2F;    &#x2F;* Tip: To avoid modifying this file each time you need to use different HSE,  &#x3D;&#x3D;&#x3D; you can define the HSE value in your toolchain compiler preprocessor. *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，对于启动时的超时时间（XX_STARTUP_TIMEOUT）建议改为5000（5s），防止启动失败时出问题。</p><p>以下是HAL系统配置选项</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* ########################### System Configuration ######################### *&#x2F;  &#x2F;**  * @brief This is the HAL system configuration section  *&#x2F;  #define VDD_VALUE 3300U &#x2F;*!&lt; Value of VDD in mv *&#x2F;  #define TICK_INT_PRIORITY 15U &#x2F;*!&lt; tick interrupt priority *&#x2F;  #define USE_RTOS 0U  #define PREFETCH_ENABLE 1U  #define INSTRUCTION_CACHE_ENABLE 1U  #define DATA_CACHE_ENABLE 1U<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较重要的是TICK_INT_PRIORITY，这个是设置滴答中断优先级的，15是最低优先级。<br>目前HAL库还不支持RTOS宏定义配置</p><p>在配置文件的最后，是关于断言功能的</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef USE_FULL_ASSERT  &#x2F;**  * @brief The assert_param macro is used for function&#39;s parameters check.  * @param expr If expr is false, it calls assert_failed function  * which reports the name of the source file and the source  * line number of the call that failed.  * If expr is true, it returns no value.  * @retval None  *&#x2F;  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))  &#x2F;* Exported functions ------------------------------------------------------- *&#x2F;  void assert_failed(uint8_t* file, uint32_t line);  #else  #define assert_param(expr) ((void)0U)  #endif &#x2F;* USE_FULL_ASSERT *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其主要作用是用来判断函数形参是否有效。默认情况下是关闭的。<br>用一个HAL库函数举例</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  ##### IO operation functions #####  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;@endverbatim  * @&#123;  *&#x2F;    &#x2F;**  * @brief Reads the specified input port pin.  * @param GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or  * x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.  * @param GPIO_Pin specifies the port bit to read.  * This parameter can be GPIO_PIN_x where x can be (0..15).  * @retval The input port pin value.  *&#x2F;  GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)  &#123;  GPIO_PinState bitstatus;    &#x2F;* Check the parameters *&#x2F;  assert_param(IS_GPIO_PIN(GPIO_Pin));    if((GPIOx-&gt;IDR &amp; GPIO_Pin) !&#x3D; (uint32_t)GPIO_PIN_RESET)  &#123;  bitstatus &#x3D; GPIO_PIN_SET;  &#125;  else  &#123;  bitstatus &#x3D; GPIO_PIN_RESET;  &#125;  return bitstatus;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于HAL的各个API都用到了断言功能，但是即使使能了断言，仍然需要自己定义函数</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void assert_failed(uint8_t* file, uint32_t line)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面给出一个参考</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*ST 库函数使用了 C 编译器的断言功能，如果定义了 USE_FULL_ASSERT ，那么所有的 ST 库函数将检查函数形参是否正确。如果不正确将调用是否正确。如果不正确将调用 assert_failed() assert_failed() 函数函数，这个函数是一个死循环，便于用户检查代码。LINE__ 表示源代码行号。 关键字__FILE__表示源代码文件名。断言功能使能后将增大代码大小，推荐用户仅在调试时使能，在正式发布软件是禁止。断言功能使能后将增大代码大小，推荐用户仅在调试时使能，在正式发布软件是禁止。 用户可以选择是否使能用户可以选择是否使能STST固件库的断言供能。使能断言的方法有两种：固件库的断言供能。使能断言的方法有两种：(1) 在在CC编译器的预定义宏选项中定义编译器的预定义宏选项中定义USE_FULL_ASSERTUSE_FULL_ASSERT。。 (2) 在本文件取消在本文件取消&quot;#define USE_FULL_ASSERT 1&quot;&quot;#define USE_FULL_ASSERT 1&quot;行的注释。 *&#x2F;void assert_failed(uint8_t* file, uint32_t line)&#123; &#x2F;* 用户可以添加自己的代码报告源代码文件名和代码行号，比如将错误文件和行号打印到串口printf(&quot;Wrong parameters value: file %s on line %d\\rr\\n&quot;, file, line) *&#x2F;&#x2F;* 这是一个死循环，断言失败时程序会在此处死机，以便于用户查错这是一个死循环，断言失败时程序会在此处死机，以便于用户查错 *&#x2F;while (1) &#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="gpio-h-c"><a href="#gpio-h-c" class="headerlink" title="gpio.h&#x2F;.c"></a>gpio.h&#x2F;.c</h2><p>似乎这里只有一个函数“ void MX_GPIO_Init()”</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;** Configure pins as  * Analog  * Input  * Output  * EVENT_OUT  * EXTI  * Free pins are configured automatically as Analog (this feature is enabled through  * the Code Generation settings)  *&#x2F;  void MX_GPIO_Init(void)  &#123;    GPIO_InitTypeDef GPIO_InitStruct &#x3D; &#123;0&#125;;    &#x2F;* GPIO Ports Clock Enable *&#x2F;  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOI_CLK_ENABLE();  __HAL_RCC_GPIOC_CLK_ENABLE();  __HAL_RCC_GPIOF_CLK_ENABLE();  __HAL_RCC_GPIOH_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  __HAL_RCC_GPIOJ_CLK_ENABLE();  __HAL_RCC_GPIOG_CLK_ENABLE();  __HAL_RCC_GPIOD_CLK_ENABLE();  __HAL_RCC_GPIOK_CLK_ENABLE();    &#x2F;*Configure GPIO pins : PE2 PE3 PE4 PE5  PE6 PE7 PE8 PE9  PE10 PE11 PE12 PE13  PE14 PE15 PE0 PE1 *&#x2F;  GPIO_InitStruct.Pin &#x3D; GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5  |GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9  |GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13  |GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;  GPIO_InitStruct.Mode &#x3D; GPIO_MODE_ANALOG;  GPIO_InitStruct.Pull &#x3D; GPIO_NOPULL;  HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);    &#x2F;*Configure GPIO pins : PI8 PI10 PI11 PI12  PI13 PI14 PI15 PI0  PI1 PI2 PI3 PI4  PI5 PI6 PI7 *&#x2F;  GPIO_InitStruct.Pin &#x3D; GPIO_PIN_8|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12  |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0  |GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4  |GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;  GPIO_InitStruct.Mode &#x3D; GPIO_MODE_ANALOG;  GPIO_InitStruct.Pull &#x3D; GPIO_NOPULL;  HAL_GPIO_Init(GPIOI, &amp;GPIO_InitStruct);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只摘取了部分代码，后面的基本都是相同的</p><blockquote><p>GPIO_InitTypeDef结构体一般用于配置GPIO引脚的初始化参数。这个结构体包含了多个成员变量，用来设置引脚的模式、速度、上拉&#x2F;下拉设置等。</p></blockquote><p>在这行代码中，GPIO_InitStruct变量被初始化为0，这意味着所有的成员变量都被设置为0。这样做是为了确保在后续的代码中，如果没有特别指定某个成员变量的值，那么它们的默认值都是0。<br>随后开启GPIO的时钟并开始配置引脚，这里的每一个GPIO_PIN之前都用宏定义定义了地址，使用或位操作符将多个引脚组合在一起。<br>这里统一设置为了模拟模式和浮空状态，随后进入HAL_GPIO_INIT函数进行初始化</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;**  * @brief Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.  * @param GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or  * x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains  * the configuration information for the specified GPIO peripheral.  * @retval None  *&#x2F;  void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)  &#123;  uint32_t position;  uint32_t ioposition &#x3D; 0x00U;  uint32_t iocurrent &#x3D; 0x00U;  uint32_t temp &#x3D; 0x00U;    &#x2F;* Check the parameters *&#x2F;  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));  assert_param(IS_GPIO_PIN(GPIO_Init-&gt;Pin));  assert_param(IS_GPIO_MODE(GPIO_Init-&gt;Mode));    &#x2F;* Configure the port pins *&#x2F;  for(position &#x3D; 0U; position &lt; GPIO_NUMBER; position++)  &#123;  &#x2F;* Get the IO position *&#x2F;  ioposition &#x3D; 0x01U &lt;&lt; position;  &#x2F;* Get the current IO position *&#x2F;  iocurrent &#x3D; (uint32_t)(GPIO_Init-&gt;Pin) &amp; ioposition;    if(iocurrent &#x3D;&#x3D; ioposition)  &#123;  &#x2F;*--------------------- GPIO Mode Configuration ------------------------*&#x2F;  &#x2F;* In case of Output or Alternate function mode selection *&#x2F;  if(((GPIO_Init-&gt;Mode &amp; GPIO_MODE) &#x3D;&#x3D; MODE_OUTPUT) || \  (GPIO_Init-&gt;Mode &amp; GPIO_MODE) &#x3D;&#x3D; MODE_AF)  &#123;  &#x2F;* Check the Speed parameter *&#x2F;  assert_param(IS_GPIO_SPEED(GPIO_Init-&gt;Speed));  &#x2F;* Configure the IO Speed *&#x2F;  temp &#x3D; GPIOx-&gt;OSPEEDR;  temp &amp;&#x3D; ~(GPIO_OSPEEDER_OSPEEDR0 &lt;&lt; (position * 2U));  temp |&#x3D; (GPIO_Init-&gt;Speed &lt;&lt; (position * 2U));  GPIOx-&gt;OSPEEDR &#x3D; temp;    &#x2F;* Configure the IO Output Type *&#x2F;  temp &#x3D; GPIOx-&gt;OTYPER;  temp &amp;&#x3D; ~(GPIO_OTYPER_OT_0 &lt;&lt; position) ;  temp |&#x3D; (((GPIO_Init-&gt;Mode &amp; OUTPUT_TYPE) &gt;&gt; OUTPUT_TYPE_Pos) &lt;&lt; position);  GPIOx-&gt;OTYPER &#x3D; temp;  &#125;    if((GPIO_Init-&gt;Mode &amp; GPIO_MODE) !&#x3D; MODE_ANALOG)  &#123;  &#x2F;* Check the parameters *&#x2F;  assert_param(IS_GPIO_PULL(GPIO_Init-&gt;Pull));    &#x2F;* Activate the Pull-up or Pull down resistor for the current IO *&#x2F;  temp &#x3D; GPIOx-&gt;PUPDR;  temp &amp;&#x3D; ~(GPIO_PUPDR_PUPDR0 &lt;&lt; (position * 2U));  temp |&#x3D; ((GPIO_Init-&gt;Pull) &lt;&lt; (position * 2U));  GPIOx-&gt;PUPDR &#x3D; temp;  &#125;    &#x2F;* In case of Alternate function mode selection *&#x2F;  if((GPIO_Init-&gt;Mode &amp; GPIO_MODE) &#x3D;&#x3D; MODE_AF)  &#123;  &#x2F;* Check the Alternate function parameter *&#x2F;  assert_param(IS_GPIO_AF(GPIO_Init-&gt;Alternate));  &#x2F;* Configure Alternate function mapped with the current IO *&#x2F;  temp &#x3D; GPIOx-&gt;AFR[position &gt;&gt; 3U];  temp &amp;&#x3D; ~(0xFU &lt;&lt; ((uint32_t)(position &amp; 0x07U) * 4U)) ;  temp |&#x3D; ((uint32_t)(GPIO_Init-&gt;Alternate) &lt;&lt; (((uint32_t)position &amp; 0x07U) * 4U));  GPIOx-&gt;AFR[position &gt;&gt; 3U] &#x3D; temp;  &#125;    &#x2F;* Configure IO Direction mode (Input, Output, Alternate or Analog) *&#x2F;  temp &#x3D; GPIOx-&gt;MODER;  temp &amp;&#x3D; ~(GPIO_MODER_MODER0 &lt;&lt; (position * 2U));  temp |&#x3D; ((GPIO_Init-&gt;Mode &amp; GPIO_MODE) &lt;&lt; (position * 2U));  GPIOx-&gt;MODER &#x3D; temp;    &#x2F;*--------------------- EXTI Mode Configuration ------------------------*&#x2F;  &#x2F;* Configure the External Interrupt or event for the current IO *&#x2F;  if((GPIO_Init-&gt;Mode &amp; EXTI_MODE) !&#x3D; 0x00U)  &#123;  &#x2F;* Enable SYSCFG Clock *&#x2F;  __HAL_RCC_SYSCFG_CLK_ENABLE();    temp &#x3D; SYSCFG-&gt;EXTICR[position &gt;&gt; 2U];  temp &amp;&#x3D; ~(0x0FU &lt;&lt; (4U * (position &amp; 0x03U)));  temp |&#x3D; ((uint32_t)(GPIO_GET_INDEX(GPIOx)) &lt;&lt; (4U * (position &amp; 0x03U)));  SYSCFG-&gt;EXTICR[position &gt;&gt; 2U] &#x3D; temp;    &#x2F;* Clear Rising Falling edge configuration *&#x2F;  temp &#x3D; EXTI-&gt;RTSR;  temp &amp;&#x3D; ~((uint32_t)iocurrent);  if((GPIO_Init-&gt;Mode &amp; TRIGGER_RISING) !&#x3D; 0x00U)  &#123;  temp |&#x3D; iocurrent;  &#125;  EXTI-&gt;RTSR &#x3D; temp;    temp &#x3D; EXTI-&gt;FTSR;  temp &amp;&#x3D; ~((uint32_t)iocurrent);  if((GPIO_Init-&gt;Mode &amp; TRIGGER_FALLING) !&#x3D; 0x00U)  &#123;  temp |&#x3D; iocurrent;  &#125;  EXTI-&gt;FTSR &#x3D; temp;    temp &#x3D; EXTI-&gt;EMR;  temp &amp;&#x3D; ~((uint32_t)iocurrent);  if((GPIO_Init-&gt;Mode &amp; EXTI_EVT) !&#x3D; 0x00U)  &#123;  temp |&#x3D; iocurrent;  &#125;  EXTI-&gt;EMR &#x3D; temp;    &#x2F;* Clear EXTI line configuration *&#x2F;  temp &#x3D; EXTI-&gt;IMR;  temp &amp;&#x3D; ~((uint32_t)iocurrent);  if((GPIO_Init-&gt;Mode &amp; EXTI_IT) !&#x3D; 0x00U)  &#123;  temp |&#x3D; iocurrent;  &#125;  EXTI-&gt;IMR &#x3D; temp;  &#125;  &#125;  &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是GPIO初始化结构体定义</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;**  * @brief GPIO Init structure definition  *&#x2F;  typedef struct  &#123;  uint32_t Pin; &#x2F;*!&lt; Specifies the GPIO pins to be configured.  This parameter can be any value of @ref GPIO_pins_define *&#x2F;    uint32_t Mode; &#x2F;*!&lt; Specifies the operating mode for the selected pins.  This parameter can be a value of @ref GPIO_mode_define *&#x2F;    uint32_t Pull; &#x2F;*!&lt; Specifies the Pull-up or Pull-Down activation for the selected pins.  This parameter can be a value of @ref GPIO_pull_define *&#x2F;    uint32_t Speed; &#x2F;*!&lt; Specifies the speed for the selected pins.  This parameter can be a value of @ref GPIO_speed_define *&#x2F;    uint32_t Alternate; &#x2F;*!&lt; Peripheral to be connected to the selected pins.  This parameter can be a value of @ref GPIO_Alternate_function_selection *&#x2F;  &#125;GPIO_InitTypeDef;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>STM32的定时器预加载功能是指在定时器的计数器中设置一个预加载值，当计数器的值达到这个预设值时，可以触发一个事件或中断。这个功能在STM32微控制器的定时器操作中非常有用，尤其是在需要精确控制时间事件时。 </p><h2 id="重复周期计数器"><a href="#重复周期计数器" class="headerlink" title="重复周期计数器"></a>重复周期计数器</h2><p>在STM32微控制器中，一个重复周期计数器（Repeat Counter）通常是指定时器中的一个功能，它允许定时器在计数达到预设值后自动重置并重新开始计数。这种功能对于创建周期性事件非常有用，如周期性中断或定期检查某个条件。</p><p>使用重复周期计数器的基本步骤如下：</p><ol><li><p><strong>定时器配置</strong>：首先设置定时器的基本参数，包括时钟源、预分频值（用于确定计数器的计数速度）和自动重载值（ARR，用于设定计数器达到该值时重置）。</p></li><li><p><strong>设置重复计数器（如果可用）</strong>：某些STM32定时器模型中含有一个专门的重复计数器（REP寄存器），可以用来设置定时器在自动重载后重复计数的次数。如果设置为N，则定时器将完成N+1个周期后产生一个更新事件（包括中断，如果已启用）。</p></li><li><p><strong>中断配置（可选）</strong>：如果需要在每个周期结束时执行特定的操作，可以配置并启用更新事件中断（UIE）。</p></li><li><p><strong>启动定时器</strong>：最后，启动定时器以开始计数。</p></li></ol><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><ol><li><p><strong>单脉冲模式（Single-Shot Mode）</strong>：在这种模式下，HRTIM在每次启动时只生成一个脉冲。这种模式通常用于精确控制时间长度的单次事件。</p></li><li><p><strong>重复模式（Repetitive Mode）</strong>：HRTIM会不断重复生成波形。这种模式适用于需要连续产生周期性波形的应用。</p></li><li><p><strong>连续模式（Continuous Mode）</strong>：在连续模式下，HRTIM持续运行，不断循环计数。这种模式通常用于持续跟踪时间或产生连续的波形。</p></li><li><p><strong>比较模式（Compare Mode）</strong>：HRTIM可以在计数器值达到预设值时生成一个事件。这种模式适用于需要在特定时间点执行操作的应用。</p></li><li><p><strong>捕获模式（Capture Mode）</strong>：在捕获模式下，HRTIM能够捕获并记录外部事件（如输入信号的边沿）发生时的计数器值，这对于测量外部事件的时间非常有用。</p></li><li><p><strong>死区时间管理（Dead-Time Management）</strong>：用于PWM（脉宽调制）应用，以防止H桥类型驱动器中的上下桥臂同时导通。</p></li><li><p><strong>波形模式（Waveform Mode）</strong>：这是一种高级模式，用于生成复杂的波形。在这种模式下，可以使用多个HRTIM通道并配置不同的事件和操作。</p></li><li><p><strong>突发模式（Burst Mode）</strong>：允许HRTIM在特定条件下自动启动和停止，实现对周期和脉冲的精确控制。</p></li></ol><h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学</title>
      <link href="/2023/07/09/gao-deng-shu-xue/gao-deng-shu-xue/"/>
      <url>/2023/07/09/gao-deng-shu-xue/gao-deng-shu-xue/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-向量代数与空间解析几何"><a href="#第八章-向量代数与空间解析几何" class="headerlink" title="第八章  向量代数与空间解析几何"></a>第八章  向量代数与空间解析几何</h1><h2 id="8-1-向量及线性运算"><a href="#8-1-向量及线性运算" class="headerlink" title="8.1 向量及线性运算"></a>8.1 向量及线性运算</h2><h3 id="方向角与方向余弦"><a href="#方向角与方向余弦" class="headerlink" title="方向角与方向余弦"></a>方向角与方向余弦</h3><p>非零向量$\mathbf{r}&#x3D;(x,y,z)&#x3D; \overrightarrow{OM}$与坐标轴的夹角$\alpha、\beta、\gamma$称为向量$r$的方向角，易知<br>$$<br>\cos \alpha&#x3D;\frac{x}{|O M|}&#x3D;\frac{x}{|r|}<br>$$<br>相应的，有<br>$$<br>\cos \beta&#x3D;\frac{y}{|\boldsymbol{r}|}, \cos \gamma&#x3D;\frac{z}{|\boldsymbol{r}|}<br>$$</p><p>显然<br>$$<br>\begin{equation}\begin{split}<br>(\cos \alpha, \cos \beta, \cos \gamma)&#x3D;\left(\frac{x}{|\boldsymbol{r}|}, \frac{y}{|\boldsymbol{r}|}, \frac{z}{|\boldsymbol{r}|}\right)&#x3D;\frac{1}{|\boldsymbol{r}|}(x, y, z)&amp;&#x3D;\frac{\boldsymbol{r}}{|\boldsymbol{r}|}&#x3D;\boldsymbol{e}_r \<br>\cos^2 \alpha+\cos^2 \beta+cos^2 \gamma&#x3D;1<br>\end{split}\end{equation}<br>$$<br>$\cos \alpha, \cos \beta, \cos \gamma$称为向量$\mathbf{r}$的方向余弦，并且以方向余弦为坐标的向量是与此向量同方向的单位向量</p><h3 id="向量的投影"><a href="#向量的投影" class="headerlink" title="向量的投影"></a>向量的投影</h3><ol><li>$Pri_{u}a&#x3D;|a| \cos \varphi$</li><li>投影对加法和数乘运算封闭</li></ol><h2 id="向量积-混合积"><a href="#向量积-混合积" class="headerlink" title="向量积 混合积"></a>向量积 混合积</h2><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3><p>向量积符合下列运算规律</p><ol><li>$\boldsymbol{b} \times \boldsymbol{a}&#x3D;-\boldsymbol{a} \times \boldsymbol{b}$</li><li>$(\boldsymbol{a}+\boldsymbol{b}) \times \boldsymbol{c}&#x3D;\boldsymbol{a} \times \boldsymbol{c}+\boldsymbol{b} \times \boldsymbol{c}$</li><li>$(\lambda \boldsymbol{a}) \times \boldsymbol{b}&#x3D;\boldsymbol{a} \times(\lambda \boldsymbol{b})&#x3D;\lambda(\boldsymbol{a} \times \boldsymbol{b})(\lambda$ 为数 $)$<br>向量积的运算（行列式形式），向量积运算之后得到的结果仍然是向量<br>$$<br>\boldsymbol{a} \times \boldsymbol{b}&#x3D;\left|\begin{array}{ccc}<br>\boldsymbol{i} &amp; \boldsymbol{j} &amp; \boldsymbol{k} \<br>a_x &amp; a_y &amp; a_z \<br>b_x &amp; b_y &amp; b_z<br>\end{array}\right|<br>$$</li></ol><h3 id="混合积"><a href="#混合积" class="headerlink" title="混合积"></a>混合积</h3><p>对于三个向量$\mathbf{a,b,c}$，先做ab的向量积，随后再与c做数量积，这样得到的数量叫做向量$\mathbf{a,b,c}$的混合积，记作<br>$$<br>[\mathbf{abc}]&#x3D;\left|\begin{array}{lll}<br>a_x &amp; a_y &amp; a_z \<br>b_x &amp; b_y &amp; b_z \<br>c_x &amp; c_y &amp; c_z<br>\end{array}\right|<br>$$<br>其几何意义为：由abc为棱构成的平行六面体的体积<br>常用性质：三个向量$\mathbf{a,b,c}$共面的充要条件为$[\mathbf{abc}]&#x3D;0$</p><h2 id="平面及其方程"><a href="#平面及其方程" class="headerlink" title="平面及其方程"></a>平面及其方程</h2><h3 id="平面的点法式方程"><a href="#平面的点法式方程" class="headerlink" title="平面的点法式方程"></a>平面的点法式方程</h3><p>此方法需知某平面的法向量与平面内一点，因此称为点法式<br>由于平面的法向量与平面内的任意一条向量的数量积都为0，设$\mathbf{M}&#x3D;(x,y,z)$是某平面内任意一点，$\mathbf{M_0}&#x3D;(x_0,y_0,z_0)$是某平面内一点，平面的一条法向量为$\mathbf{n}&#x3D;(A,B,C)$,明显有<br>$$<br>\begin{equation}\begin{split}<br>\overrightarrow{MM_0}\cdot N&#x3D;A\left(x-x_0\right)+B\left(y-y_0\right)+C\left(z-z_0\right)&#x3D;0<br>\end{split}\end{equation}<br>$$<br>即得到平面点法式方程。</p><h3 id="平面的一般方程"><a href="#平面的一般方程" class="headerlink" title="平面的一般方程"></a>平面的一般方程</h3><p>定理：任意一个空间平面都可以用一个三元一次方程$A x+B y+C z+D&#x3D;0$表示。<br>对于<strong>特殊的三元一次方程组，应该熟悉其图形特点</strong>，如：</p><ol><li>当A&#x3D;0时，平面是一个平行于x轴的平面，</li><li>当D&#x3D;0时，平面过原点</li><li>当A&#x3D;B&#x3D;0时，平面平行于$xOy$平面</li></ol><h3 id="两平面的夹角"><a href="#两平面的夹角" class="headerlink" title="两平面的夹角"></a>两平面的夹角</h3><p>两个平面法向量的夹角称为两平面的夹角<br>公式的证明过程实际上是两个平面的法向量的数量积运算经过变换得到的<br>公式：<br>$$<br>\cos \theta&#x3D;\frac{\left|A_1 A_2+B_1 B_2+C_1 C_2\right|}{\sqrt{A_1^2+B_1^2+C_1^2} \sqrt{A_2^2+B_2^2+C_2^2}}<br>$$<br>和高中部分的解析几何部分还是很像的<br>注：两平面平行或重合相当于其法向量对应成比例</p><h3 id="平面外一点到平面的距离公式"><a href="#平面外一点到平面的距离公式" class="headerlink" title="平面外一点到平面的距离公式"></a>平面外一点到平面的距离公式</h3><p>点 $P_0\left(x_0, y_0, z_0\right)$ 到平面 $A x+B y+C z+D&#x3D;0$ 的距离公式<br>$$<br>d&#x3D;\frac{\left|A x_0+B y_0+C z_0+D\right|}{\sqrt{A^2+B^2+C^2}}<br>$$<br>证明思路：还是数量积的运算，令平面上某一点$P_1$法向量为$n$，明显有<br>$$d&#x3D;\left|\overrightarrow{P_1 P_0}\right||\cos \theta|&#x3D;\frac{\left|P_1 P_0 \cdot \boldsymbol{n}\right|}{|\boldsymbol{n}|}$$<br>![[Pasted image 20230616170842.png]]<br><del>后续的自己慢慢算吧，跟高中的证明直线外一点到直线的距离是一样的</del></p><h2 id="空间直线及其方程"><a href="#空间直线及其方程" class="headerlink" title="空间直线及其方程"></a>空间直线及其方程</h2><h3 id="空间直线的一般式方程"><a href="#空间直线的一般式方程" class="headerlink" title="空间直线的一般式方程"></a>空间直线的一般式方程</h3><p>两个空间平面的交线会得到一条空间直线，由此得出空间直线的一般式方程<br>$$<br>\left{\begin{array}{l}<br>A_1 x+B_1 y+C_1 z+D_1&#x3D;0 \<br>A_2 x+B_2 y+C_2 z+D_2&#x3D;0<br>\end{array}\right.<br>$$<br>此方程组称为空间直线的一般式方程，是由两个空间平面的一般式方程组成的方程组</p><h3 id="空间直线的点向式方程（对称式方程）"><a href="#空间直线的点向式方程（对称式方程）" class="headerlink" title="空间直线的点向式方程（对称式方程）"></a>空间直线的点向式方程（对称式方程）</h3><p>在平面内，我们可以由斜率和平面内一点去建立直线的方程，而在空间内也是类似，但是斜率变成了空间直线的方向向量。<br>如果一个向量平行于一条已知直线，那么这个向量叫做这条直线的方向向量，其坐标称为这条直线的一组方向数，它的方向余弦叫做这条直线的方向余弦。<br>对于直线$L$上一点$\mathbf{M_0}&#x3D;(x_0,y_0,z_0)$和其一方向向量$\mathbf{s}&#x3D;(m,n,p)$，其点向式方程为<br>$$\frac{x-x_0}{m}&#x3D;\frac{y-y_0}{n}&#x3D;\frac{z-z_0}{p}&#x3D;t $$<br>加上t的意义在于导出其参数方程<br>$$<br>\left{\begin{array}{l}<br>x&#x3D;x_0+m t \<br>y&#x3D;y_0+n t \<br>z&#x3D;z_0+p t<br>\end{array}\right.<br>$$<br>注：</p><ol><li>当 $m 、 n$ 和 $p$ 中有一个为零, 例如 $m&#x3D;0$, 而 $n$ 与 $p \neq 0$ 时, 这方程组应理解为<br>$$<br>\left{\begin{array}{l}<br>x-x_0&#x3D;0, \<br>\frac{y-y_0}{n}&#x3D;\frac{z-z_0}{p}<br>\end{array}\right.<br>$$</li><li>当$m 、n$和$p$中有两个为零, 例如$m &#x3D; n&#x3D;0$, 而$p \neq 0$时, 这方程组应理解为<br>$$<br>\left{\begin{array}{l}<br>x-x_{0}&#x3D;0 \<br>y-y_{0}&#x3D;0<br>\end{array}\right.<br>$$</li></ol><h3 id="两直线的夹角"><a href="#两直线的夹角" class="headerlink" title="两直线的夹角"></a>两直线的夹角</h3><p>还是两直线的方向余弦的数量积运算，两直线的夹角$\varphi$计算公式为<br>$$<br>\cos \varphi&#x3D;\frac{\left|m_{1} m_{2}+n_{1} n_{2}+p_{1} p_{2}\right|}{\sqrt{m_{1}^{2}+n_{1}^{2}+p_{1}^{2}} \sqrt{m_{2}^{2}+n_{2}^{2}+p_{2}^{2}}}<br>$$</p><h3 id="平面与直线的夹角"><a href="#平面与直线的夹角" class="headerlink" title="平面与直线的夹角"></a>平面与直线的夹角</h3><p>实际上是平面的法向量与直线的方向余弦的数量积运算<br>![[Pasted image 20230616180753.png]]<br>设直线的方向向量为$\mathbf{s}&#x3D;(m,n,p)$，平面的法向量为$\mathbf{n}&#x3D;(A,B,C)$，直线与平面的夹角为$\varphi$，那么<br>$$<br>\varphi&#x3D;\left|\frac{\pi}{2}-(\widehat{s, n})\right|$$<br>绝对值的意义在于向量夹角可能为钝角。<br>因此<br>$$<br>\sin \varphi&#x3D;|\cos (\boldsymbol{s}, \boldsymbol{n})|<br>$$<br>则有<br>$$<br>\sin \varphi&#x3D;\frac{|A m+B n+C p|}{\sqrt{A^{2}+B^{2}+C^{2}} \sqrt{m^{2}+n^{2}+p^{2}}} .<br>$$<br>注意到如果平面与直线垂直，那么法向量与方向向量对应成比例</p><h2 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h2><h3 id="旋转曲面"><a href="#旋转曲面" class="headerlink" title="旋转曲面"></a>旋转曲面</h3><p>以一条平面曲线绕其平面上的一条直线旋转一周得到的曲面叫做<strong>旋转曲面</strong>，旋转曲线和定直线依次叫做旋转曲面的<strong>母线</strong>和<strong>轴</strong>。<br>对于在$yOz$平面上的曲线<br>$$<br>f(y,z)&#x3D;0<br>$$<br>如果将其绕$z$轴旋转，想得到它对应的旋转曲面的方程，只需用剩下的两个坐标，即$x,y$，将$y$替换为$\pm \sqrt{x^2+y^2}$即可<br>原理：当平面曲线绕$z$轴旋转时，$z$轴上的坐标不变，但是注意到曲线上的点到$z$轴的距离<br>$$<br>d&#x3D;\sqrt{x^2+y^2}&#x3D;|y|<br>$$<br>因此旋转曲面的$y$替换为$\pm \sqrt{x^2+y^2}$</p><h3 id="柱面"><a href="#柱面" class="headerlink" title="柱面"></a>柱面</h3><p>直线$L$沿着定曲线$C$平行移动形成的轨迹叫做柱面，其中<br>定曲线$C$称为柱面的准线，动直线$L$称为柱面的母线<br>一般的，如果只含$x,y$的方程$F(x,y)&#x3D;0$在空间直角坐标系中表示母线平行于$z$轴的平面，准线是$xOy$平面上的曲线$F(x,y)&#x3D;0$。<br><del>依此类推，后面就不写了</del></p><h2 id="空间曲线及其方程"><a href="#空间曲线及其方程" class="headerlink" title="空间曲线及其方程"></a>空间曲线及其方程</h2><p><del>感觉不是很重要，过了QaQ</del></p><h1 id="多元函数微分法及其应用"><a href="#多元函数微分法及其应用" class="headerlink" title="多元函数微分法及其应用"></a>多元函数微分法及其应用</h1><h3 id="多元函数的基本概念"><a href="#多元函数的基本概念" class="headerlink" title="多元函数的基本概念"></a>多元函数的基本概念</h3><h4 id="聚点"><a href="#聚点" class="headerlink" title="聚点"></a>聚点</h4><p>如果对于任意给定的$\delta&gt;0$，其去心邻域$\mathring{U}(P, \delta)$内总有$E$的点，那么称这个点是$E$的聚点。<br>例：对于平面点集$$E&#x3D;{(x,y)|1&lt;x^2+y^2 \leq2}$$<br>明显$x^2+y^2&#x3D;1$上的点不是$E$上的点，但是是$E$上的聚点</p><h4 id="多元函数的极限"><a href="#多元函数的极限" class="headerlink" title="多元函数的极限"></a>多元函数的极限</h4><p>对于二元函数$F(P)&#x3D;f(x,y)$，设其定义域为$D$，$P_0&#x3D;(x_0,y_0)$是$D$的聚点，如果对于任意给定的正数$\varepsilon$，总存在正数$\delta$，使得在定义域$D$内的点在任意方向上趋近$P_0$时，都有<br>$$<br>|f(P)-A|&#x3D;|f(x,y)-A|&lt;\varepsilon<br>$$<br>成立，那么称$A$为函数$f(x,y)$当$(x,y)\rightarrow (x_0,y_0)$时的（二重）极限。记作<br>$$<br>\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(p)&#x3D;A<br>$$</p><h4 id="多元函数的连续性"><a href="#多元函数的连续性" class="headerlink" title="多元函数的连续性"></a>多元函数的连续性</h4><p>对于二元函数$F(P)&#x3D;f(x,y)$，设其定义域为$D$，$P_0&#x3D;(x_0,y_0)$是$D$的聚点，且$P_0 \in D$，如果<br>$$<br>\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(x,y)&#x3D;f(x_0,y_0)<br>$$<br>那么称函数$f(x,y)$在点$P_0$连续<br>$$<br>\int_x^ye(\epsilon)d\tau<br>$$</p><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><ol><li>介值定理</li><li>有界性与最大值最小值定理<br>对于在有界闭区域上的多元连续函数一定在此区域内有界，且能取到其最小值和最大值</li></ol><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><h4 id="函数关于自变量的对称性"><a href="#函数关于自变量的对称性" class="headerlink" title="函数关于自变量的对称性"></a>函数关于自变量的对称性</h4><p>函数表达式中任意两个自变量对调之后仍然表示原来的函数，这种函数的偏导数具有形式不变性（同济P67）</p><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><p>For example，二元函数在其定义域内的点上对$x$的偏导数，其几何意义为该点处的切线对$x$轴的斜率。</p><h4 id="高阶偏导数"><a href="#高阶偏导数" class="headerlink" title="高阶偏导数"></a>高阶偏导数</h4><p>定理：如果函数$z&#x3D;f(x, y)$的两个二阶混合偏导数$\frac{\partial^{2} z}{\partial y \partial x}$及$\frac{\partial^{2} z}{\partial x \partial y}$在区域$D$内 连续, 那么在该区域内这两个二阶混合偏导数必相等.<br>注：可导不一定连续（多元微积分）。</p><h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><h4 id="偏微分"><a href="#偏微分" class="headerlink" title="偏微分"></a>偏微分</h4><p>对于<br> $$<br> f(x+\Delta x,y )-f(x,y)\approx f_x(x,y)<br> $$<br>左端称作二元函数$f(x,y)$对$x$的偏增量，右端称作称作二元函数$f(x,y)$对$x$的偏微分。</p><h4 id="全微分-1"><a href="#全微分-1" class="headerlink" title="全微分"></a>全微分</h4><p>定义：设函数$z&#x3D;f(x, y)$在点$(x, y)$的某邻域内有定义, 如果函数在点$(x, y)$的全增量$\Delta z&#x3D;f(x+\Delta x, y+\Delta y)-f(x, y)$可表示为$\Delta z&#x3D;A \Delta x+B \Delta y+o(\rho)$,其中$A$和$B$不依赖于$\Delta x$和$\Delta$而仅与$x$和$y$有关, $\rho&#x3D;\sqrt{(\Delta x)^{2}+(\Delta y)^{2}}$, 那么称 函数$z&#x3D;f(x, y)$在点$(x, y)$可微分, 而$A \Delta x+B \Delta y$称为函数$z&#x3D;f(x, y)$在点$(x, y)$的全微分, 记作$\mathrm{d} z$, 即$$\mathrm{d} z&#x3D;A \Delta x+B \Delta y$$<br>如果函数在区域$D$内各点处都可微分，那么称函数在$D$内可微分。<br>全微分等于其偏微分之和，称为多元函数的叠加原理。<br>注：可微一定连续，微分通常用来做近似计算处理。<br>注：全微分具有形式不变性</p><h5 id="可微的条件"><a href="#可微的条件" class="headerlink" title="可微的条件"></a>可微的条件</h5><ol><li>（必要条件）如果多元函数在某点可微，那么其偏导数一定存在。</li><li>（充分条件）如果多元函数的所有偏导数在某点连续，那么函数在该点可微。</li></ol><h3 id="复合函数求导法则"><a href="#复合函数求导法则" class="headerlink" title="复合函数求导法则"></a>复合函数求导法则</h3><p>主要方法是画函数关系图，根据关系图和链式求导法则写式子<br>例：$u&#x3D;e^{x^3+y^2+z},z&#x3D;x \sin y$，求<br>$$<br>\frac{\partial u}{\partial x},\frac{\partial u}{\partial y}<br>$$<br>函数关系图如图所示<br><img src="https://pic4.zhimg.com/v2-9ca8ae2f25e51a364edda41e48ff3bb3_b.jpg"><br>根据关系图有：</p>$$\begin{equation}\begin{split}\frac{\partial u}{\partial x}&=\frac{\partial u}{\partial z}\frac{\partial z}{\partial x}+\frac{\partial u}{\partial x} \\\frac{\partial u}{\partial y}&=\frac{\partial u}{\partial z}\frac{\partial z}{\partial y}+\frac{\partial u}{\partial y}\end{split}\end{equation}$$<h3 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h3><h4 id="隐函数存在定理1"><a href="#隐函数存在定理1" class="headerlink" title="隐函数存在定理1"></a>隐函数存在定理1</h4><p>设函数$F(x, y)$在点$P\left(x_{0}, y_{0}\right)$的某一邻域内具有连续偏导数, 且$F\left(x_{0}, y_{0}\right)&#x3D;0, F_{y}\left(x_{0}, y_{0}\right) \neq 0$, 则方程$F(x, y)&#x3D;0$在点$\left(x_{0}, y_{0}\right)$的某一 邻域内恒能唯一确定一个连续且具有连续导数的函数$y&#x3D;f(x)$, 它满足条件$y_{0}&#x3D;   f\left(x_{0}\right)$ , 并有<br>$$<br>\frac{\mathrm{d} y}{\mathrm{~d} x}&#x3D;-\frac{F_{x}}{F_{y}} .<br>$$<br>实际上是把$y&#x3D;f(x)$带入函数$F(x,y)$之后对$x$求偏导，有<br>$$<br>\begin{equation}\begin{split}<br>F(x,f(x))&#x3D;0\<br>F_x+F_y\frac{dy}{dx}&#x3D;0<br>\end{split}\end{equation}<br>$$<br>变换后即为上面公式</p><h4 id="隐函数存在定理2"><a href="#隐函数存在定理2" class="headerlink" title="隐函数存在定理2"></a>隐函数存在定理2</h4><p>设函数$F(x, y, z)$在点$P\left(x_{0}, y_{0}, z_{0}\right)$的某一邻域内具有连续偏导数, 且$F\left(x_{0}, y_{0}, z_{0}\right)&#x3D;0, F_{z}\left(x_{0}, y_{0}, z_{0}\right) \neq 0$，则方程$F(x, y, z)&#x3D;0$在点$\left(x_{0}, y_{0}, z_{0}\right)$的某一邻域内恒能唯一确定一个连续且具有连续偏导数的函数$z&#x3D;   f(x, y)$，它满足条件  $z_{0}&#x3D;f\left(x_{0}, y_{0}\right)$, 并有<br>$$<br>\frac{\partial z}{\partial x}&#x3D;-\frac{F_{x}}{F_{z}}, \frac{\partial z}{\partial y}&#x3D;-\frac{F_{y}}{F_{z}}<br>$$<br>与上面的证明过程大体相同，将$z&#x3D;f(x,y)$带入求偏导即得上式。</p><p>例：设$F(x,y)$有二阶连续偏导，已知$$F(\frac{x}{z},\frac{y}{z})&#x3D;0$$求<br>$$<br>dz<br>$$<br><img src="https://pic3.zhimg.com/v2-ab40835bee904e1b508903cc024afb96_b.jpg"><br>注意到$F$是一个隐函数，而我要求$dz$，而根据函数关系图发现可以确定一个函数$z&#x3D;f(x,y)$，也就是说上面的隐函数实际上是$G(x,y,z)&#x3D;F(u,v)&#x3D;0$<br>根据函数关系图写式子<br>$$\begin{equation}\begin{split}<br>\frac{\partial F}{\partial x}&#x3D;&amp;\frac{\partial F}{\partial u} \frac{\partial u}{\partial x}+\frac{\partial F}{\partial u} \frac{\partial u}{\partial z} \frac{\partial z}{\partial x}+\frac{\partial F}{\partial v} \frac{\partial v}{\partial z} \frac{\partial z}{\partial x}&#x3D;0 \<br>\frac{\partial F}{\partial y}&#x3D;&amp;\frac{\partial F}{\partial v}\frac{\partial v}{\partial z}\frac{\partial z}{\partial y}+\frac{\partial F}{\partial v}\frac{\partial v}{\partial y}+\frac{\partial F}{\partial u}\frac{\partial u}{\partial z}\frac{\partial z}{\partial y}&#x3D;0<br>\end{split}\end{equation}$$<br>按约定下标书写，有<br>$$<br>\begin{equation}\begin{split}<br>F_{1}^{\prime} \frac{1}{z}+F_{1}^{\prime} \cdot\left(-\frac{x}{z^{2}}\right) \cdot \frac{\partial z}{\partial x}+F_{2}^{\prime} \cdot\left(-\frac{y}{z^{2}}\right) \cdot \frac{\partial z}{\partial x}&#x3D;0\<br>F_{2}^{\prime} (\frac{-y}{z^2})\frac{\partial z}{\partial y}+F_2^{\prime}\frac{1}{z}+F_1^{\prime}(\frac{-x}{z^2})\frac{\partial z}{\partial y}&#x3D;0 \<br>\end{split}\end{equation}<br>$$<br>可以解出来$\frac{\partial z}{\partial y}$和$\frac{\partial z}{\partial x}$，因此全微分为<br>$$<br>dz&#x3D;\frac{\partial z}{\partial x}dx+\frac{\partial z}{\partial y}+dy<br>$$</p><h4 id="对于方程组的情况"><a href="#对于方程组的情况" class="headerlink" title="对于方程组的情况"></a>对于方程组的情况</h4><p>例题：设$xu-yv&#x3D;0,yu+xy&#x3D;1$,求：<br>$$<br>\frac{\partial u}{\partial x}, \frac{\partial u}{\partial y}, \frac{\partial v}{\partial x} \text { 和 } \frac{\partial v}{\partial y}<br>$$<br>对于题给方程组，两侧对$x$求导并移项，有：<br>$$<br>\left{\begin{array}{l}<br>x \frac{\partial u}{\partial x}-y \frac{\partial v}{\partial x}&#x3D;-u \<br>y \frac{\partial u}{\partial x}+x \frac{\partial v}{\partial x}&#x3D;-v<br>\end{array}\right.<br>$$<br>明显这是一个线性方程组，定义其系数行列式为$J$，由克莱姆法则有<br>$$<br>\begin{array}{l}<br>\frac{\partial u}{\partial x}&#x3D;\frac{\left|\begin{array}{rr}<br>-u &amp; -y \<br>-v &amp; x<br>\end{array}\right|}{\left|\begin{array}{rr}<br>x &amp; -y \<br>y &amp; x<br>\end{array}\right|}&#x3D;-\frac{x u+y v}{x^{2}+y^{2}}, \<br>\frac{\partial v}{\partial x}&#x3D;\frac{\left|\begin{array}{rr}<br>x &amp; -u \<br>y &amp; -v<br>\end{array}\right|}{\left|\begin{array}{rr}<br>x &amp; -y \<br>y &amp; x<br>\end{array}\right|}&#x3D;\frac{y u-x v}{x^{2}+y^{2}} .<br>\end{array}<br>$$<br>书中所谓的雅可比式$J$实际上就是方程组的系数行列式。</p><h3 id="多元函数微分学的几何应用"><a href="#多元函数微分学的几何应用" class="headerlink" title="多元函数微分学的几何应用"></a>多元函数微分学的几何应用</h3><p>多元函数的全导数也就是多元函数对应的曲线的切线的方向向量，再在曲线上取一点即可写出点向式方程<br>注：空间曲线需写成参数方程形式<br>通过曲线上某一点并且与该点的切线相垂直的直线称为曲线在该点处的法平面，明显法平面的法向量就是切线的方向向量，因此写出点法式方程即可</p><h3 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h3><h4 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h4><p>定理 如果函数$f(x, y)$在点$P_{0}\left(x_{0}, y_{0}\right)$可微分, 那么函数在该点沿任一方向$l$的方向导数存在,且<br>$$<br>\left.\frac{\partial f}{\partial l}\right|<em>{\left(x</em>{0} . y_{0}\right)}&#x3D;f_{x}\left(x_{0}, y_{0}\right) \cos \alpha+f_{y}\left(x_{0}, y_{0}\right) \cos \beta<br>$$<br>$\text { 其中 } \cos \alpha \text { 和 } \cos \beta \text { 是方向 } l \text { 的方向余弦. }$</p><h4 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h4><p>![[Pasted image 20230617225551.png]]<br>![[Pasted image 20230617225916.png]]</p><h3 id="多元函数极值"><a href="#多元函数极值" class="headerlink" title="多元函数极值"></a>多元函数极值</h3><ol><li>如果多元函数在某点具有偏导数而且在此处取得极值，那么其偏导数的函数值均为零</li><li> ![[Pasted image 20230617230223.png]]</li></ol><h4 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h4><p>对于自变量有附加条件的极值称为条件极值，比如在$V&#x3D;xyz$再加一个条件$a^2&#x3D;2(xy+xz+yz)$，这类极值点的求法通常使用拉格朗日乘数法<br>例：试求函数<br>$$<br>z&#x3D;f(x,y)<br>$$<br>在条件<br>$$<br>\varphi(x,y)&#x3D;0<br>$$<br>下取得极值的必要条件。<br>解：<br>不妨设在$(x_0,y_0)$取得极值，$\varphi(x,y)&#x3D;0$可以确定一个连续且具有连续导数的函数$y&#x3D;\psi(x)$，有<br>$$<br>\left.\frac{\mathrm{d} y}{\mathrm{<del>d} x}\right|<em>{x&#x3D;x</em>{0}}&#x3D;-\frac{\varphi_{x}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}<br>$$<br>带回原函数有<br>$$<br>z&#x3D;f[x, \psi(x)]<br>$$<br>此时对$x$求导，由于$x$为唯一变量，因此只需令导数为零即求得取得极值的条件<br>$$<br>\left.\frac{\mathrm{d} z}{\mathrm{</del>d} x}\right|<em>{x&#x3D;x</em>{0}}&#x3D;f_{x}\left(x_{0}, y_{0}\right)+\left.f_{y}\left(x_{0}, y_{0}\right) \frac{\mathrm{d} y}{\mathrm{~d} x}\right|<em>{x&#x3D;x</em>{0}}&#x3D;0<br>$$<br>联立上式有<br>$$<br>f_{x}\left(x_{0}, y_{0}\right)-f_{y}\left(x_{0}, y_{0}\right) \frac{\varphi_{x}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}&#x3D;0<br>$$<br>不妨令<br>$$<br>\frac{f_{y}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}&#x3D;-\lambda<br>$$<br>上述条件变为<br>$$<br>\left{\begin{array}{l}<br>f_{x}\left(x_{0}, y_{0}\right)+\lambda \varphi_{x}\left(x_{0}, y_{0}\right)&#x3D;0\<br>f_{y}\left(x_{0}, y_{0}\right)+\lambda \varphi_{y}\left(x_{0}, y_{0}\right)&#x3D;0 \<br>\varphi\left(x_{0}, y_{0}\right)&#x3D;0<br>\end{array}\right.<br>$$<br>引进拉格朗日函数<br>$$<br>L(x, y)&#x3D;f(x, y)+\lambda \varphi(x, y)<br>$$<br>其中$\lambda$称为拉格朗日算子，不难看出可以写成<br>$$<br>\left{\begin{array}{l}<br>L_x(x_0,y_0)&#x3D;0\<br>L_y(x_0,y_0)&#x3D;0\<br>\varphi\left(x_{0}, y_{0}\right)&#x3D;0<br>\end{array}\right.<br>$$<br>解出极值点之后带回原函数检验即可，对于自变量多于两个而条件多于一个的场景，拉格朗日函数加上对应的条件函数并乘上未知系数，联立方程组时将所有的拉格朗日函数的偏导数和条件全部联立解方程即可。</p><h1 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h1><h2 id="正项项级数审敛法"><a href="#正项项级数审敛法" class="headerlink" title="正项项级数审敛法"></a>正项项级数审敛法</h2><ol><li><p>比较审敛法及其极限形式</p></li><li><p>比值审敛法</p></li><li><p>根植审敛法</p></li><li><p>如果<br>$$<br>\lim\limits_{n \rightarrow +\infty}u_n \ne0<br>$$<br>则级数一定发散 </p></li><li><p>对数审敛法</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HRTIM</title>
      <link href="/2018/09/30/dian-zi-dian-li/chao-ji-dian-rong/hrtim/"/>
      <url>/2018/09/30/dian-zi-dian-li/chao-ji-dian-rong/hrtim/</url>
      
        <content type="html"><![CDATA[<p>前置条件：STM32G474，170MHz（HSE），定时器使能如图所示<br><img src="https://pic1.zhimg.com/80/v2-2aec432984e65fd476b03343c6d2ffb3_720w.png"></p><h1 id="Master-Timer"><a href="#Master-Timer" class="headerlink" title="Master Timer"></a>Master Timer</h1><h2 id="Time-Base-Setting"><a href="#Time-Base-Setting" class="headerlink" title="Time Base Setting"></a>Time Base Setting</h2><h3 id="PrecalerRatio"><a href="#PrecalerRatio" class="headerlink" title="PrecalerRatio"></a>PrecalerRatio</h3><p>用于设置定时器分频</p><h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p>设置定时器周期，至少为三个HRTIM时钟周期。</p><h3 id="RepetitionCounter"><a href="#RepetitionCounter" class="headerlink" title="RepetitionCounter"></a>RepetitionCounter</h3><p>重复周期计数器 用途未知。</p><h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>貌似都是continuous mode 后面再说</p><h2 id="Timing-Unit"><a href="#Timing-Unit" class="headerlink" title="Timing Unit"></a>Timing Unit</h2><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="Preload"><a href="#Preload" class="headerlink" title="Preload"></a>Preload</h2><p>STM32 定时器的 Preload 功能是一种非常有用的特性，它允许在不影响当前计时周期的情况下，预先设置定时器的自动重装载寄存器（ARR）或比较寄存器（比如捕获&#x2F;比较寄存器 CCR）。这个功能在生成精确的时间延迟或测量时间间隔，以及在PWM（脉冲宽度调制）输出时控制波形的具体形状时非常有用。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>PWM波形生成</strong>：在PWM应用中，经常需要调整周期或占空比来控制电机速度、LED亮度等。使用preload功能，可以在当前周期结束前预设下一周期的参数，这样可以避免在周期中间更改参数可能导致的突然跳变或不稳定现象。</li><li><strong>时间控制</strong>：在需要精确控制时间间隔的应用中，比如通信协议的实现，可以通过预装载ARR来准确设置时间间隔，确保通信的准确性和稳定性。</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><strong>自动重装载寄存器（ARR）Preload</strong>：当ARR preload功能被启用时，对ARR寄存器的更新不会立即生效，而是在当前计数周期结束时自动更新。这保证了计时周期的稳定性和准确性。</li><li><strong>捕获&#x2F;比较寄存器（CCR）Preload</strong>：对于CCR，preload功能同样允许在不干扰当前输出状态的情况下更新其值。在PWM模式下，这可以用来平滑地调整占空比。</li></ul><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><strong>配置TIMx_CR1的ARPE位</strong>：通过设置TIMx的控制寄存器CR1中的ARPE位（自动重装载预装载使能），可以启用ARR的preload功能。</li><li><strong>配置TIMx_CCMRx的OCxPE位</strong>：对于CCR的preload功能，需要在TIMx的捕获&#x2F;比较模式寄存器CCMRx中设置OCxPE位（输出比较x预装载使能）。</li><li><strong>加载新值</strong>：将新的周期值写入ARR或新的比较值写入CCR。</li><li><strong>更新请求</strong>：通常，需要一个更新事件（如计数器溢出）来使预装载的值生效。在某些模式下，可以通过软件生成一个立即更新的事件。</li></ol><h1 id="Repetition-Update"><a href="#Repetition-Update" class="headerlink" title="Repetition Update"></a>Repetition Update</h1><p>STM32G474微控制器的高分辨率定时器（HRTIM）是一个高级功能，旨在满足精确的定时和波形生成需求。其中的“Repetition Update”功能是该定时器的一个重要特性。</p><p>“Repetition Update”的主要作用是控制何时更新定时器的寄存器。在HRTIM中，有一些寄存器是受保护的，这意味着在定时器运行时，这些寄存器的值不能随意改变，以避免产生不稳定的输出波形或是不准确的定时行为。因此，“Repetition Update”允许用户设定一个重复计数器，指定定时器完成多少周期后才更新这些寄存器的内容。</p><p>使用“Repetition Update”功能的优势包括：</p><ol><li><strong>增强稳定性</strong>：通过在适当的时机更新寄存器值，可以避免在输出周期中间改变设置，从而保持输出波形的稳定。</li><li><strong>提高灵活性</strong>：用户可以根据需要配置更新频率，这对于需要频繁调整输出波形或定时参数的应用非常有用。</li><li><strong>优化性能</strong>：在特定的应用中，如电机控制，可以通过精确地调整更新频率来优化系统的响应时间和效率。</li></ol><p>在实际应用中，如果需要定时器在不同的输出周期内实现不同的行为，或者根据外部事件调整定时器的行为，这时“Repetition Update”就显得尤为重要。例如，在PWM（脉冲宽度调制）应用中，可能需要在不同的PWM周期中应用不同的占空比设置，而这些设置的更新就可以依赖于“Repetition Update”功能来实现定时和同步更新。</p><h2 id="by-the-way"><a href="#by-the-way" class="headerlink" title="by the way"></a>by the way</h2><p><del>没太看懂，但是大家都加上了我也加上吧（）</del></p><h1 id="HRTIM中心对齐PWM"><a href="#HRTIM中心对齐PWM" class="headerlink" title="HRTIM中心对齐PWM"></a>HRTIM中心对齐PWM</h1><p>使用Master同步两个定时器（Timer A和Timer B），两个子定时器只有一个输出（TA1&#x2F;TB1）。</p><h2 id="如果不同步的后果"><a href="#如果不同步的后果" class="headerlink" title="如果不同步的后果"></a>如果不同步的后果</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">HAL_HRTIM_WaveformCountStart(&amp;hhrtim1,HRTIM_TIMERID_TIMER_A);  HAL_HRTIM_WaveformOutputStart(&amp;hhrtim1,HRTIM_OUTPUT_TA1);  HAL_HRTIM_WaveformCountStart(&amp;hhrtim1, HRTIM_TIMERID_TIMER_B);  HAL_HRTIM_WaveformOutputStart(&amp;hhrtim1, HRTIM_OUTPUT_TB1);    __HAL_HRTIM_SETCOMPARE(&amp;hhrtim1, HRTIM_TIMERINDEX_TIMER_A, HRTIM_COMPAREUNIT_1, 200);  __HAL_HRTIM_SETCOMPARE(&amp;hhrtim1, HRTIM_TIMERINDEX_TIMER_B, HRTIM_COMPAREUNIT_1, 200);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么写的后果是在示波器上两个PWM输出端会发生相移，不是预期中的两个PWM波的起点是相同的。<br><del>byd照片没了，艹</del><br>如果你不用主定时器去同步的话，请在Start初始化的时候一起初始化，譬如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">HAL_HRTIM_WaveformCountStart(&amp;hhrtim1,HRTIM_TIMERID_TIMER_A | HRTIM_TIMERID_TIMER_B);  HAL_HRTIM_WaveformOutputStart(&amp;hhrtim1,HRTIM_OUTPUT_TA1 | HRTIM_OUTPUT_TB1);      __HAL_HRTIM_SETCOMPARE(&amp;hhrtim1, HRTIM_TIMERINDEX_TIMER_A, HRTIM_COMPAREUNIT_1, 200);  __HAL_HRTIM_SETCOMPARE(&amp;hhrtim1, HRTIM_TIMERINDEX_TIMER_B, HRTIM_COMPAREUNIT_1, 200);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话就能看见两个一模一样的PWM波形了。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>尝试使用Up-Down Countering去生成中心对齐PWM，示波器上能看见周期翻倍了，但是Duty被锁死在了0.5，问题可复现，尚未有解决方案。</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h1 id="Master-定时器"><a href="#Master-定时器" class="headerlink" title="Master 定时器"></a>Master 定时器</h1><p><img src="https://pic1.zhimg.com/80/v2-52027b3db7f468bb81bea0171ec1f668_1440w.png"><br>后面都是disable，开了PreLoad和重复更新<br>这里跟着CSDN配置的，开了中断源，NVIC也开中断了，但是我没用中断输出，我直接</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">HAL_HRTIM_WaveformCountStart(&amp;hhrtim1,HRTIM_TIMERID_Master);  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实测无影响。但是没测试过关了之后什么样，有时间再说</p><h2 id="TimerA"><a href="#TimerA" class="headerlink" title="TimerA"></a>TimerA</h2><p><img src="https://picx.zhimg.com/80/v2-3e2f6cce2cb1e510c811f208ee054d07_1440w.png"><br><img src="https://pica.zhimg.com/80/v2-b7217745a46a8454de907f9715b62451_1440w.png"><br>子定时器如果想用Master去做同步更新，就要在 Reset Trigger Source里面选上跟随Master周期更新，开了两个比较的单元，没用2的原因是貌似跟ADC有关，<del>然后3和1又是一样的就直接用3了</del>。<br>这里TimerA是用来生成中心对齐PWM波形的，TimerB是生成了一个正常的PWM波形，用来和中心对齐的波形进行对比<br>Set Source是选了Counting到比较单元1的值之后再变成高电平，Reset Source则是在每个周期的开始和计数到比较单元3之后波形变成低电平。<br>实际波形图<br><img src="https://raw.githubusercontent.com/WwWangGuan/pics/main/IMG_20240507_203349.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HRTIM </tag>
            
            <tag> 超级电容 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
