<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/07/25/dian-zi-dian-li/stm32h74x-75x-ying-jian-she-ji-gui-ze/"/>
      <url>/2023/07/25/dian-zi-dian-li/stm32h74x-75x-ying-jian-she-ji-gui-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="供电部分"><a href="#供电部分" class="headerlink" title="供电部分"></a>供电部分</h1><p>MCU需要1.71~3.6V的工作电压，主$V_{DD}$断电时，由$V_{BAT}$电压（1.2~3.6V）供电<br>$V_{BAT}$：1.2~3.6 V：当$V_{DD}$不存在时，为 RTC、外部 32 kHz 振荡器和备份寄存器（通过电源开关）供电。<br>$V_{DD}$:I/O引脚和系统模拟部分供电，比如复位、电源管理、振荡器等<br>$V_{DDA}$:用于ADC、DAC、运放、比较器和电压基准供电，这部分供电是独立的。<br>$V_{REF}$:用于模拟外设（ADC/DAC）的外部基准电压。<br>$V_{REF}$可连接至$V_{DDA}$。 如果有单独的外部<br>参考电压施加到$V_{REF}$，必须连接一个100nF和一个1uF的电容。<br>在所有情况下，$V_{REF}$ 必须保持低于$V_{DDA}$。<br>当$V_{DDA}$ 高于 2 V 并且使用 ADC 时，$V_{REF}$下限为 2 V，否则为 1.62 V。<br>$V_{DD33USB}$和$V_{DD50USB}$:USB收发器的外部电源。<br>当使用$V_{DD50USB}$供电时，该引脚必须连接到 USB的VBUS 上并外加一个4.7 μF 去耦电容(CIN)。<br>此外、$V_{DD33USB}$ 必须连接到一个 1 μF 的电容，其最大 ESR 应为 600 mΩ。<br>当 $V_{DD33USB}$ 用于为 USB 收发器供电（3.0 至 3.6 V）时，如果$V_{DD50USB}$引脚可用，则必须将$V_{DD33USB}$连接到 $V_{DD50USB}$引脚。<br>如果$V_{DD50USB}$引脚可用，则必须连接到$V_{DD33USB}$，而$V_{DD33USB}$必须连接两个外部去耦电容。必须连接到两个外部去耦电容（一个 100 nF 陶瓷电容和一个1 μF 钽或陶瓷电容）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A板原理图解析</title>
      <link href="/2023/07/21/roboamaster-kai-fa-ban/wei-ming-ming/"/>
      <url>/2023/07/21/roboamaster-kai-fa-ban/wei-ming-ming/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/07/17/dian-zi-dian-li/dian-lu-yuan-li/dian-lu-yuan-li/"/>
      <url>/2023/07/17/dian-zi-dian-li/dian-lu-yuan-li/dian-lu-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="电压和电路定律"><a href="#电压和电路定律" class="headerlink" title="电压和电路定律"></a>电压和电路定律</h1><p>两个及两个以上元件具有的公共连接点成为<strong>节点</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模拟电子技术</title>
      <link href="/2023/07/13/dian-zi-dian-li/mo-ni-dian-lu/mo-ni-dian-zi-ji-zhu/"/>
      <url>/2023/07/13/dian-zi-dian-li/mo-ni-dian-lu/mo-ni-dian-zi-ji-zhu/</url>
      
        <content type="html"><![CDATA[<p>参考书籍：</p><ol><li>模拟电子技术 第2版：电子工业出版社 (美)Robert L.Boylestad,(美)Louis Nashelsky著</li><li>模拟电子技术基础（第四版）<h1 id="半导体二极管"><a href="#半导体二极管" class="headerlink" title="半导体二极管"></a>半导体二极管</h1><h2 id="半导体基本知识"><a href="#半导体基本知识" class="headerlink" title="半导体基本知识"></a>半导体基本知识</h2><h3 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h3>纯净的，具有晶体结构的半导体成为本征半导体。<h3 id="本征载流子"><a href="#本征载流子" class="headerlink" title="本征载流子"></a>本征载流子</h3>仅由于外部原因引起材料中的自由电子称为本征载流子<h3 id="掺杂半导体"><a href="#掺杂半导体" class="headerlink" title="掺杂半导体"></a>掺杂半导体</h3>半导体材料可以通过在相对纯净的半导体材料中添加特定的杂质原子来改变其特性，即使只添加千万分之一的杂质。<h4 id="N型半导体（电子型半导体）"><a href="#N型半导体（电子型半导体）" class="headerlink" title="N型半导体（电子型半导体）"></a>N型半导体（电子型半导体）</h4>N型半导体是向硅（锗）晶体内掺入五价元素杂质（P/Sb）而形成的。<br>以磷原子为例，其有五个价电子，与硅原子形成四个共价键后还会多出一个电子，这个剩余的电子与其所属原子间的联系相对松散，只需要外界给予较少的能量就能成为自由电子从而在新构成的N型材料内自由运动。<br>由于磷原子与硅原子在形成4个共价键后还能给出一个电子，故称磷原子为施主原子，磷成为施主杂质或N型杂质，<del>其中N的意义为Negative。</del><br>明显自由电子为多数载流子，空穴为少数载流子。<h4 id="P型半导体（空穴型半导体）"><a href="#P型半导体（空穴型半导体）" class="headerlink" title="P型半导体（空穴型半导体）"></a>P型半导体（空穴型半导体）</h4>也是向硅晶体内掺杂，但是掺入三价元素（B/Ga）。<br>以镓原子为例，其与硅原子形成三个共价键，但是硅原子还剩余一个未成键的自由电子，因此在晶体中形成了空穴，当其相邻共价键上的电子吸收外来能量激发时，就有可能填补上这个空穴，从而在外加电场的作用下形成空穴电流。<br>由于镓原子和硅原子形成三个共价键后，硅原子并没有形成8电子稳定构型，而是形成了空穴，需要从杂质原子的空位中吸收电子，故称镓原子为受主原子。<br>明显空穴为多数载流子，自由电子为少数载流子。<h2 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h2></li></ol><h3 id="偏置电压"><a href="#偏置电压" class="headerlink" title="偏置电压"></a>偏置电压</h3><blockquote><p>偏置是指为得到一定的响应而在设备两端所加的电压，对于二极管而言，偏置电压的正负与其极性相同。</p></blockquote><h3 id="无偏置"><a href="#无偏置" class="headerlink" title="无偏置"></a>无偏置</h3><p>在<strong>无外加电场的情况下</strong>，当N型半导体和P型半导体结合在一起时，由于两种材料的载流子分布数量恰好相反，因此空穴与自由电子会向对方的区域扩散并结合，使得原来P区和N区的电中性被破坏，在交界面附近形成了一个很薄的空间电荷区，或者说形成了一个<strong>内部电场</strong>（并非由外加电压形成的），也叫内联电场。虽然这些离子也带电，但是由于物质结构的原因，它们并不能自由移动，因此他们不导电，因此空间电荷区的电阻率很高<br>在这个区域内，由于多数载流子已经扩散到对方的区域并复合掉，因此此区域也成为<strong>耗尽层</strong>，其实也就形成了一个二极管<br>对于内联电场，P区内电子被夺走显正电性，N区内空穴被中和显负电性，明显它对多数载流子的扩散有阻止作用，阻止作用是两方面的，对于N区域来说，首先要克服耗尽层正离子层的引力，其次还要克服负离子层的阻力，才能够到达P区，因此，此时耗尽层也可看为是一个阻挡层，但是其对少数载流子有加强作用，少数载流子会向对方所在的区域漂移，与扩散作用的运动方向恰好相反。并且参与扩散的多子数目等于参与漂移的少子的数目，从而达到动态平衡，空间电荷区不再发生变化，于是形成了稳定的PN结，对于P区与N区杂质浓度相同时，正负离子区的宽度也相同，称为<strong>对称结</strong>，<br>当两侧杂质浓度不同时，浓度高一侧的离子区宽度低于浓度低的离子区宽度，此时称为<strong>不对称PN结</strong>；但是两种结的外部特性都是相同的，即在<strong><em>半导体二极管两端不施加偏置电压时，在单一方向上的电流为零</em></strong></p><h3 id="反向偏置"><a href="#反向偏置" class="headerlink" title="反向偏置"></a>反向偏置</h3><p><img src="https://pica.zhimg.com/80/v2-b269a241d8f30d69e3799e4c7dd2d53a_1440w.png" alt=""><br>当将电压反向加在PN结上（正极接N，负极接P）时，P型半导体中的空穴和N型半导体中的电子被外加电压吸引，使得P型半导体中的负离子和N型半导体中的正离子急剧增多，导致耗尽层加宽，加宽到了多子无法通过耗尽层，如上图所示。<br>但是，外加电场并未影响到少子，少子进入耗尽层的数量仍然不变，与无偏置情况下的数量相同。<br>反向饱和电流用$I_{S}$表示。</p><h3 id="正向偏置"><a href="#正向偏置" class="headerlink" title="正向偏置"></a>正向偏置</h3><p>当讲电压正向加在PN结(正极接P，负极接N)上时，外加电压将会吸引P型半导体的阴离子和N型半导体的阳离子，使得耗尽层变窄。随着外加电压的变大，耗尽层变得更窄，更多的多子可以通过PN结，这将导致电流呈指数级增长。</p><p><del>对于少子而言，耗尽层宽度的下降使得P型半导体中的电子和N型半导体中的空穴流进对方的区域</del></p><h2 id="二极管的一般特性"><a href="#二极管的一般特性" class="headerlink" title="二极管的一般特性"></a>二极管的一般特性</h2><p><img src="https://pic1.zhimg.com/80/v2-609b053bed915f3b0805b2dd6c26ab94_1440w.png" alt=""></p><h3 id="一般特性"><a href="#一般特性" class="headerlink" title="一般特性"></a>一般特性</h3><p>我们使用<strong>肖克利方程</strong>来描述半导体二极管的一般特性</p><script type="math/tex; mode=display">I_{D}=I_{S}(e^{\frac{U_D}{nU_T}}-1)</script><p>其中，$I_D$是通过二极管的电流,$I_{S}$是反向饱和电流，$U_{D}$是加在二极管上的正偏电压，$n$是影响因子，范围在1~2之间，但除非特殊说明，否则都按1处理。<br>我们定义$U_{T}$是热电压，由下式决定</p><script type="math/tex; mode=display">U_{T}=\frac{kT}{q}</script><p>其中，$k$是玻尔兹曼常数，为$1.38 \times 10^{-23}J/K$，T是热力学温度，q是电子的电荷量，为$1.6\times 10^{-19}C$。<br>整理得$$<br>I_D=I_S\,e^{\frac{qU_D}{kT}}-I_S</p><p>$$<br>对其分析，明显得：</p><ol><li>$U_D&lt;0$时,当$U_D$趋于负无穷时，$e^{\frac{qU_D}{kT}}$趋于零，此时$I_D$几乎等于$-I_S$，在图中对应反向偏置区域。</li><li>$U_D&gt;0$时，式中的指数部分将快速增长并超过第二部分，图中曲线随者电压的增大而趋向于垂直。<br>但是，在实际的元件中，<strong>反向饱和电流通常会比肖克利方程中的$I_S$大得多</strong>，这是因为一些没有包含在肖克利方程中的因素引起的，譬如耗尽区载流子的产生以及表面漏电流。<br>此外，pn结的接触面积与反向饱和电流的大小有着直接的对应关系。<h3 id="齐纳区域"><a href="#齐纳区域" class="headerlink" title="齐纳区域"></a>齐纳区域</h3><img src="https://picx.zhimg.com/80/v2-467233537e8ecd41e1923e463311c2e2_1440w.png" alt=""></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/07/12/kong-zhi-li-lun/kong-zhi-zhi-mei/du-shu-bi-ji/"/>
      <url>/2023/07/12/kong-zhi-li-lun/kong-zhi-zhi-mei/du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IIC</title>
      <link href="/2023/07/11/stm32/iic/"/>
      <url>/2023/07/11/stm32/iic/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>IIC（Inter-Integrated Circuit ,内部集成电路)总线是一种由飞利浦Philip公司开发的串行总线。是两条串行的总线，它由一根数据线（SDA）和一根 时钟线（SDL）组成。I2C总线上可以接多个I2C设备，每个器件都有一个唯一的地址识别。同一时间只能有一个主设备，其他为从设备。通常MCU作为主设备控制，外设作为从设备。<br>IIC通信模式为半双工通信，同一时间只能单向通信。 </p><h1 id="电路组成"><a href="#电路组成" class="headerlink" title="电路组成"></a>电路组成</h1><p>I2C总线为漏极开路结构(OD)，因此它们必须接有上拉电阻,阻值常为4.7K或者10K。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[object Object]</title>
      <link href="/2023/07/09/dian-zi-dian-li/pcb/pcb-she-ji-gui-ze/"/>
      <url>/2023/07/09/dian-zi-dian-li/pcb/pcb-she-ji-gui-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="3W规则"><a href="#3W规则" class="headerlink" title="3W规则"></a>3W规则</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SuperCap</title>
      <link href="/2023/07/09/chao-ji-dian-rong/supercap/"/>
      <url>/2023/07/09/chao-ji-dian-rong/supercap/</url>
      
        <content type="html"><![CDATA[<h1 id="超级电容功率控制器"><a href="#超级电容功率控制器" class="headerlink" title="超级电容功率控制器"></a>超级电容功率控制器</h1><h2 id="开关电容均压电路"><a href="#开关电容均压电路" class="headerlink" title="开关电容均压电路"></a>开关电容均压电路</h2><h2 id="超级电容控制模块"><a href="#超级电容控制模块" class="headerlink" title="超级电容控制模块"></a>超级电容控制模块</h2>]]></content>
      
      
      <categories>
          
          <category> 超级电容 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2023/07/09/xian-xing-dai-shu/xian-xing-dai-shu/"/>
      <url>/2023/07/09/xian-xing-dai-shu/xian-xing-dai-shu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路分析</title>
      <link href="/2023/07/09/dian-zi-dian-li/lm3150mhx/dian-lu-fen-xi/"/>
      <url>/2023/07/09/dian-zi-dian-li/lm3150mhx/dian-lu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><img src="https://pica.zhimg.com/80/v2-31edd6ee23e2deb3d1fc7208c1ea0177_1440w.png" alt=""></p><h1 id="芯片引脚分析"><a href="#芯片引脚分析" class="headerlink" title="芯片引脚分析"></a>芯片引脚分析</h1><h2 id="VCC"><a href="#VCC" class="headerlink" title="VCC"></a>VCC</h2><blockquote><p>Nominally regulated to 5.95V. Connect a 1.0 µF to 2.2 µF decoupling capacitor from this pin to ground.</p></blockquote><p>Design Guide要求串联一个容值在1.0uF和2.2uF的电容，可以看到图中C5是一个2.2uF的电容串联接地。</p><h2 id="VIN"><a href="#VIN" class="headerlink" title="VIN"></a>VIN</h2><blockquote><p>Supply pin to the device. Nominal input range is 6V to 42V.</p></blockquote><p>明显此脚接电源输入，电压范围在6V到42V。</p><h2 id="EN"><a href="#EN" class="headerlink" title="EN"></a>EN</h2><blockquote><p>To enable the IC apply a logic high signal to this pin greater than 1.26V typical or leave floating. To disable the part, ground the EN pin.</p></blockquote><p>引脚需要给一个高于1.26V的输入电压来让芯片工作，或者电压保持浮动，原理图上选择串联一个10k电阻。Electrical Characteristic里给出的电压范围是1.14V~1.26V。<br>没找到应该怎么算这个电阻的阻值<del>（<em>还是说整个值仿真一下之后发现行就怼上去了</em>）</del>，Design Guide还要求其工作在开漏状态时应串联一个1000pF的电容（推荐值）。</p><h2 id="FB（FeedBack）"><a href="#FB（FeedBack）" class="headerlink" title="FB（FeedBack）"></a>FB（FeedBack）</h2><blockquote><p>Internally connected to the regulation, over-voltage, and short-circuit comparators. The regulation setting is 0.6V at this pin. Connect to feedback resistor divider between the output and ground to set the output voltage.</p></blockquote><p>似乎此脚的输入电压应该调到0.6V，并且连接到输出和接地之间的反馈电阻用以调整输出电压。</p><h2 id="SGND"><a href="#SGND" class="headerlink" title="SGND"></a>SGND</h2><blockquote><p>Ground for all internal bias and reference circuitry. Should be connected to PGND at a single point.</p></blockquote><p>信号地，应该和PGND连一起。</p><h2 id="SS（Soft-Start）"><a href="#SS（Soft-Start）" class="headerlink" title="SS（Soft Start）"></a>SS（Soft Start）</h2><blockquote><p>An internal 7.7 µA current source charges an external capacitor to provide the soft-start function.</p></blockquote><p>此处需外接一电容，充电后提供软起动功能<br>计算公式</p><script type="math/tex; mode=display">C_{SS}=\frac{I_{SS}t_{SS}}{V_{ref}}</script><p>其中$V_{ref}=0.6V$，$I_{SS}=7.7 \mu A$，$t_{SS}$需要在开始的几秒之内测出来？(我理解是这个意思)</p><h2 id="RON"><a href="#RON" class="headerlink" title="RON"></a>RON</h2><blockquote><p>Function:An external resistor from VIN to this pin sets the high-side switch on-time.</p></blockquote><p>从VIN到该引脚的外部电阻设置高压侧开关接通时间。<br>由datasheet有以下关系</p><script type="math/tex; mode=display">D=\frac{t_{on}}{t_{on}t_{off}}=t_{on}f_s \approx \frac{V_{OUT}}{V_{IN}}</script><p>易得</p><script type="math/tex; mode=display">f_s=\frac{V_{OUT}}{K R_{on}}</script><p>其中K为常数，$K=100pC$。</p><h2 id="PGND"><a href="#PGND" class="headerlink" title="PGND"></a>PGND</h2><p>SGND里写了</p><h2 id="ILIM（Current-Limit）"><a href="#ILIM（Current-Limit）" class="headerlink" title="ILIM（Current Limit）"></a>ILIM（Current Limit）</h2><blockquote><p>Monitors current through the low-side switch and triggers current limit operation if the inductor valley current exceeds a user defined value that is set by $R_{LIM}$ and the Sense current, $I_{LIM-TH}$, sourced out of this pin during operation.</p></blockquote><p>监控通过低压侧开关的电流，如果电感器谷电流（最小电流）超过用户定义的值（由$R_{LIM}$设置），则触发电流限制操作，并且在操作过程中检测电流$I_{LIN-TH}$来自此引脚。<br>由datasheet，$R_{LIM}$可以按下方算式进行估计</p><script type="math/tex; mode=display">\begin{equation}\begin{split} &I_{CL}=I_{OCL}-\frac{\Delta I_L}{2} \\&R_{ILM}=\frac{I_{CL}R_{DS(on)_{max}}}{I_{LIM-TH}}\end{split}\end{equation}</script><p>其中$I_{OCL}$是自定义的最大输出电流，$R_{DS(on)_{max}}$是低位MOS管在预期最大MOS管温度下的电阻值，$I_{LIM-TH}$典型内部电流源为$85 \mu A$。<br>还有一个</p><script type="math/tex; mode=display">\Delta I_L=\frac{(V_{IN}-V_{OUT})t_{on}}{L}</script><h2 id="SW-Switch-Node"><a href="#SW-Switch-Node" class="headerlink" title="SW(Switch Node)"></a>SW(Switch Node)</h2><blockquote><p>Switch pin of controller and high-gate driver lower supply rail. A boost capacitor is also connected between this pin and BST pin</p></blockquote><p>SW和BST之间连接一个升压电容<br>Design Guide推荐值为0.47uF<br>此外SW向外连接了一个电感（续流？），直接输出VOUT<br><strong>这里不是很懂，但是Design Example上是这样的。</strong></p><h2 id="HG-High-Side-Gate-Drive"><a href="#HG-High-Side-Gate-Drive" class="headerlink" title="HG(High-Side Gate Drive)"></a>HG(High-Side Gate Drive)</h2><blockquote><p>Gate drive signal to the high-side NMOS switch. The high-side gate driver voltage is supplied by the differential voltage between the BST pin and SW pin.</p></blockquote><p>高位NMOS的Gate信号端，Design Example上面上下两个MOS管连在了一起，上位的D连接下位的S。（为啥..？）</p><h2 id="BST-Connection-for-Bootstrap-Capacitor"><a href="#BST-Connection-for-Bootstrap-Capacitor" class="headerlink" title="BST(Connection for Bootstrap Capacitor)"></a>BST(Connection for Bootstrap Capacitor)</h2><p>见SW</p><h2 id="LG"><a href="#LG" class="headerlink" title="LG"></a>LG</h2><blockquote><p>Gate drive signal to the low-side NMOS switch. The low-side gate driver voltage is supplied by VCC.</p></blockquote><p>低位NMOS的Gate信号端，VCC直接给低位NMOS供电。</p><h2 id="PGND-1"><a href="#PGND-1" class="headerlink" title="PGND"></a>PGND</h2><blockquote><p>Synchronous rectifier MOSFET source connection. Tie to power ground plane. Should be tied to SGND at a single point.</p></blockquote><p>和SGND连一起。</p><h1 id="电压输入与输出附近"><a href="#电压输入与输出附近" class="headerlink" title="电压输入与输出附近"></a>电压输入与输出附近</h1><p>注意到在$VIN$和$VOUT$的附近都有三四个电容，放电容的意义是起一定的缓冲作用，相当于微型UPS用以保护芯片。<br><del>我怎么觉得不止这一个作用</del><br>输出和输入端用了两个连接器（XT30PW-F和XT30UPB-F），用以连接供电线缆</p><h1 id="电压输出大小"><a href="#电压输出大小" class="headerlink" title="电压输出大小"></a>电压输出大小</h1><p>根据Design Guide有</p><script type="math/tex; mode=display">V_{OUT}=V_{FB}\frac{R_{FB1}+R_{FB2}}{R_{FB1}}</script><p>其中，$R_{FB1}$是下方的电阻，$R_{FB2}$是上方的电阻，<br>上方原理图中，$R_{FB1}$为10k，$R_{FB2}$为300k，$V_{FB}$为0.6V<br>经计算得</p><script type="math/tex; mode=display">V_{OUT}=18.6V</script>]]></content>
      
      
      <categories>
          
          <category> 电子电力 </category>
          
          <category> LM3150MHX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DC-DC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式C</title>
      <link href="/2023/07/09/qian-ru-shi-c/qian-ru-shi-c/"/>
      <url>/2023/07/09/qian-ru-shi-c/qian-ru-shi-c/</url>
      
        <content type="html"><![CDATA[<h1 id="混合编译"><a href="#混合编译" class="headerlink" title="混合编译"></a>混合编译</h1><pre class=" language-lang-C"><code class="language-lang-C">#ifdef __cplusplus  extern "C" &#123;  #endif</code></pre><p>这段代码是用于在C++代码中使用C语言的函数接口时进行编译器兼容性处理的。<br>实际上，#ifdef __cplusplus 表示如果当前编译器是C++编译器，则执行下面的语句块。extern “C” { 表示将下面的代码块用C语言的方式进行编译和链接。</p><p>这样就可以在C++代码中使用C语言的函数接口而不会出现编译错误。</p><h1 id="堆栈作用"><a href="#堆栈作用" class="headerlink" title="堆栈作用"></a>堆栈作用</h1><p>堆和栈是两种不同的内存分配方式，它们在单片机中具有不同的作用和特点：</p><ol><li><p>堆（Heap）：</p><ul><li>堆是一块动态分配的内存区域，用于存储程序运行时动态分配的数据。</li><li>堆的大小不固定，可以根据需要动态调整，通常比栈大得多。</li><li>堆的分配和释放由程序员手动控制，通常使用动态内存分配函数（如malloc()、free()）进行操作。</li><li>堆的数据可以在程序的任意位置访问，具有较长的生命周期。</li></ul></li><li><p>栈（Stack）：</p><ul><li>栈是一种自动分配和释放的内存区域，用于存储函数调用、局部变量，返回地址，函数的形参等临时数据。</li><li>栈的大小固定，由编译器或操作系统预先分配。通常比堆小，但速度更快。</li><li>栈的分配和释放由编译器自动管理，遵循“<strong>先进后出</strong>”的原则。</li><li>栈的数据只能在当前函数的作用域内访问，具有较短的生命周期。<br>对于STM32而言，堆栈在启动文件中设定<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2>此修饰符用来控制变量与函数的存储方式和可见性</li></ul></li><li>对局部变量使用static声明则此变量只会在第一次调用时初始化，之后的调用会保留上一次调用的值，并且其生命周期会延长到整个程序的运行期间而非整个函数的运行期间。</li><li>在函数外部使用static关键字声明的变量称为静态全局变量。静态全局变量的作用域仅限于声明它的源文件，其他文件无法访问。</li><li>静态函数：使用static关键字声明的函数称为静态函数。静态函数只能在声明它的源文件中使用，不能被其他文件调用。<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2>C语言中的extern关键字用于声明一个全局变量或函数，该变量或函数在其他文件中定义。它的作用是告诉编译器该变量或函数是在其他文件中定义的，需要在当前文件中使用。</li></ol><p>extern关键字可以放在变量或函数的声明前面，表示该变量或函数在其他文件中已经定义。例如：</p><pre class=" language-lang-C"><code class="language-lang-C">extern int count; // 声明一个全局变量count，在其他文件中定义extern void printMessage(); // 声明一个函数printMessage()，在其他文件中定义</code></pre><p>通过使用extern关键字，可以将全局变量或函数的定义分散在多个文件中，提高代码的模块化和可维护性。<br>需要注意的是，extern关键字只是告诉编译器该变量或函数在其他文件中定义，具体的定义仍需在其他文件中进行。如果没有在其他文件中定义，编译器将会报错。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><pre class=" language-lang-C"><code class="language-lang-C">#define HSE_VALUE ((uint32_t)8000000) \\外部高速时钟频率</code></pre><ol><li>这段代码定义了一个宏常量HSE_VALUE，其值为8000000。在单片机中，HSE_VALUE通常用于定义外部高速时钟（HSE）的频率。通过定义HSE_VALUE，可以方便地在程序中使用该值进行时钟配置和计算等操作。<br>在这个例子中，HSE_VALUE的值被定义为8000000，即外部高速时钟的频率为8MHz。在实际应用中，可以根据实际的硬件配置和需要进行适当的修改。</li></ol><p>使用宏常量的好处是可以提高代码的可读性和可维护性。通过使用HSE_VALUE宏常量，可以避免在代码中多次写入具体的数值，而只需要引用宏常量即可。这样，在需要修改外部高速时钟频率时，只需要修改一处定义即可，不需要在代码中逐个修改相关的数值，提高了代码的可维护性。</p><ol><li>(uint32_t)8000000 是一个类型转换表达式，将常量8000000转换为32位无符号整数类型（uint32_t）。在单片机编程中，类型转换常常用于将不同的数据类型进行转换，以满足特定的需求。在这个例子中，将8000000转换为uint32_t类型，可能是为了确保在计算或操作中使用32位无符号整数的正确性。<br>类型转换的目的可以是为了避免数据溢出、提高计算精度、满足特定的数据格式要求等。在使用类型转换时，需要注意数据范围是否适合目标类型，以及可能引起的数据丢失或截断等问题。</li></ol><h1 id="递归包含"><a href="#递归包含" class="headerlink" title="递归包含"></a>递归包含</h1><p>递归包含是指在头文件中包含其他头文件时，可能会出现循环依赖的情况。例如，头文件A包含头文件B，而头文件B又包含头文件A，这样就形成了递归包含。<br>递归包含可能会导致以下问题：</p><ol><li>编译错误：当头文件A包含头文件B时，编译器会先处理头文件A的内容，然后再处理头文件B的内容。如果头文件B中又包含了头文件A，就会产生循环依赖，编译器无法解析这种情况，导致编译错误。</li><li>重复定义：如果递归包含导致某个符号在多个头文件中被定义多次，就会导致重复定义的错误。这会导致链接错误，使得程序无法正常编译和运行。<br>可以采取以下几种解决方法以避免递归包含：</li><li>使用前置声明：如果只需要使用某个类型的指针或引用，可以使用前置声明来替代头文件的包含。这样可以避免直接包含头文件，减少循环依赖的可能性。</li><li>使用头文件保护宏：在每个头文件的开头和结尾使用头文件保护宏，可以防止同一个头文件被重复包含。这样可以避免递归包含和重复定义的问题。<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1>C语言中的断言（assertion）是一种用于在程序中检查条件是否满足的机制。它可以帮助程序员在开发过程中发现和诊断错误，并提供一种简单的调试工具。</li></ol><p>断言的基本用法是在代码中插入一个条件判断，如果条件为假（即false），则会触发断言失败，并输出相关的错误信息。断言的目的是在程序运行时快速定位错误，并提供有关错误信息的提示，以便于调试和修复问题。</p><p>在C语言中，可以使用 <code>&lt;assert.h&gt;</code> 头文件中的 <code>assert()</code> 宏来实现断言功能。<code>assert()</code> 宏接受一个条件表达式作为参数，如果条件为假，则会触发断言失败，打印出错信息，并终止程序的执行。</p><p>以下是一个简单的示例：</p><pre class=" language-lang-c"><code class="language-lang-c">#include <assert.h>int main() &#123;    int x = 5;    assert(x == 10);  // 断言条件 x == 10    return 0;&#125;</code></pre><p>在上述示例中，断言条件 <code>x == 10</code> 显然是不满足的，因此运行程序时会触发断言失败，输出类似以下的错误信息：</p><pre class=" language-lang-Cmake"><code class="language-lang-Cmake">Assertion failed: x == 10, file example.c, line 6</code></pre><p>通过断言，我们可以在程序中插入一些条件检查，帮助我们在开发过程中发现和解决问题。但需要注意的是，断言通常用于调试阶段，而在生产环境中，可以通过定义 <code>NDEBUG</code> 宏来禁用断言，以提高程序的性能和效率。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>0x00000002U 是一个十六进制的无符号整数常量，表示十进制的2。</p><p>解析这个数据时，按照以下步骤进行：</p><ol><li>“0x” 表示这是一个十六进制数。</li><li>“00000002” 是十六进制数的具体数值部分。</li><li>“U” 表示这是一个无符号整数。(unsigned int)</li></ol><p>将十六进制数”00000002” 转换为十进制数，结果为2。由于数据类型被指定为无符号整数，因此该数值为正数。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定时器</title>
      <link href="/2023/07/09/stm32/ding-shi-qi/"/>
      <url>/2023/07/09/stm32/ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<p>对于STM32F4x，其有2 个高级控制定时器、10 个通用定时器和 2 个基本定时器。</p><p><img src="https://picx.zhimg.com/80/v2-4211c12913d9b34f3ba486b6409f30f1_1440w.png" alt="" title="STM32定时器汇总"></p><p><img src="https://picx.zhimg.com/80/v2-5f07297b26daffd8a1956a2bc9731a01_1440w.png" alt="STM32定时器特性"></p><p><img src="https://picx.zhimg.com/80/v2-f95d0963cfb4d534a8f6689cfbbd3a96_1440w.png" alt="STM32F1系统结构图"></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="CNT"><a href="#CNT" class="headerlink" title="CNT"></a>CNT</h3><p>计数器寄存器内的计数值</p><h3 id="ARR"><a href="#ARR" class="headerlink" title="ARR"></a>ARR</h3><p>重装载值</p><h3 id="Counter-Mode"><a href="#Counter-Mode" class="headerlink" title="Counter Mode"></a>Counter Mode</h3><p>计数模式<br>一共有五种计数模式</p><ol><li>Up</li><li>Down</li><li>Center Aligned Mode（1/2/3）<br>PSC 预分频系数<br>Auto-reload Preload 自动重装载<br>internal Clock Division(CKD) 内部时钟分频因子<h1 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h1>对于计数器的计数频率，我们有<script type="math/tex; mode=display">f_{timer}=\frac{T_{clk}}{PSC}</script>因此实际我们所需的定时周期在计数频率确定之后，只需更改ARR即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HAL笔记</title>
      <link href="/2023/07/09/stm32/hal-bi-ji/"/>
      <url>/2023/07/09/stm32/hal-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>以下所有笔记均基于安富莱V6板</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>为防止递归包含使用如下宏定义进行头文件保护</p><pre class=" language-lang-C"><code class="language-lang-C">#ifndef __STM32F4xx_HAL_CONF_H #define __STM32F4xx_HAL_CONF_H// 在这里定义你的配置#endif /* __STM32F4xx_HAL_CONF_H */</code></pre><blockquote><p>递归包含是指在头文件中包含其他头文件时，可能会出现循环依赖的情况。例如，头文件A包含头文件B，而头文件B又包含头文件A，这样就形成了递归包含。<br>递归包含可能会导致以下问题：</p><ol><li>编译错误：当头文件A包含头文件B时，编译器会先处理头文件A的内容，然后再处理头文件B的内容。如果头文件B中又包含了头文件A，就会产生循环依赖，编译器无法解析这种情况，导致编译错误。</li><li>重复定义：如果递归包含导致某个符号在多个头文件中被定义多次，就会导致重复定义的错误。这会导致链接错误，使得程序无法正常编译和运行。</li></ol></blockquote><p>在配置文件中对于HAL库模块的启用使用了宏定义，如：</p><pre class=" language-lang-C"><code class="language-lang-C">/* ########################## Module Selection ############################## */  /**  * @brief This is the list of modules to be used in the HAL driver  */  #define HAL_MODULE_ENABLED  /* #define HAL_CRYP_MODULE_ENABLED */  #define HAL_ADC_MODULE_ENABLED  #define HAL_CAN_MODULE_ENABLED  /* #define .HAL_CRC_MODULE_ENABLED */  /* #define HAL_CAN_LEGACY_MODULE_ENABLED */</code></pre><p>注释掉的即为未启用的模块，在配置文件的后面，如果你启用了该模块，那么会包含相对应的头文件</p><pre class=" language-lang-C"><code class="language-lang-C">#ifdef HAL_RCC_MODULE_ENABLED  #include "stm32f4xx_hal_rcc.h"  #endif /* HAL_RCC_MODULE_ENABLED */  #ifdef HAL_GPIO_MODULE_ENABLED  #include "stm32f4xx_hal_gpio.h"  #endif /* HAL_GPIO_MODULE_ENABLED */  #ifdef HAL_EXTI_MODULE_ENABLED  #include "stm32f4xx_hal_exti.h"  #endif /* HAL_EXTI_MODULE_ENABLED */  #ifdef HAL_DMA_MODULE_ENABLED  #include "stm32f4xx_hal_dma.h"  #endif /* HAL_DMA_MODULE_ENABLED */  #ifdef HAL_CORTEX_MODULE_ENABLED  #include "stm32f4xx_hal_cortex.h"  #endif /* HAL_CORTEX_MODULE_ENABLED */  #ifdef HAL_ADC_MODULE_ENABLED  #include "stm32f4xx_hal_adc.h"  #endif /* HAL_ADC_MODULE_ENABLED */  #ifdef HAL_CAN_MODULE_ENABLED  #include "stm32f4xx_hal_can.h"  #endif /* HAL_CAN_MODULE_ENABLED */  #ifdef HAL_CAN_LEGACY_MODULE_ENABLED  #include "stm32f4xx_hal_can_legacy.h"  #endif /* HAL_CAN_LEGACY_MODULE_ENABLED */  #ifdef HAL_CRC_MODULE_ENABLED  #include "stm32f4xx_hal_crc.h"  #endif /* HAL_CRC_MODULE_ENABLED */  #ifdef HAL_CRYP_MODULE_ENABLED  #include "stm32f4xx_hal_cryp.h"  #endif /* HAL_CRYP_MODULE_ENABLED */  #ifdef HAL_DMA2D_MODULE_ENABLED  #include "stm32f4xx_hal_dma2d.h"  #endif /* HAL_DMA2D_MODULE_ENABLED */  #ifdef HAL_DAC_MODULE_ENABLED  #include "stm32f4xx_hal_dac.h"  #endif /* HAL_DAC_MODULE_ENABLED */  ......</code></pre><p>在配置文件中包含了对晶振频率的设定，需和外界保持一致。</p><pre class=" language-lang-C"><code class="language-lang-C">/* ########################## HSE/HSI Values adaptation ##################### */  /**  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.  * This value is used by the RCC HAL module to compute the system frequency  * (when HSE is used as system clock source, directly or through the PLL).  */  #if !defined (HSE_VALUE)  #define HSE_VALUE 25000000U /*!< Value of the External oscillator in Hz */  #endif /* HSE_VALUE */  #if !defined (HSE_STARTUP_TIMEOUT)  #define HSE_STARTUP_TIMEOUT 100U /*!< Time out for HSE start up, in ms */  #endif /* HSE_STARTUP_TIMEOUT */  /**  * @brief Internal High Speed oscillator (HSI) value.  * This value is used by the RCC HAL module to compute the system frequency  * (when HSI is used as system clock source, directly or through the PLL).  */  #if !defined (HSI_VALUE)  #define HSI_VALUE ((uint32_t)16000000U) /*!< Value of the Internal oscillator in Hz*/  #endif /* HSI_VALUE */  /**  * @brief Internal Low Speed oscillator (LSI) value.  */  #if !defined (LSI_VALUE)  #define LSI_VALUE 32000U /*!< LSI Typical Value in Hz*/  #endif /* LSI_VALUE */ /*!< Value of the Internal Low Speed oscillator in Hz  The real value may vary depending on the variations  in voltage and temperature.*/  /**  * @brief External Low Speed oscillator (LSE) value.  */  #if !defined (LSE_VALUE)  #define LSE_VALUE 32768U /*!< Value of the External Low Speed oscillator in Hz */  #endif /* LSE_VALUE */  #if !defined (LSE_STARTUP_TIMEOUT)  #define LSE_STARTUP_TIMEOUT 5000U /*!< Time out for LSE start up, in ms */  #endif /* LSE_STARTUP_TIMEOUT */  /**  * @brief External clock source for I2S peripheral  * This value is used by the I2S HAL module to compute the I2S clock source  * frequency, this source is inserted directly through I2S_CKIN pad.  */  #if !defined (EXTERNAL_CLOCK_VALUE)  #define EXTERNAL_CLOCK_VALUE 12288000U /*!< Value of the External audio frequency in Hz*/  #endif /* EXTERNAL_CLOCK_VALUE */  /* Tip: To avoid modifying this file each time you need to use different HSE,  === you can define the HSE value in your toolchain compiler preprocessor. */</code></pre><p>需要注意的是，对于启动时的超时时间（XX_STARTUP_TIMEOUT）建议改为5000（5s），防止启动失败时出问题。</p><p>以下是HAL系统配置选项</p><pre class=" language-lang-C"><code class="language-lang-C">/* ########################### System Configuration ######################### */  /**  * @brief This is the HAL system configuration section  */  #define VDD_VALUE 3300U /*!< Value of VDD in mv */  #define TICK_INT_PRIORITY 15U /*!< tick interrupt priority */  #define USE_RTOS 0U  #define PREFETCH_ENABLE 1U  #define INSTRUCTION_CACHE_ENABLE 1U  #define DATA_CACHE_ENABLE 1U</code></pre><p>比较重要的是TICK_INT_PRIORITY，这个是设置滴答中断优先级的，15是最低优先级。<br>目前HAL库还不支持RTOS宏定义配置</p><p>在配置文件的最后，是关于断言功能的</p><pre class=" language-lang-C"><code class="language-lang-C">#ifdef USE_FULL_ASSERT  /**  * @brief The assert_param macro is used for function's parameters check.  * @param expr If expr is false, it calls assert_failed function  * which reports the name of the source file and the source  * line number of the call that failed.  * If expr is true, it returns no value.  * @retval None  */  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))  /* Exported functions ------------------------------------------------------- */  void assert_failed(uint8_t* file, uint32_t line);  #else  #define assert_param(expr) ((void)0U)  #endif /* USE_FULL_ASSERT */</code></pre><p>其主要作用是用来判断函数形参是否有效。默认情况下是关闭的。<br>用一个HAL库函数举例</p><pre class=" language-lang-C"><code class="language-lang-C">===============================================================================  ##### IO operation functions #####  ===============================================================================@endverbatim  * @&#123;  */  /**  * @brief Reads the specified input port pin.  * @param GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or  * x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.  * @param GPIO_Pin specifies the port bit to read.  * This parameter can be GPIO_PIN_x where x can be (0..15).  * @retval The input port pin value.  */  GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)  &#123;  GPIO_PinState bitstatus;  /* Check the parameters */  assert_param(IS_GPIO_PIN(GPIO_Pin));  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)  &#123;  bitstatus = GPIO_PIN_SET;  &#125;  else  &#123;  bitstatus = GPIO_PIN_RESET;  &#125;  return bitstatus;  &#125;</code></pre><p>对于HAL的各个API都用到了断言功能，但是即使使能了断言，仍然需要自己定义函数</p><pre class=" language-lang-C"><code class="language-lang-C">void assert_failed(uint8_t* file, uint32_t line)</code></pre><p>下面给出一个参考</p><pre class=" language-lang-C"><code class="language-lang-C">/*ST 库函数使用了 C 编译器的断言功能，如果定义了 USE_FULL_ASSERT ，那么所有的 ST 库函数将检查函数形参是否正确。如果不正确将调用是否正确。如果不正确将调用 assert_failed() assert_failed() 函数函数，这个函数是一个死循环，便于用户检查代码。LINE__ 表示源代码行号。 关键字__FILE__表示源代码文件名。断言功能使能后将增大代码大小，推荐用户仅在调试时使能，在正式发布软件是禁止。断言功能使能后将增大代码大小，推荐用户仅在调试时使能，在正式发布软件是禁止。 用户可以选择是否使能用户可以选择是否使能STST固件库的断言供能。使能断言的方法有两种：固件库的断言供能。使能断言的方法有两种：(1) 在在CC编译器的预定义宏选项中定义编译器的预定义宏选项中定义USE_FULL_ASSERTUSE_FULL_ASSERT。。 (2) 在本文件取消在本文件取消"#define USE_FULL_ASSERT 1""#define USE_FULL_ASSERT 1"行的注释。 */void assert_failed(uint8_t* file, uint32_t line)&#123; /* 用户可以添加自己的代码报告源代码文件名和代码行号，比如将错误文件和行号打印到串口printf("Wrong parameters value: file %s on line %d\\rr\\n", file, line) *//* 这是一个死循环，断言失败时程序会在此处死机，以便于用户查错这是一个死循环，断言失败时程序会在此处死机，以便于用户查错 */while (1) &#123;    &#125;&#125;</code></pre><h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="gpio-h-c"><a href="#gpio-h-c" class="headerlink" title="gpio.h/.c"></a>gpio.h/.c</h2><p>似乎这里只有一个函数“ void MX_GPIO_Init()”</p><pre class=" language-lang-C"><code class="language-lang-C">/** Configure pins as  * Analog  * Input  * Output  * EVENT_OUT  * EXTI  * Free pins are configured automatically as Analog (this feature is enabled through  * the Code Generation settings)  */  void MX_GPIO_Init(void)  &#123;  GPIO_InitTypeDef GPIO_InitStruct = &#123;0&#125;;  /* GPIO Ports Clock Enable */  __HAL_RCC_GPIOE_CLK_ENABLE();  __HAL_RCC_GPIOI_CLK_ENABLE();  __HAL_RCC_GPIOC_CLK_ENABLE();  __HAL_RCC_GPIOF_CLK_ENABLE();  __HAL_RCC_GPIOH_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  __HAL_RCC_GPIOJ_CLK_ENABLE();  __HAL_RCC_GPIOG_CLK_ENABLE();  __HAL_RCC_GPIOD_CLK_ENABLE();  __HAL_RCC_GPIOK_CLK_ENABLE();  /*Configure GPIO pins : PE2 PE3 PE4 PE5  PE6 PE7 PE8 PE9  PE10 PE11 PE12 PE13  PE14 PE15 PE0 PE1 */  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5  |GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9  |GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13  |GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;  GPIO_InitStruct.Pull = GPIO_NOPULL;  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);  /*Configure GPIO pins : PI8 PI10 PI11 PI12  PI13 PI14 PI15 PI0  PI1 PI2 PI3 PI4  PI5 PI6 PI7 */  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12  |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0  |GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4  |GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;  GPIO_InitStruct.Pull = GPIO_NOPULL;  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);  &#125;</code></pre><p>这里只摘取了部分代码，后面的基本都是相同的</p><blockquote><p>GPIO_InitTypeDef结构体一般用于配置GPIO引脚的初始化参数。这个结构体包含了多个成员变量，用来设置引脚的模式、速度、上拉/下拉设置等。</p></blockquote><p>在这行代码中，GPIO_InitStruct变量被初始化为0，这意味着所有的成员变量都被设置为0。这样做是为了确保在后续的代码中，如果没有特别指定某个成员变量的值，那么它们的默认值都是0。<br>随后开启GPIO的时钟并开始配置引脚，这里的每一个GPIO_PIN之前都用宏定义定义了地址，使用或位操作符将多个引脚组合在一起。<br>这里统一设置为了模拟模式和浮空状态，随后进入HAL_GPIO_INIT函数进行初始化</p><pre class=" language-lang-C"><code class="language-lang-C">/**  * @brief Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.  * @param GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or  * x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains  * the configuration information for the specified GPIO peripheral.  * @retval None  */  void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)  &#123;  uint32_t position;  uint32_t ioposition = 0x00U;  uint32_t iocurrent = 0x00U;  uint32_t temp = 0x00U;  /* Check the parameters */  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));  /* Configure the port pins */  for(position = 0U; position < GPIO_NUMBER; position++)  &#123;  /* Get the IO position */  ioposition = 0x01U << position;  /* Get the current IO position */  iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;  if(iocurrent == ioposition)  &#123;  /*--------------------- GPIO Mode Configuration ------------------------*/  /* In case of Output or Alternate function mode selection */  if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \  (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)  &#123;  /* Check the Speed parameter */  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));  /* Configure the IO Speed */  temp = GPIOx->OSPEEDR;  temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));  temp |= (GPIO_Init->Speed << (position * 2U));  GPIOx->OSPEEDR = temp;  /* Configure the IO Output Type */  temp = GPIOx->OTYPER;  temp &= ~(GPIO_OTYPER_OT_0 << position) ;  temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);  GPIOx->OTYPER = temp;  &#125;  if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)  &#123;  /* Check the parameters */  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));  /* Activate the Pull-up or Pull down resistor for the current IO */  temp = GPIOx->PUPDR;  temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));  temp |= ((GPIO_Init->Pull) << (position * 2U));  GPIOx->PUPDR = temp;  &#125;  /* In case of Alternate function mode selection */  if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)  &#123;  /* Check the Alternate function parameter */  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));  /* Configure Alternate function mapped with the current IO */  temp = GPIOx->AFR[position >> 3U];  temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;  temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));  GPIOx->AFR[position >> 3U] = temp;  &#125;  /* Configure IO Direction mode (Input, Output, Alternate or Analog) */  temp = GPIOx->MODER;  temp &= ~(GPIO_MODER_MODER0 << (position * 2U));  temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));  GPIOx->MODER = temp;  /*--------------------- EXTI Mode Configuration ------------------------*/  /* Configure the External Interrupt or event for the current IO */  if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)  &#123;  /* Enable SYSCFG Clock */  __HAL_RCC_SYSCFG_CLK_ENABLE();  temp = SYSCFG->EXTICR[position >> 2U];  temp &= ~(0x0FU << (4U * (position & 0x03U)));  temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));  SYSCFG->EXTICR[position >> 2U] = temp;  /* Clear Rising Falling edge configuration */  temp = EXTI->RTSR;  temp &= ~((uint32_t)iocurrent);  if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)  &#123;  temp |= iocurrent;  &#125;  EXTI->RTSR = temp;  temp = EXTI->FTSR;  temp &= ~((uint32_t)iocurrent);  if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)  &#123;  temp |= iocurrent;  &#125;  EXTI->FTSR = temp;  temp = EXTI->EMR;  temp &= ~((uint32_t)iocurrent);  if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)  &#123;  temp |= iocurrent;  &#125;  EXTI->EMR = temp;  /* Clear EXTI line configuration */  temp = EXTI->IMR;  temp &= ~((uint32_t)iocurrent);  if((GPIO_Init->Mode & EXTI_IT) != 0x00U)  &#123;  temp |= iocurrent;  &#125;  EXTI->IMR = temp;  &#125;  &#125;  &#125;  &#125;</code></pre><p>以下是GPIO初始化结构体定义</p><pre class=" language-lang-C"><code class="language-lang-C">/**  * @brief GPIO Init structure definition  */  typedef struct  &#123;  uint32_t Pin; /*!< Specifies the GPIO pins to be configured.  This parameter can be any value of @ref GPIO_pins_define */  uint32_t Mode; /*!< Specifies the operating mode for the selected pins.  This parameter can be a value of @ref GPIO_mode_define */  uint32_t Pull; /*!< Specifies the Pull-up or Pull-Down activation for the selected pins.  This parameter can be a value of @ref GPIO_pull_define */  uint32_t Speed; /*!< Specifies the speed for the selected pins.  This parameter can be a value of @ref GPIO_speed_define */  uint32_t Alternate; /*!< Peripheral to be connected to the selected pins.  This parameter can be a value of @ref GPIO_Alternate_function_selection */  &#125;GPIO_InitTypeDef;</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 HAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAL与LL库区别</title>
      <link href="/2023/07/09/stm32/hal-yu-ll-ku-qu-bie/"/>
      <url>/2023/07/09/stm32/hal-yu-ll-ku-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>指带inline关键字的函数，作用是将函数直接嵌入到调用此函数的代码中，从而降低调用此函数的时间，适合频繁调用的场景</p><h1 id="两种库的区别"><a href="#两种库的区别" class="headerlink" title="两种库的区别"></a>两种库的区别</h1><p>LL库：寄存器纯享版<br>HAL库：程序员专享版<br>两种库可以混合使用</p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高等数学</title>
      <link href="/2023/07/09/gao-deng-shu-xue/gao-deng-shu-xue/"/>
      <url>/2023/07/09/gao-deng-shu-xue/gao-deng-shu-xue/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-向量代数与空间解析几何"><a href="#第八章-向量代数与空间解析几何" class="headerlink" title="第八章  向量代数与空间解析几何"></a>第八章  向量代数与空间解析几何</h1><h2 id="8-1-向量及线性运算"><a href="#8-1-向量及线性运算" class="headerlink" title="8.1 向量及线性运算"></a>8.1 向量及线性运算</h2><h3 id="方向角与方向余弦"><a href="#方向角与方向余弦" class="headerlink" title="方向角与方向余弦"></a>方向角与方向余弦</h3><p>非零向量$\mathbf{r}=(x,y,z)= \overrightarrow{OM}$与坐标轴的夹角$\alpha、\beta、\gamma$称为向量$r$的方向角，易知</p><script type="math/tex; mode=display">\cos \alpha=\frac{x}{|O M|}=\frac{x}{|r|}</script><p>相应的，有</p><script type="math/tex; mode=display">\cos \beta=\frac{y}{|\boldsymbol{r}|}, \cos \gamma=\frac{z}{|\boldsymbol{r}|}</script><p>显然</p><script type="math/tex; mode=display">\begin{equation}\begin{split}(\cos \alpha, \cos \beta, \cos \gamma)=\left(\frac{x}{|\boldsymbol{r}|}, \frac{y}{|\boldsymbol{r}|}, \frac{z}{|\boldsymbol{r}|}\right)=\frac{1}{|\boldsymbol{r}|}(x, y, z)&=\frac{\boldsymbol{r}}{|\boldsymbol{r}|}=\boldsymbol{e}_r \\\cos^2 \alpha+\cos^2 \beta+cos^2 \gamma=1\end{split}\end{equation}</script><p>$\cos \alpha, \cos \beta, \cos \gamma$称为向量$\mathbf{r}$的方向余弦，并且以方向余弦为坐标的向量是与此向量同方向的单位向量</p><h3 id="向量的投影"><a href="#向量的投影" class="headerlink" title="向量的投影"></a>向量的投影</h3><ol><li>$Pri_{u}a=|a| \cos \varphi$</li><li>投影对加法和数乘运算封闭<h2 id="向量积-混合积"><a href="#向量积-混合积" class="headerlink" title="向量积 混合积"></a>向量积 混合积</h2><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3>向量积符合下列运算规律</li><li>$\boldsymbol{b} \times \boldsymbol{a}=-\boldsymbol{a} \times \boldsymbol{b}$</li><li>$(\boldsymbol{a}+\boldsymbol{b}) \times \boldsymbol{c}=\boldsymbol{a} \times \boldsymbol{c}+\boldsymbol{b} \times \boldsymbol{c}$</li><li>$(\lambda \boldsymbol{a}) \times \boldsymbol{b}=\boldsymbol{a} \times(\lambda \boldsymbol{b})=\lambda(\boldsymbol{a} \times \boldsymbol{b})(\lambda$ 为数 $)$<br>向量积的运算（行列式形式），向量积运算之后得到的结果仍然是向量<script type="math/tex; mode=display">\boldsymbol{a} \times \boldsymbol{b}=\left|\begin{array}{ccc}\boldsymbol{i} & \boldsymbol{j} & \boldsymbol{k} \\a_x & a_y & a_z \\b_x & b_y & b_z\end{array}\right|</script><h3 id="混合积"><a href="#混合积" class="headerlink" title="混合积"></a>混合积</h3>对于三个向量$\mathbf{a,b,c}$，先做ab的向量积，随后再与c做数量积，这样得到的数量叫做向量$\mathbf{a,b,c}$的混合积，记作<script type="math/tex; mode=display">[\mathbf{abc}]=\left|\begin{array}{lll}a_x & a_y & a_z \\b_x & b_y & b_z \\c_x & c_y & c_z\end{array}\right|</script>其几何意义为：由abc为棱构成的平行六面体的体积<br>常用性质：三个向量$\mathbf{a,b,c}$共面的充要条件为$[\mathbf{abc}]=0$<h2 id="平面及其方程"><a href="#平面及其方程" class="headerlink" title="平面及其方程"></a>平面及其方程</h2><h3 id="平面的点法式方程"><a href="#平面的点法式方程" class="headerlink" title="平面的点法式方程"></a>平面的点法式方程</h3>此方法需知某平面的法向量与平面内一点，因此称为点法式<br>由于平面的法向量与平面内的任意一条向量的数量积都为0，设$\mathbf{M}=(x,y,z)$是某平面内任意一点，$\mathbf{M_0}=(x_0,y_0,z_0)$是某平面内一点，平面的一条法向量为$\mathbf{n}=(A,B,C)$,明显有<script type="math/tex; mode=display">\begin{equation}\begin{split}\overrightarrow{MM_0}\cdot N=A\left(x-x_0\right)+B\left(y-y_0\right)+C\left(z-z_0\right)=0\end{split}\end{equation}</script>即得到平面点法式方程。<h3 id="平面的一般方程"><a href="#平面的一般方程" class="headerlink" title="平面的一般方程"></a>平面的一般方程</h3>定理：任意一个空间平面都可以用一个三元一次方程$A x+B y+C z+D=0$表示。<br>对于<strong>特殊的三元一次方程组，应该熟悉其图形特点</strong>，如：</li><li>当A=0时，平面是一个平行于x轴的平面，</li><li>当D=0时，平面过原点</li><li>当A=B=0时，平面平行于$xOy$平面<h3 id="两平面的夹角"><a href="#两平面的夹角" class="headerlink" title="两平面的夹角"></a>两平面的夹角</h3>两个平面法向量的夹角称为两平面的夹角<br>公式的证明过程实际上是两个平面的法向量的数量积运算经过变换得到的<br>公式：<script type="math/tex; mode=display">\cos \theta=\frac{\left|A_1 A_2+B_1 B_2+C_1 C_2\right|}{\sqrt{A_1^2+B_1^2+C_1^2} \sqrt{A_2^2+B_2^2+C_2^2}}</script>和高中部分的解析几何部分还是很像的<br>注：两平面平行或重合相当于其法向量对应成比例<h3 id="平面外一点到平面的距离公式"><a href="#平面外一点到平面的距离公式" class="headerlink" title="平面外一点到平面的距离公式"></a>平面外一点到平面的距离公式</h3>点 $P_0\left(x_0, y_0, z_0\right)$ 到平面 $A x+B y+C z+D=0$ 的距离公式<script type="math/tex; mode=display">d=\frac{\left|A x_0+B y_0+C z_0+D\right|}{\sqrt{A^2+B^2+C^2}}</script>证明思路：还是数量积的运算，令平面上某一点$P_1$法向量为$n$，明显有<script type="math/tex; mode=display">d=\left|\overrightarrow{P_1 P_0}\right||\cos \theta|=\frac{\left|P_1 P_0 \cdot \boldsymbol{n}\right|}{|\boldsymbol{n}|}</script>![[Pasted image 20230616170842.png]]<br><del>后续的自己慢慢算吧，跟高中的证明直线外一点到直线的距离是一样的</del><h2 id="空间直线及其方程"><a href="#空间直线及其方程" class="headerlink" title="空间直线及其方程"></a>空间直线及其方程</h2><h3 id="空间直线的一般式方程"><a href="#空间直线的一般式方程" class="headerlink" title="空间直线的一般式方程"></a>空间直线的一般式方程</h3>两个空间平面的交线会得到一条空间直线，由此得出空间直线的一般式方程<script type="math/tex; mode=display">\left\{\begin{array}{l}A_1 x+B_1 y+C_1 z+D_1=0 \\A_2 x+B_2 y+C_2 z+D_2=0\end{array}\right.</script>此方程组称为空间直线的一般式方程，是由两个空间平面的一般式方程组成的方程组<h3 id="空间直线的点向式方程（对称式方程）"><a href="#空间直线的点向式方程（对称式方程）" class="headerlink" title="空间直线的点向式方程（对称式方程）"></a>空间直线的点向式方程（对称式方程）</h3>在平面内，我们可以由斜率和平面内一点去建立直线的方程，而在空间内也是类似，但是斜率变成了空间直线的方向向量。<br>如果一个向量平行于一条已知直线，那么这个向量叫做这条直线的方向向量，其坐标称为这条直线的一组方向数，它的方向余弦叫做这条直线的方向余弦。<br>对于直线$L$上一点$\mathbf{M_0}=(x_0,y_0,z_0)$和其一方向向量$\mathbf{s}=(m,n,p)$，其点向式方程为<script type="math/tex; mode=display">\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}=t</script>加上t的意义在于导出其参数方程<script type="math/tex; mode=display">\left\{\begin{array}{l}x=x_0+m t \\y=y_0+n t \\z=z_0+p t \end{array}\right.</script>注：</li><li>当 $m 、 n$ 和 $p$ 中有一个为零, 例如 $m=0$, 而 $n$ 与 $p \neq 0$ 时, 这方程组应理解为<script type="math/tex; mode=display">\left\{\begin{array}{l}x-x_0=0, \\\frac{y-y_0}{n}=\frac{z-z_0}{p}\end{array}\right.</script></li><li>当$m 、n$和$p$中有两个为零, 例如$m = n=0$, 而$p \neq 0$时, 这方程组应理解为<script type="math/tex; mode=display">\left\{\begin{array}{l}x-x_{0}=0 \\y-y_{0}=0 \end{array}\right.</script><h3 id="两直线的夹角"><a href="#两直线的夹角" class="headerlink" title="两直线的夹角"></a>两直线的夹角</h3>还是两直线的方向余弦的数量积运算，两直线的夹角$\varphi$计算公式为<script type="math/tex; mode=display">\cos \varphi=\frac{\left|m_{1} m_{2}+n_{1} n_{2}+p_{1} p_{2}\right|}{\sqrt{m_{1}^{2}+n_{1}^{2}+p_{1}^{2}} \sqrt{m_{2}^{2}+n_{2}^{2}+p_{2}^{2}}}</script><h3 id="平面与直线的夹角"><a href="#平面与直线的夹角" class="headerlink" title="平面与直线的夹角"></a>平面与直线的夹角</h3>实际上是平面的法向量与直线的方向余弦的数量积运算<br>![[Pasted image 20230616180753.png]]<br>设直线的方向向量为$\mathbf{s}=(m,n,p)$，平面的法向量为$\mathbf{n}=(A,B,C)$，直线与平面的夹角为$\varphi$，那么<script type="math/tex; mode=display">\varphi=\left|\frac{\pi}{2}-(\widehat{s, n})\right|</script>绝对值的意义在于向量夹角可能为钝角。<br>因此<script type="math/tex; mode=display">\sin \varphi=|\cos (\boldsymbol{s}, \boldsymbol{n})|</script>则有<script type="math/tex; mode=display">\sin \varphi=\frac{|A m+B n+C p|}{\sqrt{A^{2}+B^{2}+C^{2}} \sqrt{m^{2}+n^{2}+p^{2}}} .</script>注意到如果平面与直线垂直，那么法向量与方向向量对应成比例<h2 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h2><h3 id="旋转曲面"><a href="#旋转曲面" class="headerlink" title="旋转曲面"></a>旋转曲面</h3>以一条平面曲线绕其平面上的一条直线旋转一周得到的曲面叫做<strong>旋转曲面</strong>，旋转曲线和定直线依次叫做旋转曲面的<strong>母线</strong>和<strong>轴</strong>。<br>对于在$yOz$平面上的曲线<script type="math/tex; mode=display">f(y,z)=0</script>如果将其绕$z$轴旋转，想得到它对应的旋转曲面的方程，只需用剩下的两个坐标，即$x,y$，将$y$替换为$\pm \sqrt{x^2+y^2}$即可<br>原理：当平面曲线绕$z$轴旋转时，$z$轴上的坐标不变，但是注意到曲线上的点到$z$轴的距离<script type="math/tex; mode=display">d=\sqrt{x^2+y^2}=|y|</script>因此旋转曲面的$y$替换为$\pm \sqrt{x^2+y^2}$<h3 id="柱面"><a href="#柱面" class="headerlink" title="柱面"></a>柱面</h3>直线$L$沿着定曲线$C$平行移动形成的轨迹叫做柱面，其中<br>定曲线$C$称为柱面的准线，动直线$L$称为柱面的母线<br>一般的，如果只含$x,y$的方程$F(x,y)=0$在空间直角坐标系中表示母线平行于$z$轴的平面，准线是$xOy$平面上的曲线$F(x,y)=0$。<br><del>依此类推，后面就不写了</del><h2 id="空间曲线及其方程"><a href="#空间曲线及其方程" class="headerlink" title="空间曲线及其方程"></a>空间曲线及其方程</h2><del>感觉不是很重要，过了QaQ</del></li></ol><h1 id="多元函数微分法及其应用"><a href="#多元函数微分法及其应用" class="headerlink" title="多元函数微分法及其应用"></a>多元函数微分法及其应用</h1><h3 id="多元函数的基本概念"><a href="#多元函数的基本概念" class="headerlink" title="多元函数的基本概念"></a>多元函数的基本概念</h3><h4 id="聚点"><a href="#聚点" class="headerlink" title="聚点"></a>聚点</h4><p>如果对于任意给定的$\delta&gt;0$，其去心邻域$\mathring{U}(P, \delta)$内总有$E$的点，那么称这个点是$E$的聚点。<br>例：对于平面点集<script type="math/tex">E=\{(x,y)|1<x^2+y^2 \leq2\}</script><br>明显$x^2+y^2=1$上的点不是$E$上的点，但是是$E$上的聚点</p><h4 id="多元函数的极限"><a href="#多元函数的极限" class="headerlink" title="多元函数的极限"></a>多元函数的极限</h4><p>对于二元函数$F(P)=f(x,y)$，设其定义域为$D$，$P_0=(x_0,y_0)$是$D$的聚点，如果对于任意给定的正数$\varepsilon$，总存在正数$\delta$，使得在定义域$D$内的点在任意方向上趋近$P_0$时，都有</p><script type="math/tex; mode=display">|f(P)-A|=|f(x,y)-A|<\varepsilon</script><p>成立，那么称$A$为函数$f(x,y)$当$(x,y)\rightarrow (x_0,y_0)$时的（二重）极限。记作</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(p)=A</script><h4 id="多元函数的连续性"><a href="#多元函数的连续性" class="headerlink" title="多元函数的连续性"></a>多元函数的连续性</h4><p>对于二元函数$F(P)=f(x,y)$，设其定义域为$D$，$P_0=(x_0,y_0)$是$D$的聚点，且$P_0 \in D$，如果</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(x,y)=f(x_0,y_0)</script><p>那么称函数$f(x,y)$在点$P_0$连续</p><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><ol><li>介值定理</li><li>有界性与最大值最小值定理<br>对于在有界闭区域上的多元连续函数一定在此区域内有界，且能取到其最小值和最大值<h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><h4 id="函数关于自变量的对称性"><a href="#函数关于自变量的对称性" class="headerlink" title="函数关于自变量的对称性"></a>函数关于自变量的对称性</h4>函数表达式中任意两个自变量对调之后仍然表示原来的函数，这种函数的偏导数具有形式不变性（同济P67）<h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4>For example，二元函数在其定义域内的点上对$x$的偏导数，其几何意义为该点处的切线对$x$轴的斜率。<h4 id="高阶偏导数"><a href="#高阶偏导数" class="headerlink" title="高阶偏导数"></a>高阶偏导数</h4>定理：如果函数$z=f(x, y)$的两个二阶混合偏导数$\frac{\partial^{2} z}{\partial y \partial x}$及$\frac{\partial^{2} z}{\partial x \partial y}$在区域$D$内 连续, 那么在该区域内这两个二阶混合偏导数必相等.<br>注：可导不一定连续（多元微积分）。<h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><h4 id="偏微分"><a href="#偏微分" class="headerlink" title="偏微分"></a>偏微分</h4>对于<script type="math/tex; mode=display">f(x+\Delta x,y )-f(x,y)\approx f_x(x,y)</script>左端称作二元函数$f(x,y)$对$x$的偏增量，右端称作称作二元函数$f(x,y)$对$x$的偏微分。<h4 id="全微分-1"><a href="#全微分-1" class="headerlink" title="全微分"></a>全微分</h4>定义：设函数$z=f(x, y)$在点$(x, y)$的某邻域内有定义, 如果函数在点$(x, y)$的全增量$\Delta z=f(x+\Delta x, y+\Delta y)-f(x, y)$可表示为$\Delta z=A \Delta x+B \Delta y+o(\rho)$,其中$A$和$B$不依赖于$\Delta x$和$\Delta$而仅与$x$和$y$有关, $\rho=\sqrt{(\Delta x)^{2}+(\Delta y)^{2}}$, 那么称 函数$z=f(x, y)$在点$(x, y)$可微分, 而$A \Delta x+B \Delta y$称为函数$z=f(x, y)$在点$(x, y)$的全微分, 记作$\mathrm{d} z$, 即<script type="math/tex">\mathrm{d} z=A \Delta x+B \Delta y</script><br>如果函数在区域$D$内各点处都可微分，那么称函数在$D$内可微分。<br>全微分等于其偏微分之和，称为多元函数的叠加原理。<br>注：可微一定连续，微分通常用来做近似计算处理。<br>注：全微分具有形式不变性<h5 id="可微的条件"><a href="#可微的条件" class="headerlink" title="可微的条件"></a>可微的条件</h5></li><li>（必要条件）如果多元函数在某点可微，那么其偏导数一定存在。</li><li>（充分条件）如果多元函数的所有偏导数在某点连续，那么函数在该点可微。<h3 id="复合函数求导法则"><a href="#复合函数求导法则" class="headerlink" title="复合函数求导法则"></a>复合函数求导法则</h3>主要方法是画函数关系图，根据关系图和链式求导法则写式子<br>例：$u=e^{x^3+y^2+z},z=x \sin y$，求<script type="math/tex; mode=display">\frac{\partial u}{\partial x},\frac{\partial u}{\partial y}</script>函数关系图如图所示<br><img src="https://pic4.zhimg.com/v2-9ca8ae2f25e51a364edda41e48ff3bb3_b.jpg" alt=""><br>根据关系图有：$$\begin{equation}\begin{split}\frac{\partial u}{\partial x}&=\frac{\partial u}{\partial z}\frac{\partial z}{\partial x}+\frac{\partial u}{\partial x} \\\frac{\partial u}{\partial y}&=\frac{\partial u}{\partial z}\frac{\partial z}{\partial y}+\frac{\partial u}{\partial y}\end{split}\end{equation}$$</li></ol><h3 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h3><h4 id="隐函数存在定理1"><a href="#隐函数存在定理1" class="headerlink" title="隐函数存在定理1"></a>隐函数存在定理1</h4><p>设函数$F(x, y)$在点$P\left(x_{0}, y_{0}\right)$的某一邻域内具有连续偏导数, 且$F\left(x_{0}, y_{0}\right)=0, F_{y}\left(x_{0}, y_{0}\right) \neq 0$, 则方程$F(x, y)=0$在点$\left(x_{0}, y_{0}\right)$的某一 邻域内恒能唯一确定一个连续且具有连续导数的函数$y=f(x)$, 它满足条件$y_{0}=   f\left(x_{0}\right)$ , 并有</p><script type="math/tex; mode=display">\frac{\mathrm{d} y}{\mathrm{~d} x}=-\frac{F_{x}}{F_{y}} .</script><p>实际上是把$y=f(x)$带入函数$F(x,y)$之后对$x$求偏导，有</p><script type="math/tex; mode=display">\begin{equation}\begin{split}F(x,f(x))=0\\F_x+F_y\frac{dy}{dx}=0\end{split}\end{equation}</script><p>变换后即为上面公式</p><h4 id="隐函数存在定理2"><a href="#隐函数存在定理2" class="headerlink" title="隐函数存在定理2"></a>隐函数存在定理2</h4><p>设函数$F(x, y, z)$在点$P\left(x_{0}, y_{0}, z_{0}\right)$的某一邻域内具有连续偏导数, 且$F\left(x_{0}, y_{0}, z_{0}\right)=0, F_{z}\left(x_{0}, y_{0}, z_{0}\right) \neq 0$，则方程$F(x, y, z)=0$在点$\left(x_{0}, y_{0}, z_{0}\right)$的某一邻域内恒能唯一确定一个连续且具有连续偏导数的函数$z=   f(x, y)$，它满足条件  $z_{0}=f\left(x_{0}, y_{0}\right)$, 并有</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=-\frac{F_{x}}{F_{z}}, \frac{\partial z}{\partial y}=-\frac{F_{y}}{F_{z}}</script><p>与上面的证明过程大体相同，将$z=f(x,y)$带入求偏导即得上式。</p><p>例：设$F(x,y)$有二阶连续偏导，已知<script type="math/tex">F(\frac{x}{z},\frac{y}{z})=0</script>求</p><script type="math/tex; mode=display">dz</script><p><img src="https://pic3.zhimg.com/v2-ab40835bee904e1b508903cc024afb96_b.jpg" alt=""><br>注意到$F$是一个隐函数，而我要求$dz$，而根据函数关系图发现可以确定一个函数$z=f(x,y)$，也就是说上面的隐函数实际上是$G(x,y,z)=F(u,v)=0$<br>根据函数关系图写式子</p><script type="math/tex; mode=display">\begin{equation}\begin{split}\frac{\partial F}{\partial x}=&\frac{\partial F}{\partial u} \frac{\partial u}{\partial x}+\frac{\partial F}{\partial u} \frac{\partial u}{\partial z} \frac{\partial z}{\partial x}+\frac{\partial F}{\partial v} \frac{\partial v}{\partial z} \frac{\partial z}{\partial x}=0 \\\frac{\partial F}{\partial y}=&\frac{\partial F}{\partial v}\frac{\partial v}{\partial z}\frac{\partial z}{\partial y}+\frac{\partial F}{\partial v}\frac{\partial v}{\partial y}+\frac{\partial F}{\partial u}\frac{\partial u}{\partial z}\frac{\partial z}{\partial y}=0\end{split}\end{equation}</script><p>按约定下标书写，有</p><script type="math/tex; mode=display">\begin{equation}\begin{split}F_{1}^{\prime} \frac{1}{z}+F_{1}^{\prime} \cdot\left(-\frac{x}{z^{2}}\right) \cdot \frac{\partial z}{\partial x}+F_{2}^{\prime} \cdot\left(-\frac{y}{z^{2}}\right) \cdot \frac{\partial z}{\partial x}=0\\F_{2}^{\prime} (\frac{-y}{z^2})\frac{\partial z}{\partial y}+F_2^{\prime}\frac{1}{z}+F_1^{\prime}(\frac{-x}{z^2})\frac{\partial z}{\partial y}=0 \\\end{split}\end{equation}</script><p>可以解出来$\frac{\partial z}{\partial y}$和$\frac{\partial z}{\partial x}$，因此全微分为</p><script type="math/tex; mode=display">dz=\frac{\partial z}{\partial x}dx+\frac{\partial z}{\partial y}+dy</script><h4 id="对于方程组的情况"><a href="#对于方程组的情况" class="headerlink" title="对于方程组的情况"></a>对于方程组的情况</h4><p>例题：设$xu-yv=0,yu+xy=1$,求：</p><script type="math/tex; mode=display">\frac{\partial u}{\partial x}, \frac{\partial u}{\partial y}, \frac{\partial v}{\partial x} \text { 和 } \frac{\partial v}{\partial y}</script><p>对于题给方程组，两侧对$x$求导并移项，有：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}x \frac{\partial u}{\partial x}-y \frac{\partial v}{\partial x}=-u \\y \frac{\partial u}{\partial x}+x \frac{\partial v}{\partial x}=-v\end{array}\right.</script><p>明显这是一个线性方程组，定义其系数行列式为$J$，由克莱姆法则有</p><script type="math/tex; mode=display">\begin{array}{l}\frac{\partial u}{\partial x}=\frac{\left|\begin{array}{rr}-u & -y \\-v & x\end{array}\right|}{\left|\begin{array}{rr}x & -y \\y & x\end{array}\right|}=-\frac{x u+y v}{x^{2}+y^{2}}, \\\frac{\partial v}{\partial x}=\frac{\left|\begin{array}{rr}x & -u \\y & -v\end{array}\right|}{\left|\begin{array}{rr}x & -y \\y & x\end{array}\right|}=\frac{y u-x v}{x^{2}+y^{2}} .\end{array}</script><p>书中所谓的雅可比式$J$实际上就是方程组的系数行列式。</p><h3 id="多元函数微分学的几何应用"><a href="#多元函数微分学的几何应用" class="headerlink" title="多元函数微分学的几何应用"></a>多元函数微分学的几何应用</h3><p>多元函数的全导数也就是多元函数对应的曲线的切线的方向向量，再在曲线上取一点即可写出点向式方程<br>注：空间曲线需写成参数方程形式<br>通过曲线上某一点并且与该点的切线相垂直的直线称为曲线在该点处的法平面，明显法平面的法向量就是切线的方向向量，因此写出点法式方程即可</p><h3 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h3><h4 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h4><p>定理 如果函数$f(x, y)$在点$P_{0}\left(x_{0}, y_{0}\right)$可微分, 那么函数在该点沿任一方向$l$的方向导数存在,且</p><script type="math/tex; mode=display">\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0} . y_{0}\right)}=f_{x}\left(x_{0}, y_{0}\right) \cos \alpha+f_{y}\left(x_{0}, y_{0}\right) \cos \beta</script><p>$\text { 其中 } \cos \alpha \text { 和 } \cos \beta \text { 是方向 } l \text { 的方向余弦. }$</p><h4 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h4><p>![[Pasted image 20230617225551.png]]<br>![[Pasted image 20230617225916.png]]</p><h3 id="多元函数极值"><a href="#多元函数极值" class="headerlink" title="多元函数极值"></a>多元函数极值</h3><ol><li>如果多元函数在某点具有偏导数而且在此处取得极值，那么其偏导数的函数值均为零</li><li>![[Pasted image 20230617230223.png]]<h4 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h4>对于自变量有附加条件的极值称为条件极值，比如在$V=xyz$再加一个条件$a^2=2(xy+xz+yz)$，这类极值点的求法通常使用拉格朗日乘数法<br>例：试求函数<script type="math/tex; mode=display">z=f(x,y)</script>在条件<script type="math/tex; mode=display">\varphi(x,y)=0</script>下取得极值的必要条件。<br>解：<br>不妨设在$(x_0,y_0)$取得极值，$\varphi(x,y)=0$可以确定一个连续且具有连续导数的函数$y=\psi(x)$，有<script type="math/tex; mode=display">\left.\frac{\mathrm{d} y}{\mathrm{~d} x}\right|_{x=x_{0}}=-\frac{\varphi_{x}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}</script>带回原函数有<script type="math/tex; mode=display">z=f[x, \psi(x)]</script>此时对$x$求导，由于$x$为唯一变量，因此只需令导数为零即求得取得极值的条件<script type="math/tex; mode=display">\left.\frac{\mathrm{d} z}{\mathrm{~d} x}\right|_{x=x_{0}}=f_{x}\left(x_{0}, y_{0}\right)+\left.f_{y}\left(x_{0}, y_{0}\right) \frac{\mathrm{d} y}{\mathrm{~d} x}\right|_{x=x_{0}}=0</script>联立上式有<script type="math/tex; mode=display">f_{x}\left(x_{0}, y_{0}\right)-f_{y}\left(x_{0}, y_{0}\right) \frac{\varphi_{x}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}=0</script>不妨令<script type="math/tex; mode=display">\frac{f_{y}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}=-\lambda</script>上述条件变为<script type="math/tex; mode=display">\left\{\begin{array}{l}f_{x}\left(x_{0}, y_{0}\right)+\lambda \varphi_{x}\left(x_{0}, y_{0}\right)=0\\f_{y}\left(x_{0}, y_{0}\right)+\lambda \varphi_{y}\left(x_{0}, y_{0}\right)=0 \\\varphi\left(x_{0}, y_{0}\right)=0 \end{array}\right.</script>引进拉格朗日函数<script type="math/tex; mode=display">L(x, y)=f(x, y)+\lambda \varphi(x, y)</script>其中$\lambda$称为拉格朗日算子，不难看出可以写成<script type="math/tex; mode=display">\left\{\begin{array}{l}L_x(x_0,y_0)=0\\L_y(x_0,y_0)=0\\\varphi\left(x_{0}, y_{0}\right)=0 \end{array}\right.</script>解出极值点之后带回原函数检验即可，对于自变量多于两个而条件多于一个的场景，拉格朗日函数加上对应的条件函数并乘上未知系数，联立方程组时将所有的拉格朗日函数的偏导数和条件全部联立解方程即可。<h1 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h1><h2 id="正项项级数审敛法"><a href="#正项项级数审敛法" class="headerlink" title="正项项级数审敛法"></a>正项项级数审敛法</h2></li><li>比较审敛法及其极限形式</li><li>比值审敛法</li><li>根植审敛法</li><li>如果<script type="math/tex; mode=display">\lim\limits_{n \rightarrow +\infty}u_n \ne0</script>则级数一定发散 </li><li>对数审敛法</li></ol>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
